---
title: Java中的锁
date: 2020-08-04 17:25:19
categories:
	- Java并发
	- 锁
---

### Lock简介

> 锁是一种工具，用于控制对共享资源的访问。

Lock和Synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。
Lock并不是用来代替Synchronized的，而是当使用Synchronized不合适或不足以满足要求的时候，来提供高级功能的。
Lock接口最常见的实体类是ReentrantLock。
通常情况下，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可以并发访问，比如ReadWriteLock里面的ReadLock。

<!--more-->

### 为什么需要Lock?

**Synchronized不够用**

（1）效率低：锁的释放情况少、试图获得锁是不能设定超时、不能中断一个正在试图获得锁的线程。
（2）不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。
（3）无法知道是否成功获取到锁。

### Lock主要方法介绍

**◆lock()**

就是最普通的获取锁。如果锁已被其他线程获取，则进行等待。

注意：Lock不会像synchronized一样在异常时自动释放锁。
因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放。
lock()方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock()就会陷入永久等待。

**◆tryLock**()

用来尝试获取锁，如果当前锁没有被其他线程占用，若获取成功，则返回true，否则返回false，代表获取锁失败。
相比于lock()，这样的方法显得功能更强大了，我们可以根据是否能获取锁来决定后续程序的行为。该方法会立即返回，即便在拿不到锁也是不会一直在那等待。

**◆tryLock(long time, TimeUnit unit)**

一定时间内尝试获取锁，超时就放弃。

**◆lockInterruptibly**()

相当于tryLock(long time, TimeUnit unit)把超时时间设为无限。在等待锁的过程中，线程可以被中断。

**◆unlock**()

释放锁。

### 可见性保证（happens-before）

Lock的加解锁和synchronized有同样的内存语义：下一个线程加锁后可以看到前一个线程解锁前发生的操作

### 锁的分类

1. 乐观锁/悲观锁
2. 可重入锁/不可重入锁
3. 公平锁/非公平锁
4. 独享锁（互斥锁）/共享锁（读写锁）
5. 自旋锁/阻塞锁
6. 可中断锁/不可中断锁

这些分类，是从各种不同角度出发去看的，这些分类并不互斥，也就是多个类型可以并存；有可能一个锁，同时属于两种类型。比如ReentrantLock既是互斥锁，又是可重入锁。

#### 乐观锁和悲观锁

为什么会诞生非互斥同步锁（乐观锁）？

互斥同步锁（悲观锁）的劣势:

①阻塞和唤醒带来的性能劣势

永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行

②优先级反转

优先级高的线程可能在等待优先级低的线程释放锁

#### 悲观锁

如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据是，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失。
Java中悲观锁的实现就是synchronized和Lock相关类。

#### 乐观锁

认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果没被改变过，就说明真的是只有我自己在操作，那我就正常去修改数据。如果数据和我一开始拿到的不一样，说明其他人在这段时间修改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略。乐观锁的实现一般都是利用CAS算法来实现的。
乐观锁的典型例子就是原子类、并发容器等。

##### 典型例子

Git就是乐观锁的典型例子，当我们往远端仓库push的时候，git会检查远端仓库的版本是不是领先于我们现在的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码了，我们的这次提交就失败；如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库

##### 开销对比

悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。

相反，虽然乐观锁一开始开销比悲观锁小，但是如果自旋时间很长或者不断重试，那么消耗的资源也会越来越多。

##### 各有千秋

悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，典型情况：
（1）临界区有IO操作。
（2）临界区代码复杂或者循环量大。
（3）临界区竞争非常激烈。

乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高。

#### 可重入锁/不可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
好处：可重入锁的一个好处是可一定程度避免死锁，提升封装性（加解锁）。
源码对比：可重入锁ReentrantLock以及非可重入锁ThreadPoolExecutor的Worker类。

![HTTP](/articleImage/2020-08-04/lock1.png)

![HTTP](/articleImage/2020-08-04/lock2.png)

#### 公平锁和非公平锁

公平指的是按照线程请求的顺序，来分配锁；非公平值的是，不完全按照请求的顺序，在一定情况下，可以插队。

##### 为什么要有非公平锁？

避免唤醒带来的空档期，提升吞吐量。

创建：如果在创建ReentrantLock对象时，参数填写为true，那么就是公平锁。

特例：针对 tryLock()方法，它不遵守设定的公平的规则。当有线程执行 tryLock0的时候，一旦有线程释放了锁，那么这个正在 tryLock的线程就能获取到锁，即使在它之前已经有其他现在在等待队列里了。

##### 公平锁和非公平锁的优缺点

**公平锁：**

优势：各线程公平平等，每个线程在等待一段时间后，总有执行的机会。
劣势：更慢，吞吐量更小。

**非公平锁：**

优势：更快，吞吐量更大。
劣势：有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行。

**源码分析：**
公平锁：判断队列中是否有在等待该锁的线程。
非公平锁：不判断。

![HTTP](/articleImage/2020-08-04/lock3.png)

#### 共享锁和排它锁ReentrantReadWriteLock

ReentrantReadWriteLock实现了ReadWriteLock接口。
最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。

排它锁，又称为独占锁、独享锁（Synchronized）。共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据。共享锁和排它锁的典型是读写锁ReentrantReadWriteLock,其中读锁是共享锁，写锁是独享锁

##### 读写锁的作用

多个读操作同时进行，并没有线程安全问题。
在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有读写锁的情况，读是无阻塞的，提高了程序的执行效率。

##### 读写锁的规则

（1）多个线程只申请读锁，都可以申请到。
（2）如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
（3）如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。

总结：要么是一个或多个线程同时有读锁，要么是一个线程又写锁，但是两者不会同时出现（要么多读，要么一写）

换一种思路更容易理解:读写锁只是一把锁，可以通过两种方式锁定读锁定和写锁定。读写锁可以同时被-个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定。

##### 读写锁插队策略（ReentrantReadWriteLock为例）

公平锁：不允许插队。
非公平锁：
○写锁可以随时插队。
○读锁仅在等待队列头结点不是想获取写锁的线程的时候可以插队。

#### 锁的升降级

**为什么需要升降级?**

持有写锁是浪费资源的，降低了整体的效率，所以这个时候利用锁的降级是很好的办法，可以提高整体性能。

**为什么不支持锁的升级？**

可能造成死锁：当两个线程同时申请升级锁，可能会导致都在等待对方释放锁。

**适用场景**：相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率。

#### 自旋锁和阻塞锁

◆阻塞或唤醒—个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。

◆如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

◆在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。

◆如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

◆而为了让当前线程“稍等一下”，我们需让当前线程进行自旋如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

◆阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒。

##### 自旋锁的缺点

如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的。

•在Java1.5版本及以上的并发框架 javautil.concurrent的 atmoic包下的类基本都是自旋锁的实现。
• AtomicInteger的实现:自旋锁的实现原理是CAS，Atomicinteger中调用 unsafe进行自增操作的源码中的do- While循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没修改成功，就在 while里死循环，直至修改成功。

##### 自旋锁的适用场景

自旋锁一般用于多核的服务器，在并发不是特别高的情况下，比阻塞锁的效率高另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），那也是不合适的。

#### 可中断锁

在Java中，synchronized是不可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断。
如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以中断它，这种就是可中断锁。

### Java虚拟机对锁的优化

#### 自旋锁和自适应

自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者立即睡眠，如果自旋锁已经被别的执行单元保持，调用者不放弃处理器的执行时间， 进行忙循环(自旋)， 看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。(JDK1.6以后默认开启了自旋锁) 自旋的次数默认是10次。自适应意味着自旋的时间不再是固定的， 而是由前一次在同一个锁上的自旋时间以及锁拥有者的状态来决定。如果在同一个锁对象上, 自旋等待刚好成功获得锁， 并且在持有锁的线程在运行中， 那么虚拟机就会认为这次自旋也是很有可能获得锁， 进而它将允许自旋等待相对更长的时间。

#### 锁消除

锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。锁削除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 

#### 锁粗化

锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。

### 我们在写代码时如何优化锁和提高并发性能

1.缩小同步代码块

2.尽量不要锁住方法

3.减少请求锁的次数

4.避免人为制造“热点”

5.锁中尽量不要再包含锁

6.选择合适的锁类型或合适的工具类

