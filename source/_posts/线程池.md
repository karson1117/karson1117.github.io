---
title: 线程池
date: 2020-07-24 15:20:19
categories:
	- Java并发
	- 线程池
---

### 线程池的自我介绍

* 线程池的重要性
* 什么是“池”
    * 软件中的“池”，也可以理解为计划经济
* 如果不使用线程池，每个任务都新开一个线程处理
    * 一个线程问题不大
    * 当任务数量上升到1000，for循环创建线程
* 这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。

<!--more-->

### 为什么要使用线程池
问题一：反复创建线程开销大
问题二：过多的线程会占用太多内存
解决以上两个问题的思路:
①用少量的线程--避免内存占用过多
②让这部分线程都保持工作，且可以反复执行任务

### 线程池的好处
* 加快响应速度
* 合理利用CPU和内存
* 统一管理

### 线程池适合应用的场合
* 服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率
* 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理

### 创建和停止线程池

* 线程池构造函数的参数
* 线程池应该手动创建还是自动创建
* 线程池里的线程数量设定为多少比较合适？
* 停止线程池的正确方法

#### 线程池构造函数的参数

![HTTP](/articleImage/2020-07-24/线程池构造函数的参数.png)

**corePoolSize（核心线程数）**
线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来再创建新线程去执行任务。

**maximumPoolSize（最大线程数） **
线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maximumPoolSize。

**keepAliveTime（存活时间）**
如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过KeepAliveTime，它们就会被终止。

**threadFactory（线程工厂）**
 用来创建线程,新的线程是由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。如果自己指定 ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。

**workQueue(工作队列)**
新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务
ArrayBlockingQueue:基于数组的有界阻塞队列，按FIFO排序。
LinkedBlockingQuene:基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

**handler（拒绝策略）** 
AbortPolicy ：抛出异常
DiscardPolicy : 直接丢弃，无通知
DiscardOldestPolicy : 丢弃最早的任务
CallerRunsPolicy ：由提交任务的线程去执行任务

#### 添加线程规则

1.如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。
2.如果线程数等于（或大于）corePoolSize但少于maxPoolSize，则将任务放入队列。
3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来执行任务。
4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。

是否需要增加线程的判断顺序是：

corePoolSize>>workQueue>>maxPoolSize

![HTTP](/articleImage/2020-07-24/线程池添加线程规则.png)


#### 增减线程的特点
1.通过设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程池。
2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。
3.通过设置maxPoolSize为很高的值，例如 Integer.MAX_VALUE 可以允许线程池容纳任意数量的并发任务。
4.是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。

#### 线程池应该手动创建还是自动创建
手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。

◆ newFixedPool
由于传进去的 LinkedBlockingQueue，是没有容量上限的所以当请求数越来越多，并且无法及时处理完毕的时候，
也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM

◆newSingleThreadExecutor
 可以看出，这里和刚才的 newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存。

◆newCachedThreadPool
可缓存线程池
特点:无界线程池，具有自动回收多余线程的功能
这里的弊端在于第二个参数 maximum Poolsize被设置为了 Integer. MAX_ VALUE，这可能会创建数量非常多的线程，甚至导致OOM。

◆ScheduledThreadPool
支持定时及周期性任务执行的线程池

#### 正确的创建线程池的方法

根据不同的业务场景，自己设置线程池参数，比如我们的
内存有多大，我们想给线程取什么名字等等

**线程池里的线程数量设定为多少比较合适？**

**CPU集型**（加控计算hash等）:最佳线程数为CPU核心数的1-2倍左右。
**耗时IO型**（读写数据库、文件、网络读写等）:最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为
依据，保证线程空闲可以衔接上，参考 Brain Goetz推荐的计算方法:

◆线程数=CPU核心数*（1+平均等待时间/平均工作时间）

#### 停止线程池的正确方法

1.shutdown，只是起到通知的作用,告诉线程池停止运行，此时线程不再接受新的任务，isShutDown=true。
2..isTerminated：真正的结束状态。
3.awaitTermination：等待一定时间后判断线程池是否已结束。
4.shutdownNow：主动中断所有子线程。

正确的调用顺序应该是: shutdown>>awaitTermination？shutdownNow