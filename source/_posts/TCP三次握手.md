---
title: TCP三次握手
date: 2020-07-03 13:53:37
categories:
	- Java面试
	- 计算机网络
---

### 传输控制协议TCP简介

- 面向连接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

![TCP报文](/articleImage/2020-07-03/3.jpg)

<!--more-->

**序列号seq**：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
**确认号ack**：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。
**确认ACK**：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
**同步SYN**：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
**终止FIN**：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。

![TCP Flags](/articleImage/2020-07-03/2.png)

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

![TCP Flags](/articleImage/2020-07-03/3.png)

**常见面试题：**
**1.为什么需要三次握手才能建立起连接**
		为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。

**2.首次握手的隐患---SYN超时**
		Server收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。
对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。
针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。

**3.建议连接后，client出现故障怎么办？**
		TCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。