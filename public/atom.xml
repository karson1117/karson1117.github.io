<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Karson&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dduggs.top/"/>
  <updated>2020-07-24T09:44:19.897Z</updated>
  <id>http://dduggs.top/</id>
  
  <author>
    <name>Karson</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义注解</title>
    <link href="http://dduggs.top/2020/07/24/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>http://dduggs.top/2020/07/24/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-07-24T09:27:44.000Z</published>
    <updated>2020-07-24T09:44:19.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA注解"><a href="#JAVA注解" class="headerlink" title="JAVA注解"></a><strong>JAVA注解</strong></h3><blockquote><p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。</p></blockquote><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a><strong>内置注解</strong></h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p> 1、作用在代码的注解:</p><ul><li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。<a id="more"></a></li></ul><p>2、作用在其他注解的注解(或者说<strong>元注解</strong>):</p><ul><li><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</li><li><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</li><li><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>3、从 Java 7 开始，额外添加了 3 个注解:</p><ul><li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a><strong>元注解</strong></h3><p>1、<strong>@Target</strong></p><p><code>@Target</code> 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值</p><ul><li>ElementType.TYPE 可以应用于类的任何元素。</li><li>ElementType.FIELD 可以应用于字段或属性。</li><li>ElementType.METHOD 可以应用于方法级注释。</li><li>ElementType.PARAMETER 可以应用于方法的参数。</li><li>ElementType.CONSTRUCTOR 可以应用于构造函数。</li><li>ElementType.LOCAL_VARIABLE 可以应用于局部变量。</li><li>ElementType.ANNOTATION_TYPE 可以应用于注释类型。</li><li>ElementType.PACKAGE 可以应用于包声明。</li><li>ElementType.TYPE_PARAMETER</li><li>ElementType.TYPE_USE</li></ul><p>2、<strong>@Retention</strong></p><p><code>@Retention</code> annotation指定标记注释的存储方式：</p><ul><li>RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。</li><li>RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。</li><li>RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。</li></ul><p>3、<strong>@Documented</strong></p><p><code>@Documented</code> 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。</p><p>4、<strong>@Inherited</strong></p><p><code>@Inherited</code> 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。</p><p>5、<strong>@Repeatable</strong></p><p>Repeatable Java SE 8中引入的，<code>@Repeatable</code>注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a><strong>自定义注解</strong></h3><p>Java中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * default extension name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> <span class="keyword">implements</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Annotation&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现Annotation接口中只有一个annotationType的方法，而且通过源码的注释我们可以发现答案是不能。<img src="/articleImage/2020-07-24/3.png" alt="img">汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。</p><h3 id="利用反射解析注解"><a href="#利用反射解析注解" class="headerlink" title="利用反射解析注解"></a><strong>利用反射解析注解</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取DemoClass的Class对象</span></span><br><span class="line">            DemoClass demo = DemoClass.builder().build();</span><br><span class="line">            Class clazz = demo.getClass();</span><br><span class="line">            <span class="comment">//判断DemoClass对象上是否有DemoAnnotation注解</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(DemoAnnotation<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"DemoClass类上配置了DemoAnnotation注解！"</span>);</span><br><span class="line">                <span class="comment">//获取该对象上DemoAnnotation类型的注解</span></span><br><span class="line">                DemoAnnotation demoAnno = (DemoAnnotation) clazz.getAnnotation(DemoAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"DemoClass.name :"</span> + demoAnno.value()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DemoClass类上没有配置DemoAnnotation注解！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例：自定义日期格式校验注解"><a href="#实例：自定义日期格式校验注解" class="headerlink" title="实例：自定义日期格式校验注解"></a>实例：<strong>自定义日期格式校验注解</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> karson</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;DateValidator.DateValidatorInner<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">DateValidator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须的属性</span></span><br><span class="line"><span class="comment">     * 显示 校验信息</span></span><br><span class="line"><span class="comment">     * 利用 &#123;&#125; 获取 属性值，参考了官方的message编写方式</span></span><br><span class="line"><span class="comment">     *<span class="doctag">@see</span> org.hibernate.validator 静态资源包里面 message 编写方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "日期格式不匹配</span>&#123;dateFormat&#125;<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 必须的属性</span></span><br><span class="line"><span class="string">     * 用于分组校验</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 非必须</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    String dateFormat() default "</span>yyyy-MM-dd HH:mm:ss<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 必须实现 ConstraintValidator接口</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    class DateValidatorInner implements ConstraintValidator&lt;DateValidator, String&gt; &#123;</span></span><br><span class="line"><span class="string">        private String dateFormat;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        @Override</span></span><br><span class="line"><span class="string">        public void initialize(DateValidator constraintAnnotation) &#123;</span></span><br><span class="line"><span class="string">            this.dateFormat = constraintAnnotation.dateFormat();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * 校验逻辑的实现</span></span><br><span class="line"><span class="string">         * @param value 需要校验的 值</span></span><br><span class="line"><span class="string">         * @return 布尔值结果</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        @Override</span></span><br><span class="line"><span class="string">        public boolean isValid(String value, ConstraintValidatorContext context) &#123;</span></span><br><span class="line"><span class="string">            if (value == null) &#123;</span></span><br><span class="line"><span class="string">                return true;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            if("</span><span class="string">".equals(value))&#123;</span></span><br><span class="line"><span class="string">                return true;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                Date date = DateUtils.parseDate(value, dateFormat);</span></span><br><span class="line"><span class="string">                return date != null;</span></span><br><span class="line"><span class="string">            &#125; catch (ParseException e) &#123;</span></span><br><span class="line"><span class="string">                return false;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JAVA注解&quot;&gt;&lt;a href=&quot;#JAVA注解&quot; class=&quot;headerlink&quot; title=&quot;JAVA注解&quot;&gt;&lt;/a&gt;&lt;strong&gt;JAVA注解&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内置注解&quot;&gt;&lt;a href=&quot;#内置注解&quot; class=&quot;headerlink&quot; title=&quot;内置注解&quot;&gt;&lt;/a&gt;&lt;strong&gt;内置注解&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。&lt;/p&gt;
&lt;p&gt; 1、作用在代码的注解:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Override&lt;/code&gt; - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Deprecated&lt;/code&gt; - 标记过时方法。如果使用该方法，会报编译警告。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt; - 指示编译器去忽略注解中声明的警告。
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://dduggs.top/2020/07/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://dduggs.top/2020/07/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-07-24T07:20:19.000Z</published>
    <updated>2020-07-24T08:07:06.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h3><ul><li>线程池的重要性</li><li>什么是“池”<ul><li>软件中的“池”，也可以理解为计划经济</li></ul></li><li>如果不使用线程池，每个任务都新开一个线程处理<ul><li>一个线程问题不大</li><li>当任务数量上升到1000，for循环创建线程</li></ul></li><li>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。</li></ul><a id="more"></a><h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><p>问题一：反复创建线程开销大<br>问题二：过多的线程会占用太多内存<br>解决以上两个问题的思路:<br>①用少量的线程–避免内存占用过多<br>②让这部分线程都保持工作，且可以反复执行任务</p><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ul><li>加快响应速度</li><li>合理利用CPU和内存</li><li>统一管理</li></ul><h3 id="线程池适合应用的场合"><a href="#线程池适合应用的场合" class="headerlink" title="线程池适合应用的场合"></a>线程池适合应用的场合</h3><ul><li>服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li><li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li></ul><h3 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h3><ul><li>线程池构造函数的参数</li><li>线程池应该手动创建还是自动创建</li><li>线程池里的线程数量设定为多少比较合适？</li><li>停止线程池的正确方法</li></ul><h4 id="线程池构造函数的参数"><a href="#线程池构造函数的参数" class="headerlink" title="线程池构造函数的参数"></a>线程池构造函数的参数</h4><p><img src="/articleImage/2020-07-24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0.png" alt="HTTP"></p><p><strong>corePoolSize（核心线程数）</strong><br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来再创建新线程去执行任务。</p><p><strong>maximumPoolSize（最大线程数）</strong><br>线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maximumPoolSize。</p><p><strong>keepAliveTime（存活时间）</strong><br>如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过KeepAliveTime，它们就会被终止。</p><p><strong>threadFactory（线程工厂）</strong><br> 用来创建线程,新的线程是由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。如果自己指定 ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</p><p><strong>workQueue(工作队列)</strong><br>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务<br>ArrayBlockingQueue:基于数组的有界阻塞队列，按FIFO排序。<br>LinkedBlockingQuene:基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p><p><strong>handler（拒绝策略）</strong><br>AbortPolicy ：抛出异常<br>DiscardPolicy : 直接丢弃，无通知<br>DiscardOldestPolicy : 丢弃最早的任务<br>CallerRunsPolicy ：由提交任务的线程去执行任务</p><h4 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h4><p>1.如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。<br>2.如果线程数等于（或大于）corePoolSize但少于maxPoolSize，则将任务放入队列。<br>3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来执行任务。<br>4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。</p><p>是否需要增加线程的判断顺序是：</p><p>corePoolSize&gt;&gt;workQueue&gt;&gt;maxPoolSize</p><p><img src="/articleImage/2020-07-24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png" alt="HTTP"></p><h4 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h4><p>1.通过设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程池。<br>2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。<br>3.通过设置maxPoolSize为很高的值，例如 Integer.MAX_VALUE 可以允许线程池容纳任意数量的并发任务。<br>4.是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。</p><h4 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h4><p>手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。</p><p>◆ newFixedPool<br>由于传进去的 LinkedBlockingQueue，是没有容量上限的所以当请求数越来越多，并且无法及时处理完毕的时候，<br>也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM</p><p>◆newSingleThreadExecutor<br> 可以看出，这里和刚才的 newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存。</p><p>◆newCachedThreadPool<br>可缓存线程池<br>特点:无界线程池，具有自动回收多余线程的功能<br>这里的弊端在于第二个参数 maximum Poolsize被设置为了 Integer. MAX_ VALUE，这可能会创建数量非常多的线程，甚至导致OOM。</p><p>◆ScheduledThreadPool<br>支持定时及周期性任务执行的线程池</p><h4 id="正确的创建线程池的方法"><a href="#正确的创建线程池的方法" class="headerlink" title="正确的创建线程池的方法"></a>正确的创建线程池的方法</h4><p>根据不同的业务场景，自己设置线程池参数，比如我们的<br>内存有多大，我们想给线程取什么名字等等</p><p><strong>线程池里的线程数量设定为多少比较合适？</strong></p><p><strong>CPU集型</strong>（加控计算hash等）:最佳线程数为CPU核心数的1-2倍左右。<br><strong>耗时IO型</strong>（读写数据库、文件、网络读写等）:最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为<br>依据，保证线程空闲可以衔接上，参考 Brain Goetz推荐的计算方法:</p><p>◆线程数=CPU核心数*（1+平均等待时间/平均工作时间）</p><h4 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h4><p>1.shutdown，只是起到通知的作用,告诉线程池停止运行，此时线程不再接受新的任务，isShutDown=true。<br>2..isTerminated：真正的结束状态。<br>3.awaitTermination：等待一定时间后判断线程池是否已结束。<br>4.shutdownNow：主动中断所有子线程。</p><p>正确的调用顺序应该是: shutdown&gt;&gt;awaitTermination？shutdownNow</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程池的自我介绍&quot;&gt;&lt;a href=&quot;#线程池的自我介绍&quot; class=&quot;headerlink&quot; title=&quot;线程池的自我介绍&quot;&gt;&lt;/a&gt;线程池的自我介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;线程池的重要性&lt;/li&gt;
&lt;li&gt;什么是“池”&lt;ul&gt;
&lt;li&gt;软件中的“池”，也可以理解为计划经济&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果不使用线程池，每个任务都新开一个线程处理&lt;ul&gt;
&lt;li&gt;一个线程问题不大&lt;/li&gt;
&lt;li&gt;当任务数量上升到1000，for循环创建线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java并发" scheme="http://dduggs.top/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="http://dduggs.top/categories/Java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="http://dduggs.top/2020/07/09/socket/"/>
    <id>http://dduggs.top/2020/07/09/socket/</id>
    <published>2020-07-09T03:50:49.000Z</published>
    <updated>2020-07-09T06:08:13.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><blockquote><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p><p>也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识</p></blockquote><a id="more"></a><p><img src="/articleImage/2020-07-09/1.png" alt="UDP报文"></p><h3 id="Socket通信过程"><a href="#Socket通信过程" class="headerlink" title="Socket通信过程"></a>Socket通信过程</h3><p><img src="/articleImage/2020-07-09/socket1.jpg" alt="UDP报文"></p><p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p><h4 id="Socket面试题"><a href="#Socket面试题" class="headerlink" title="Socket面试题"></a>Socket面试题</h4><p>编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。</p><p><a href="https://www.cnblogs.com/zhzhlong/p/9296850.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Socket&quot;&gt;&lt;a href=&quot;#Socket&quot; class=&quot;headerlink&quot; title=&quot;Socket&quot;&gt;&lt;/a&gt;Socket&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。&lt;br&gt;所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。&lt;/p&gt;
&lt;p&gt;也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS</title>
    <link href="http://dduggs.top/2020/07/08/Http%E4%B8%8EHttps/"/>
    <id>http://dduggs.top/2020/07/08/Http%E4%B8%8EHttps/</id>
    <published>2020-07-08T08:37:13.000Z</published>
    <updated>2020-07-08T09:32:35.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><blockquote><p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p></blockquote><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><blockquote><p>SSL（Security Sockets Layer，安全套接层）<br>为网络通信提供安全及数据完整性的一种安全协议<br>是操作系统对外的API，SSL3.0后更名为TLS<br>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p></blockquote><a id="more"></a><h4 id="加密的方式"><a href="#加密的方式" class="headerlink" title="加密的方式"></a>加密的方式</h4><p>对称加密：加密和解密都使用同一个密钥<br>非对称加密：加密使用的密钥和解密使用的密钥是不相同的<br>哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 （例如：MD5）<br>数字签名：证明某个消息或者文件是某人发出/认同的/未被修改过的。（将要发送的内容hash后的值一同传输）</p><h4 id="HTTPS数据传输流程"><a href="#HTTPS数据传输流程" class="headerlink" title="HTTPS数据传输流程"></a>HTTPS数据传输流程</h4><p><img src="/articleImage/2020-07-08/4.jpg" alt="HTTP"></p><ol><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>浏览器将支持的加密算法信息发送给服务器。</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。</li><li>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器。</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器。</li><li>浏览器解密响应消息，并对消息整形验证，之后进行加密交互数据。</li></ol><p><img src="/articleImage/2020-07-08/5.png" alt="HTTP"></p><p><strong>数字证书内容</strong><br>包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。</p><p><strong>验证证书安全性过程</strong><br>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。<br>然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。<br>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。</p><h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h4><ol><li>HTTPS需要到CA申请证书，HTTP不需要。</li><li>HTTPS密文传输，HTTP明文传输。</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口。</li><li>HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全。</li></ol><h4 id="HTTPS真的安全吗？"><a href="#HTTPS真的安全吗？" class="headerlink" title="HTTPS真的安全吗？"></a>HTTPS真的安全吗？</h4><p>浏览器默认填充http:// ，请求需要进行跳转，有被劫持的风险<br><em>可以使用HSTS优化</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。&lt;/p&gt;
&lt;p&gt;PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;SSL&quot;&gt;&lt;a href=&quot;#SSL&quot; class=&quot;headerlink&quot; title=&quot;SSL&quot;&gt;&lt;/a&gt;SSL&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;SSL（Security Sockets Layer，安全套接层）&lt;br&gt;为网络通信提供安全及数据完整性的一种安全协议&lt;br&gt;是操作系统对外的API，SSL3.0后更名为TLS&lt;br&gt;采用身份验证和数据加密保证网络通信的安全和数据的完整性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP相关</title>
    <link href="http://dduggs.top/2020/07/08/HTTP%E7%9B%B8%E5%85%B3/"/>
    <id>http://dduggs.top/2020/07/08/HTTP%E7%9B%B8%E5%85%B3/</id>
    <published>2020-07-08T07:15:07.000Z</published>
    <updated>2020-07-08T08:35:03.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Http简介"><a href="#Http简介" class="headerlink" title="Http简介"></a>Http简介</h4><blockquote><p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。<br>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。<br>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p><p>HTTP是一个属于应用层的面向对象的协议，HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p></blockquote><a id="more"></a><p><img src="/articleImage/2020-07-08/1.jpg" alt="HTTP"></p><h4 id="Http特点"><a href="#Http特点" class="headerlink" title="Http特点"></a>Http特点</h4><p><strong>1.支持客户/服务器模式</strong><br>    HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><strong>2.简单快速</strong><br>    客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p><strong>3.灵活</strong><br>    HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p><strong>4.无连接</strong><br>    无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p><strong>5.无状态</strong><br>    HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h4 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h4><p><img src="/articleImage/2020-07-08/2.jpg" alt="HTTP"></p><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<br>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p><p><img src="/articleImage/2020-07-08/3.png" alt="HTTP"></p><h4 id="Http响应"><a href="#Http响应" class="headerlink" title="Http响应"></a>Http响应</h4><p><img src="/articleImage/2020-07-08/3.jpg" alt="HTTP"></p><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>第二部分：消息报头，用来说明客户端要使用的一些附加信息<br>第三部分：空行，消息报头后面的空行是必须的<br>第四部分：响应正文，服务器返回给客户端的文本信息。</p><p><img src="/articleImage/2020-07-08/4.png" alt="HTTP"></p><h4 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h4><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><blockquote><p><strong>1xx：指示信息–表示请求已接收，继续处理</strong><br><strong>2xx：成功–表示请求已被成功接收、理解、接受</strong><br><strong>3xx：重定向–要完成请求必须进行更进一步的操作</strong><br><strong>4xx：客户端错误–请求有语法错误或请求无法实现</strong><br><strong>5xx：服务器端错误–服务器未能实现合法的请求</strong></p></blockquote><p><strong>常见状态码：</strong></p><ul><li>200 OK                        //客户端请求成功</li><li>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li><li>403 Forbidden                 //服务器收到请求，但是拒绝提供服务</li><li>404 Not Found                 //请求资源不存在，eg：输入了错误的URL</li><li>500 Internal Server Error     //服务器发生不可预期的错误</li><li>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><ul><li>GET     请求指定的页面信息，并返回实体主体。</li><li>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</li><li>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<br>POST请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>PUT     从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE      请求服务器删除指定的页面。</li><li>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS     允许客户端查看服务器的性能。</li><li>TRACE     回显服务器收到的请求，主要用于测试或诊断。</li></ul><h4 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。<br>以下是 HTTP 请求/响应的步骤：</p><p>1、客户端连接到Web服务器<br>    一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。<br>2、发送HTTP请求<br>    通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。<br>3、服务器接受请求并返回HTTP响应<br>    Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。<br>4、释放连接TCP连接<br>    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。<br>5、客户端浏览器解析HTML内容<br>    客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<br>6、浏览器将该 html 文本并显示内容;</p><h4 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h4><p>Http报文层面：GET请求的信息放在URL，POST请求信息放置在报文体中。<br>数据库层面：GET请求符合幂等性和安全性的，POST不符合。<br>其他层面：GET可以被缓存（浏览器书签、CDN）、存储，POST依赖Web服务端。</p><h4 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h4><p>Cookie简介</p><ul><li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求的时候，会把Cookie回发</li><li>服务器接收到后，会解析Cookie生成与客户端相对应的内容</li></ul><p>Session简介</p><ul><li>服务器端的机制，在服务器上保存的信息</li><li>解析客户端请求并操作session id，按需保存状态信息</li></ul><p>Session的实现方式</p><ul><li>使用Cookie实现</li><li>使用URL回写来实现，带上JSESSIONID参数</li></ul><p>Cookie和Session的区别</p><ul><li>Cookie数据存放在客户的浏览器上，Session数据放在服务器上</li><li>Session相对于Cookie更安全</li><li>若考虑减轻服务器负担，应当使用Cookie</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Http简介&quot;&gt;&lt;a href=&quot;#Http简介&quot; class=&quot;headerlink&quot; title=&quot;Http简介&quot;&gt;&lt;/a&gt;Http简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。&lt;br&gt;HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。&lt;br&gt;2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。&lt;/p&gt;
&lt;p&gt;HTTP是一个属于应用层的面向对象的协议，HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP滑动窗口</title>
    <link href="http://dduggs.top/2020/07/07/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://dduggs.top/2020/07/07/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2020-07-07T03:18:29.000Z</published>
    <updated>2020-07-07T06:19:01.673Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RTT：Round-Trip Time, 即往返时延，指发送一个数据包到收到对应的 ACK, 所花费的时间；<br>RTO：Retransmission TimeOut, 即重传时间间隔。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul><li>保证 TCP 的可靠性。</li><li>保证 TCP 的流控特性。        </li></ul><p>在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。</p><p><img src="/articleImage/2020-07-07/hdck1.png" alt="滑动窗口1"></p><a id="more"></a><p><strong>1.如何保持有序？</strong></p><p><img src="/articleImage/2020-07-07/3.png" alt="滑动窗口2"></p><p>​    双方按顺序确认对方已接收的包</p><p><strong>2.如何提高吞吐量？</strong></p><p>​    <img src="/articleImage/2020-07-07/4.png" alt="滑动窗口3"></p><p>​    同时发送多个包</p><p>3.Ack一直未确认如何处理？</p><p>​    超时重传</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;RTT：Round-Trip Time, 即往返时延，指发送一个数据包到收到对应的 ACK, 所花费的时间；&lt;br&gt;RTO：Retransmission TimeOut, 即重传时间间隔。&lt;/p&gt;
&lt;h4 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;保证 TCP 的可靠性。&lt;/li&gt;
&lt;li&gt;保证 TCP 的流控特性。        &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-07/hdck1.png&quot; alt=&quot;滑动窗口1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="http://dduggs.top/2020/07/07/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://dduggs.top/2020/07/07/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-07-07T02:17:43.000Z</published>
    <updated>2020-07-07T03:05:04.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UDP简介"><a href="#UDP简介" class="headerlink" title="UDP简介"></a>UDP简介</h3><blockquote><p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。</p></blockquote><p><img src="/articleImage/2020-07-07/udp.png" alt="UDP报文"></p><p>UDP首部由8个字节构成，每个字段都是两个字节。</p><p>1、源端口：源端口号，需要对方回信时选用，不需要时置0；<br>2、目标端口：目的端口号，在终点交付报文时需要用到；<br>3、头部长度：UDP的数据报长度（包含首部和数据），最小值为8字节（只有首部）；<br>4、校验和：检测UDP数据在传输中是否出错，有错则丢弃。</p><a id="more"></a><h3 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h3><ul><li><p>面向非连接</p></li><li><p>不维护连接状态，支持同时向多个客户端传输相同的消息。</p></li><li><p>数据包报头只有8个字节，额外开销较小。</p></li><li><p>吞吐量只受限于数据生成速率、传输速率以及机器性能。</p></li><li><p>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表。</p></li><li><p>面向报文，不对应用程序提交的报文信息进行拆分或者合并。</p></li></ul><p>在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><h3 id="UDP与TCP的区别"><a href="#UDP与TCP的区别" class="headerlink" title="UDP与TCP的区别"></a>UDP与TCP的区别</h3><ul><li><p>TCP是面向连接而UDP是面向非连接。</p></li><li><p>可靠性：TCP是客户端与服务端一对一通过握手实现传输，具有稳定的可靠性，而UDP可能会丢失，不确定有没有被接收。</p></li><li><p>有序性：TCP通过序列号保证了消息的正确性。</p></li><li><p>速度：TCP速度比较慢，因为需要建立连接。</p></li><li><p>量级：TCP是重量级的，而UDP是轻量级的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;UDP简介&quot;&gt;&lt;a href=&quot;#UDP简介&quot; class=&quot;headerlink&quot; title=&quot;UDP简介&quot;&gt;&lt;/a&gt;UDP简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-07/udp.png&quot; alt=&quot;UDP报文&quot;&gt;&lt;/p&gt;
&lt;p&gt;UDP首部由8个字节构成，每个字段都是两个字节。&lt;/p&gt;
&lt;p&gt;1、源端口：源端口号，需要对方回信时选用，不需要时置0；&lt;br&gt;2、目标端口：目的端口号，在终点交付报文时需要用到；&lt;br&gt;3、头部长度：UDP的数据报长度（包含首部和数据），最小值为8字节（只有首部）；&lt;br&gt;4、校验和：检测UDP数据在传输中是否出错，有错则丢弃。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP四次挥手</title>
    <link href="http://dduggs.top/2020/07/03/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://dduggs.top/2020/07/03/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2020-07-03T08:02:35.000Z</published>
    <updated>2020-07-03T10:20:23.751Z</updated>
    
    <content type="html"><![CDATA[<p>“挥手”是为了终止连接，TCP四次挥手的流程图如下：</p><p><img src="/articleImage/2020-07-03/4.png" alt="TCP Flags"></p><a id="more"></a><p><strong>第一次挥手：</strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br><strong>第二次挥手</strong>：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br><strong>第三次挥手</strong>：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br><strong>第四次挥手：</strong>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p>常见面试题：</p><p><strong>1.Time-Wait到Closed状态为什么需要等待2MSL(最长报文段生命)</strong><br>确保有足够的时间让对方收到ACK包<br>避免新旧连接混淆</p><p><strong>2.为什么需要四次握手才能断开连接</strong><br>因为全双工，发送方和接受方都需要FIN报文和ACK报文</p><p><strong>3.服务器出现大量CLOSE_WAIT状态的原因</strong><br>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<br>检查代码，特别是释放资源的代码<br>检查配置，特别是处理请求对的线程配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“挥手”是为了终止连接，TCP四次挥手的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-03/4.png&quot; alt=&quot;TCP Flags&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手</title>
    <link href="http://dduggs.top/2020/07/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://dduggs.top/2020/07/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2020-07-03T05:53:37.000Z</published>
    <updated>2020-07-03T08:00:40.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传输控制协议TCP简介"><a href="#传输控制协议TCP简介" class="headerlink" title="传输控制协议TCP简介"></a>传输控制协议TCP简介</h3><ul><li>面向连接的、可靠的、基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><p><img src="/articleImage/2020-07-03/3.jpg" alt="TCP报文"></p><a id="more"></a><p><strong>序列号seq</strong>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。<br><strong>确认号ack</strong>：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。<br><strong>确认ACK</strong>：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效<br><strong>同步SYN</strong>：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。<br><strong>终止FIN</strong>：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</p><p><img src="/articleImage/2020-07-03/2.png" alt="TCP Flags"></p><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p><img src="/articleImage/2020-07-03/3.png" alt="TCP Flags"></p><p><strong>常见面试题：</strong><br><strong>1.为什么需要三次握手才能建立起连接</strong><br>        为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。</p><p><strong>2.首次握手的隐患—SYN超时</strong><br>        Server收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。<br>对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。<br>针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。</p><p><strong>3.建议连接后，client出现故障怎么办？</strong><br>        TCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;传输控制协议TCP简介&quot;&gt;&lt;a href=&quot;#传输控制协议TCP简介&quot; class=&quot;headerlink&quot; title=&quot;传输控制协议TCP简介&quot;&gt;&lt;/a&gt;传输控制协议TCP简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;面向连接的、可靠的、基于字节流的传输层通信协议&lt;/li&gt;
&lt;li&gt;将应用层的数据流分割成报文段并发送给目标节点的TCP层&lt;/li&gt;
&lt;li&gt;数据包都有序号，对方收到则发送ACK确认，未收到则重传&lt;/li&gt;
&lt;li&gt;使用校验和来检验数据在传输过程中是否有误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-03/3.jpg&quot; alt=&quot;TCP报文&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://dduggs.top/2020/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://dduggs.top/2020/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-03T03:18:54.000Z</published>
    <updated>2020-07-08T09:38:30.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h3><p><img src="/articleImage/2020-07-03/1.png" alt="七层协议"></p><h5 id="第一层：物理层"><a href="#第一层：物理层" class="headerlink" title="第一层：物理层"></a>第一层：物理层</h5><p>解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。<br>物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率<br>主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。<br>层数据：比特<br>存在的物理设备：网卡</p><a id="more"></a><h5 id="第二层：数据链路层"><a href="#第二层：数据链路层" class="headerlink" title="第二层：数据链路层"></a>第二层：数据链路层</h5><p>在传输比特流的时候会出现错传、传输不完整的情况，因此数据链路层应运而生，它定了如何格式化数据以进行传输，提供错误检测和纠正，以确保数据传输的可靠性<br>层数据：帧<br>存在的物理设备：交换机（对帧解码，并根据帧中包含的信息，把数据发送给正确的接收方）。</p><h5 id="第三层，网络层"><a href="#第三层，网络层" class="headerlink" title="第三层，网络层"></a>第三层，网络层</h5><p>随着网络节点的不断增加，点对点通信的时候需要经过多个结点，如何到达目标节点、如何选择最佳路径便成为了首要需求。<br>作用：是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先级，网络拥塞程度，服务质量，可选路由的花费决定从节点A到结点B的最佳路径。<br>层数据：（分组）数据报 存在的物理设备：路由器（由于网络层处理并智能指导数据传送，路由器连接网络各段）<br>需要关注的协议： IP</p><h5 id="第四层，传输层"><a href="#第四层，传输层" class="headerlink" title="第四层，传输层"></a>第四层，传输层</h5><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很多时间，而网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发出的数据进行切分，切割为一个一个的段落，即segment进行发送，其中一个段落丢失了该怎么办，要不要重传，每个段落要按照顺序到达吗。这便是传输层需要考虑的问题。<br>传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，同时传输层解决了传输质量的问题，该层是OSI模型中最重要的一层。具有传输协议，同时进行流量控制，或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网不能直接接收大于1500字节的数据包，发送方结点的传输层将数据分割成较小的数据片，同时为每一数据片安排序列号，以便数据到达接收方结点的传输层时能以正确的顺序重组，该过程称为排序。<br>层数据：分段<br>需要关注的协议：TCP/UDP</p><h5 id="第五层，会话层"><a href="#第五层，会话层" class="headerlink" title="第五层，会话层"></a>第五层，会话层</h5><p>现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道每次都需要调用tcp协议去打包，然后调IP协议去找路由，自己去发，这样当然不行。因此我们要建立一个自动收发包，自动寻址的功能。于是发明了会话层<br>作用：建立和管理应用程序间的通讯</p><h5 id="第六层，表示层"><a href="#第六层，表示层" class="headerlink" title="第六层，表示层"></a>第六层，表示层</h5><p>现在能保证应用程序能自动收发包和寻址，但我要用linux给windows发包，两个系统的语法不一致。<br>作用：解决不同系统之间的通信语法问题，在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用网络的类型不同而不同。</p><h5 id="第七层，应用层"><a href="#第七层，应用层" class="headerlink" title="第七层，应用层"></a>第七层，应用层</h5><p>此时虽然发送方知道发送的是什么东西，转换成字节数组有多长，但接收方不知道，所以应用层的网络协议诞生了<br>作用：规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，方便接受方能够正确解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层，你也可以直接在两台电脑传递，只不过都是1、0的字节数组。<br>需要关注的协议：http协议</p><p>从应用层开始都会对要传输信息的头部进行处理，加上本层的一些信息，最终物理层通过以太网，电缆等介质将数据解析成比特流，在网络中传输。数据传递到目标地址并自底而上的将头部的内容解析分离出来。</p><p>OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的指定。即OSI参考模型并不是一个标准，而是制定标准是所使用的概念性框架。<br>TCP\IP : OSI的一种实现</p><p><img src="/articleImage/2020-07-03/osi.gif" alt="OSI"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络基础知识&quot;&gt;&lt;a href=&quot;#网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;网络基础知识&quot;&gt;&lt;/a&gt;网络基础知识&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-03/1.png&quot; alt=&quot;七层协议&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;第一层：物理层&quot;&gt;&lt;a href=&quot;#第一层：物理层&quot; class=&quot;headerlink&quot; title=&quot;第一层：物理层&quot;&gt;&lt;/a&gt;第一层：物理层&lt;/h5&gt;&lt;p&gt;解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。&lt;br&gt;物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率&lt;br&gt;主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。&lt;br&gt;层数据：比特&lt;br&gt;存在的物理设备：网卡&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo博客多电脑同步（hexo+GitHub）</title>
    <link href="http://dduggs.top/2020/06/29/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5/"/>
    <id>http://dduggs.top/2020/06/29/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5/</id>
    <published>2020-06-29T01:58:13.000Z</published>
    <updated>2020-07-02T09:54:51.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何让公司电脑A、家里电脑B都能同步编辑博客。"><a href="#1-如何让公司电脑A、家里电脑B都能同步编辑博客。" class="headerlink" title="1.如何让公司电脑A、家里电脑B都能同步编辑博客。"></a>1.如何让公司电脑A、家里电脑B都能同步编辑博客。</h3><p><strong>上传博客工程到Github</strong></p><p> 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#git初始化</span><br><span class="line">git init</span><br><span class="line">#添加仓库地址</span><br><span class="line">git remote add origin https:<span class="comment">//github.com/用户名/你的GitHub用户名.github.io.git </span></span><br><span class="line">#新建分支并切换到新建的分支</span><br><span class="line">git checkout -b 分支名 </span><br><span class="line">#添加所有本地文件到git</span><br><span class="line">git add . </span><br><span class="line">#git提交</span><br><span class="line">git commit -m <span class="string">"这里填写你本次提交的备注，内容随意"</span> </span><br><span class="line">#文件推送到hexo分支</span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><p><strong>从另一台电脑下载博客工程</strong></p><p>B电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。</p><p>然后输入以下命令<a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b 分支名 https:<span class="comment">//github.com/用户名/你的GitHub用户</span></span><br></pre></td></tr></table></figure><p>克隆下载完成后，进入到你项目的文件夹，重新配置你的hexo环境，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置</span><br><span class="line">sudo npm install -g hexo-cli </span><br><span class="line">#安装依赖库</span><br><span class="line">sudo npm install </span><br><span class="line">#安装git部署相关配置</span><br><span class="line">sudo npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>之后就可以创建撰写新的文章，并使用sudo hexo g -d命令创建并部署您的网站。</p><p><strong>撰写完后如何再次同步</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"提交的备注，内容随意"</span></span><br><span class="line">git push origin 分支名</span><br><span class="line">#没错，这个样就够了~你B电脑上的数据也已经同步到Github上面了。</span><br><span class="line">#那第二天到A电脑跟前，只需要执行以下命令就行</span><br><span class="line"></span><br><span class="line">git pull</span><br><span class="line">#这样，你的数据就全部同步到A电脑了，以后在部署完后，再次执行</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"提交的备注，内容随意"</span></span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><hr><p><strong>常见问题</strong></p><p>（1）修改主题后，主题文件无法推送至GitHub</p><p>可能是该子文件夹下有.git文件夹导致无法上传，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#删除子文件夹下.git后，依然无法提交子文件夹下的文件。</span></span><br><span class="line"><span class="bullet">1. </span>git rm --cached themes/yilia</span><br><span class="line"><span class="bullet">2. </span>git add .</span><br><span class="line"><span class="bullet">3. </span>git commit -m "xxx"</span><br><span class="line"><span class="bullet">4. </span>git push origin master</span><br></pre></td></tr></table></figure><p>（2）文章多标签格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line">- Hexo</span><br><span class="line">- GitHub</span><br><span class="line">- Git</span><br></pre></td></tr></table></figure><p>（3）文章缩略标识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>（4）添加评论GitTalk</p><p><strong>创建 gitalk.ejs</strong></p><p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/post/</code> 目录下创建 <code>gitalk.ejs</code> 并写入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;blueimp-md5&#x2F;2.10.0&#x2F;js&#x2F;md5.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">  clientID: &#39;&lt;%&#x3D;theme.gitalk.clientID%&gt;&#39;,</span><br><span class="line">  clientSecret: &#39;&lt;%&#x3D;theme.gitalk.clientSecret%&gt;&#39;,</span><br><span class="line">  repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class="line">  owner: &#39;&lt;%&#x3D;theme.gitalk.owner%&gt;&#39;,</span><br><span class="line">  admin: [&#39;&lt;%&#x3D;theme.gitalk.admin%&gt;&#39;],</span><br><span class="line">  id: md5(window.location.pathname),</span><br><span class="line">  distractionFreeMode: &lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>修改 article.ejs</strong></p><p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/article.ejs</code> 文件中最后一行 <code>“&lt;% } %&gt;”</code> 之前添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.gitalk.enable &amp;&amp; theme.gitalk.distractionFreeMode)&#123; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class="line">      key: post.slug,</span><br><span class="line">      title: post.title,</span><br><span class="line">      url: config.url+url_for(post.path)</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><strong>添加配置文件</strong></p><p>在 yilia 的配置文件<code>_config.yml</code> 中 gitment 配置下面添加如下配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#6. Gitalk</span><br><span class="line">gitalk: </span><br><span class="line">  enable: true    #用来做启用判断可以不用</span><br><span class="line">  clientID: your clientID    #Github上生成的 Settings Developer&#x2F;settings&#x2F;OAuth Apps</span><br><span class="line">  clientSecret: your clientSecret   #同上</span><br><span class="line">  repo: git_comment    #评论所在的github project</span><br><span class="line">  owner: findtheonlyway    #github用户名</span><br><span class="line">  admin: erbiduo    #可以初始化评论issue的github账户名称</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure><p>（5）微信分享二维码失效</p><p>打开<code>themes\yilia\layout\_partial\post\share.ejs</code>文件</p><p>把第49行中的 <code>//pan.baidu.com/share/qrcode?url=</code>修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=</span></span><br></pre></td></tr></table></figure><p>（6）添加文章分类</p><p><strong>1、添加categories链接</strong><br>打开yilia/_config.yml文件，menu处做出以下修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: <span class="regexp">/</span></span><br><span class="line"><span class="regexp">  分类: /</span>categories</span><br><span class="line">  归档: <span class="regexp">/archives</span></span><br></pre></td></tr></table></figure><p><strong>2、分类页面的构建</strong><br>新建categories页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page categories</span><br><span class="line">#该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。</span><br></pre></td></tr></table></figure><p>修改categories/index.md为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-06-11 10:13:21</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>生成html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:4000/categories/" target="_blank" rel="noopener">http://localhost:4000/categories/</a> ，即可看到categories页面，只不过现在的页面只有标题。</p><p><strong>3、修改 yilia 主题</strong><br>修改<em>yilia\source\main.0cf68a.css</em>，将下面的内容添加进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">category-all-page &#123;</span><br><span class="line">    margin: <span class="number">30</span>px <span class="number">40</span>px <span class="number">30</span>px <span class="number">40</span>px;</span><br><span class="line">    position: relative;</span><br><span class="line">    min-height: <span class="number">70</span>vh;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page h2 &#123;</span><br><span class="line">    margin: <span class="number">20</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-all-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-all &#123;</span><br><span class="line">    margin-top: <span class="number">20</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list &#123;</span><br><span class="line">    margin: <span class="number">0</span>;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    list-style: none;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-item &#123;</span><br><span class="line">    margin: <span class="number">10</span>px <span class="number">15</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-count &#123;</span><br><span class="line">    color: $grey;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-count:before &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">" ("</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-count:after &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">") "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item &#123;</span><br><span class="line">    margin: <span class="number">10</span>px <span class="number">10</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-count &#123;</span><br><span class="line">    color: $grey;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-count:before &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">" ("</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-count:after &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">") "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-child &#123;</span><br><span class="line">    padding-left: <span class="number">10</span>px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>4、多层分类</strong><br>新建<em>yilia/layout/categories.ejs</em>，输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"article article-type-post show"</span>&gt;</span><br><span class="line">  &lt;header <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-header"</span> style=<span class="string">"border-bottom: 1px solid #ccc"</span>&gt;</span><br><span class="line">  &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-title"</span> itemprop=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;%= page.title %&gt;</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>header&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% <span class="keyword">if</span> (site.categories.length)&#123; %&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"category-all-page"</span>&gt;</span><br><span class="line">    &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%- list_categories(site.categories, &#123;</span></span><br><span class="line"><span class="regexp">      show_count: true,</span></span><br><span class="line"><span class="regexp">      class: 'category-list-item',</span></span><br><span class="line"><span class="regexp">      style: 'list',</span></span><br><span class="line"><span class="regexp">      depth: 2,</span></span><br><span class="line"><span class="regexp">      separator: ''</span></span><br><span class="line"><span class="regexp">    &#125;) %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;<span class="regexp">/article&gt;</span></span><br></pre></td></tr></table></figure><p>找到 <em>layout/_partial/article.ejs</em> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#然后找到&lt;div class&#x3D;&quot;article-entry&quot; itemprop&#x3D;&quot;articleBody&quot;&gt;</span><br><span class="line">#与&lt;% if ((theme.reward_type &#x3D;&#x3D;&#x3D; 2 || (theme.reward_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;之间的内容全部替换为：</span><br><span class="line"></span><br><span class="line">&lt;% if (page.type &#x3D;&#x3D;&#x3D; &quot;tags&quot;) &#123; %&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tag-cloud-title&quot;&gt;</span><br><span class="line">&lt;%- _p(&#39;counter.tag_cloud&#39;, site.tags.length) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tag-cloud-tags&quot;&gt;</span><br><span class="line">&lt;%- tagcloud(&#123;</span><br><span class="line">min_font: 12,</span><br><span class="line">max_font: 30,</span><br><span class="line">amount: 200,</span><br><span class="line">color: true,</span><br><span class="line">start_color: &#39;#ccc&#39;,</span><br><span class="line">end_color: &#39;#111&#39;</span><br><span class="line">&#125;) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;% &#125; </span><br><span class="line">else if (page.type &#x3D;&#x3D;&#x3D; &#39;categories&#39;) &#123; </span><br><span class="line">%&gt; &lt;div class&#x3D;&quot;category-all-page&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;category-all-title&quot;&gt;</span><br><span class="line">&lt;%- _p(&#39;&#39;, site.categories.length) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;category-all&quot;&gt;</span><br><span class="line">&lt;%- list_categories() %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;&lt;%- post.excerpt %&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;%- post.content %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><strong>5、修改自己的文章</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo博客多电脑同步（hexo+GitHub）</span><br><span class="line">date: <span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">09</span>:<span class="number">58</span>:<span class="number">13</span></span><br><span class="line">tags: </span><br><span class="line">- Hexo</span><br><span class="line">- GitHub</span><br><span class="line">- Git</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br></pre></td></tr></table></figure><p>（7）分页显示错误</p><p>首先找到<em>blog\themes\yilia\layout_partial\archive.ejs</em></p><p>修改两处，分别在8，9行与37，38行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br><span class="line">&lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class="line">  &lt;nav id&#x3D;&quot;page-nav&quot;&gt;</span><br><span class="line">    &lt;%- paginator(&#123;</span><br><span class="line">      prev_text: &#39;上一页&#39;,</span><br><span class="line">      next_text: &#39;下一页&#39;</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后找到<em>blog\themes\yilia\layout_partial\script.ejs</em><br>ctrl + f 搜索 next &amp;raquo</p><p><img src="/articleImage/2020-06-29/1.png" alt="script.ejs"></p><p>找到图片中框选的两处， 分别改为上一页与下一页</p><p><img src="/articleImage/2020-06-29/2.png" alt="script.ejs"></p><p><a href="https://cloud.tencent.com/developer/article/1046404" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://blog.csdn.net/dta0502/article/details/89607895" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-如何让公司电脑A、家里电脑B都能同步编辑博客。&quot;&gt;&lt;a href=&quot;#1-如何让公司电脑A、家里电脑B都能同步编辑博客。&quot; class=&quot;headerlink&quot; title=&quot;1.如何让公司电脑A、家里电脑B都能同步编辑博客。&quot;&gt;&lt;/a&gt;1.如何让公司电脑A、家里电脑B都能同步编辑博客。&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;上传博客工程到Github&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#git初始化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#添加仓库地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin https:&lt;span class=&quot;comment&quot;&gt;//github.com/用户名/你的GitHub用户名.github.io.git &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#新建分支并切换到新建的分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b 分支名 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#添加所有本地文件到git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add . &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#git提交&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;这里填写你本次提交的备注，内容随意&quot;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#文件推送到hexo分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin 分支名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;从另一台电脑下载博客工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。&lt;/p&gt;
&lt;p&gt;然后输入以下命令
    
    </summary>
    
    
      <category term="博客" scheme="http://dduggs.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://dduggs.top/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://dduggs.top/tags/GitHub/"/>
    
      <category term="Git" scheme="http://dduggs.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>无代码侵入调试dubbo服务</title>
    <link href="http://dduggs.top/2020/06/28/Local-Debug-Dubbo/"/>
    <id>http://dduggs.top/2020/06/28/Local-Debug-Dubbo/</id>
    <published>2020-06-28T10:58:48.000Z</published>
    <updated>2020-07-02T03:33:48.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-提供者（Provider-service）"><a href="#1-提供者（Provider-service）" class="headerlink" title="1.提供者（Provider-service）"></a>1.提供者（Provider-service）</h3><p>​    dubbo.xml中添加<strong>register=”false”</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"$&#123;zookeeper.cluster&#125;"</span> <span class="attr">register</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-消费者（Consumer-service）"><a href="#2-消费者（Consumer-service）" class="headerlink" title="2.消费者（Consumer-service）"></a>2.消费者（Consumer-service）</h3><p>​        在本地任意位置新建配置文件:dubbo-local-consumer.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是你们DubboServer.xml中配置的需要Export Service，</span></span><br><span class="line"><span class="comment"># 建议你有几个要Export Service都配置在这里，后面是请求本地的地址</span></span><br><span class="line"><span class="comment"># 地址格式：dubbo://ip:port，这里需要注意的是，需要修改为自己dubbo服务的端口</span></span><br><span class="line"><span class="meta">com.xxxService</span>=<span class="string">dubbo://localhost:20880</span></span><br></pre></td></tr></table></figure><p>​        设置启动参数指向该配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动参数：</span></span><br><span class="line"><span class="meta">-Ddubbo.resolve.file</span>=<span class="string">/C:\workspace\dubbo-local-consumer.properties</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-提供者（Provider-service）&quot;&gt;&lt;a href=&quot;#1-提供者（Provider-service）&quot; class=&quot;headerlink&quot; title=&quot;1.提供者（Provider-service）&quot;&gt;&lt;/a&gt;1.提供者（Provider-se
      
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="效率" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="dubbo" scheme="http://dduggs.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Centos6下redis安装配置</title>
    <link href="http://dduggs.top/2017/07/21/redis_install/"/>
    <id>http://dduggs.top/2017/07/21/redis_install/</id>
    <published>2017-07-21T05:34:00.000Z</published>
    <updated>2020-07-02T03:26:01.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Remote Dictionary Server(Redis)<br>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p></blockquote><a id="more"></a><h3 id="1、安装需要的支持环境"><a href="#1、安装需要的支持环境" class="headerlink" title="1、安装需要的支持环境"></a>1、安装需要的支持环境</h3><p>在安装Redis之前首要先做的是安装Unix的Tcl工具，如果不安装的话后期将无法对Redis进行测试。在后期执行make test的时候返回如下错误信息：You need tcl 8.xuyao de5 or newer in order to run the Redis test，具体的流程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;tcl&#x2F;tcl8.6.3-src.tar.gz</span><br><span class="line">tar -zxvf tcl8.6.3-src.tar.gz</span><br><span class="line">cd ​tcl8.6.3&#x2F;unix&#x2F;</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="2、安装redis"><a href="#2、安装redis" class="headerlink" title="2、安装redis"></a>2、安装redis</h3><p>安装redis的过程非常的简单，具体教程官网也有。具体如下：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class="line">tar zxvf redis-2.8.19.tar.gz</span><br><span class="line">cd redis-2.8.19</span><br><span class="line">make</span><br><span class="line">make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install</span><br></pre></td></tr></table></figure><p>其中PREFIX=/usr/local/redis可以省略，省略情况下redis会默认安装到/usr/local/bin目录下。</p><h3 id="3、测试Redis"><a href="#3、测试Redis" class="headerlink" title="3、测试Redis"></a>3、测试Redis</h3><pre><code>cd srcmake test通过以上命令就可以对redis进行加大的测试。</code></pre><h3 id="4、配置redis"><a href="#4、配置redis" class="headerlink" title="4、配置redis"></a>4、配置redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#拷贝并修改配置文档</span><br><span class="line">cp .&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#我只修改了如下几项：</span><br><span class="line">daemonize yes #redis将以守护进程的方式运行，默认为no会暂用你的终端</span><br><span class="line">timeout 300​ #当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">requirepass yourpassword #设置密码</span><br><span class="line">#bind 127.0.0.1 #限制了只能本地连接</span><br><span class="line">另外，设置密码后，使用redis-cli登录要带密码登录</span><br><span class="line">否则操作redis会出现身份认证的错误</span><br><span class="line">命令如下:</span><br><span class="line">redis-cli -a youPassword</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#B、启动或关闭服务</span><br><span class="line">service redis start</span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure><h3 id="5、使用redis"><a href="#5、使用redis" class="headerlink" title="5、使用redis"></a>5、使用redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">[root@localhost bin]# .&#x2F;redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set name cjs</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;cjs&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="6、java使用redis"><a href="#6、java使用redis" class="headerlink" title="6、java使用redis"></a>6、java使用redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><pre><code>public final class RedisUtil {//Redis服务器IPprivate static String ADDR = &quot;***.***.***.***&quot;;//Redis的端口号private static int PORT = 6379;//访问密码private static String AUTH = &quot;****&quot;;//可用连接实例的最大数目，默认值为8；//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。private static int MAX_ACTIVE = 1024;//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。private static int MAX_IDLE = 200;//等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；private static int MAX_WAIT = 10000;private static int TIMEOUT = 10000;//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；private static boolean TEST_ON_BORROW = true;private static JedisPool jedisPool = null;/** * 初始化Redis连接池 */static {    try {        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxIdle(MAX_IDLE);        //jedis高版本JedisPoolConfig没有maxActive改名为：        config.setMaxTotal(MAX_ACTIVE);        config.setMaxWaitMillis(MAX_WAIT);        config.setTestOnBorrow(TEST_ON_BORROW);        jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);    } catch (Exception e) {        e.printStackTrace();    }}/** * 获取Jedis实例 * @return */public synchronized static Jedis getJedis() {    try {        if (jedisPool != null) {            Jedis resource = jedisPool.getResource();            return resource;        } else {            return null;        }    } catch (Exception e) {        e.printStackTrace();        return null;    }}/** * 释放jedis资源 * @param jedis */public static void returnResource(final Jedis jedis) {    if (jedis != null) {        jedisPool.returnResource(jedis);    }}}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Remote Dictionary Server(Redis)&lt;br&gt;是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/p&gt;
&lt;p&gt;它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="http://dduggs.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>List集合按对象的某个字段去重</title>
    <link href="http://dduggs.top/2017/05/26/duplicateRemoval/"/>
    <id>http://dduggs.top/2017/05/26/duplicateRemoval/</id>
    <published>2017-05-26T07:37:46.000Z</published>
    <updated>2020-07-02T03:33:18.050Z</updated>
    
    <content type="html"><![CDATA[<p>思路:<br>利用Set(集合)的不可重复性：List–&gt;Set–&gt;List<br>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：<br>●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。<br>●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</p><a id="more"></a><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>set集合的构造方式列出来了三种:new Comparator; lambda表达式; Comparator.comparing(); </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CompareTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CompanyMsgParam&gt; companyList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    CompanyMsgParam c1 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;001&quot;, &quot;A公司&quot;, &quot;0&quot;);</span><br><span class="line">    CompanyMsgParam c2 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;001&quot;, &quot;B公司&quot;, &quot;1&quot;);</span><br><span class="line">    CompanyMsgParam c3 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;002&quot;, &quot;C公司&quot;, &quot;2&quot;);</span><br><span class="line">    CompanyMsgParam c4 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;003&quot;, &quot;D公司&quot;, &quot;3&quot;);</span><br><span class="line">    companyList.add(c1);</span><br><span class="line">    companyList.add(c2);</span><br><span class="line">    companyList.add(c3);</span><br><span class="line">    companyList.add(c4);</span><br><span class="line">&#x2F;&#x2F;第一种</span><br><span class="line">    Set&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(new Comparator&lt;CompanyMsgParam&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(CompanyMsgParam com1, CompanyMsgParam com2) &#123;</span><br><span class="line">            return com1.getCompanyCode().compareTo(com2.getCompanyCode());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">    Set&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;((com1, com2) -&gt; com1.getCompanyCode().compareTo(com2.getCompanyCode()));</span><br><span class="line">&#x2F;&#x2F;第三种</span><br><span class="line">    Set&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(Comparator.comparing(CompanyMsgParam::getCompanyCode));</span><br><span class="line">    set.addAll(companyList);</span><br><span class="line"></span><br><span class="line">    companyList &#x3D; new ArrayList&lt;CompanyMsgParam&gt;(set);</span><br><span class="line"></span><br><span class="line">    for (CompanyMsgParam param : companyList) &#123;</span><br><span class="line">        System.out.println(param.getCompanyCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IDEA配置LanguageLevel和JavaCompiler版本的问题"><a href="#IDEA配置LanguageLevel和JavaCompiler版本的问题" class="headerlink" title="IDEA配置LanguageLevel和JavaCompiler版本的问题"></a>IDEA配置LanguageLevel和JavaCompiler版本的问题</h3><p>按个人需要修改下面的配置即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;思路:&lt;br&gt;利用Set(集合)的不可重复性：List–&amp;gt;Set–&amp;gt;List&lt;br&gt;Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：&lt;br&gt;●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。&lt;br&gt;●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>javaMail发送邮件</title>
    <link href="http://dduggs.top/2017/05/25/javaMail/"/>
    <id>http://dduggs.top/2017/05/25/javaMail/</id>
    <published>2017-05-25T06:39:47.000Z</published>
    <updated>2020-07-02T03:39:46.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..</p></blockquote><a id="more"></a>    <h3 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 发送邮件</span><br><span class="line"> * </span><br><span class="line"> * @param toAddress: 收件人邮箱</span><br><span class="line"> * @param mailSubject: 邮件主题</span><br><span class="line"> * @param mailBody: 邮件正文</span><br><span class="line"> * @param mailBodyIsHtml: 邮件正文格式,true:HTML格式;false:文本格式</span><br><span class="line"> * &#x2F;&#x2F;@param inLineFile: 内嵌文件</span><br><span class="line"> * @param attachments: 附件</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean sendMail (String toAddress, String mailSubject, String mailBody, </span><br><span class="line">boolean mailBodyIsHtml, File[] attachments)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">&#x2F;&#x2F; 创建邮件发送类 JavaMailSender (用于发送多元化邮件，包括附件，图片，html 等    )</span><br><span class="line">       JavaMailSenderImpl mailSender &#x3D; new JavaMailSenderImpl();</span><br><span class="line">       mailSender.setHost(host); &#x2F;&#x2F; 设置邮件服务主机    </span><br><span class="line">       mailSender.setUsername(username); &#x2F;&#x2F; 发送者邮箱的用户名</span><br><span class="line">       mailSender.setPassword(password); &#x2F;&#x2F; 发送者邮箱的密码</span><br><span class="line">       </span><br><span class="line">&#x2F;&#x2F;配置文件，用于实例化java.mail.session    </span><br><span class="line">Properties pro &#x3D; new Properties();</span><br><span class="line">pro.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</span><br><span class="line">pro.put(&quot;mail.smtp.socketFactory.port&quot;, port);</span><br><span class="line">pro.put(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;);</span><br><span class="line">pro.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);</span><br><span class="line">mailSender.setJavaMailProperties(pro);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建多元化邮件 (创建 mimeMessage 帮助类，用于封装信息至 mimeMessage)</span><br><span class="line">MimeMessage mimeMessage &#x3D; mailSender.createMimeMessage();</span><br><span class="line">MimeMessageHelper helper &#x3D; new MimeMessageHelper(mimeMessage, ArrayUtils.isNotEmpty(attachments), &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">helper.setFrom(sendFrom, sendNick);</span><br><span class="line">helper.setTo(toAddress);</span><br><span class="line"></span><br><span class="line">helper.setSubject(mailSubject);</span><br><span class="line">helper.setText(mailBody, mailBodyIsHtml); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加内嵌文件，第1个参数为cid标识这个文件,第2个参数为资源</span><br><span class="line">&#x2F;&#x2F;helper.addInline(MimeUtility.encodeText(inLineFile.getName()), inLineFile);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加附件    </span><br><span class="line">if (ArrayUtils.isNotEmpty(attachments)) &#123;</span><br><span class="line">for (File file : attachments) &#123;</span><br><span class="line">helper.addAttachment(MimeUtility.encodeText(file.getName()), file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mailSender.send(mimeMessage);</span><br><span class="line">return true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行报错："><a href="#运行报错：" class="headerlink" title="运行报错："></a>运行报错：</h3><blockquote><p>“Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 550 User has no permission…..”</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>网易163邮箱 “设置–POP3/SMTP/IMAP” 中 “客户端授权” 未开启。<br>开启授权码后，它将代替邮箱密码在客户端使用。<br><img src="/img/articleImg/163sqm.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="JavaMail" scheme="http://dduggs.top/tags/JavaMail/"/>
    
  </entry>
  
  <entry>
    <title>java值传递还是引用传递</title>
    <link href="http://dduggs.top/2017/05/24/paramPass/"/>
    <id>http://dduggs.top/2017/05/24/paramPass/</id>
    <published>2017-05-24T07:48:36.000Z</published>
    <updated>2020-07-02T03:34:27.564Z</updated>
    
    <content type="html"><![CDATA[<p> 由一道面试题引发的问题：java是值传递还是引用传递？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    String str&#x3D;&quot;abc&quot;;</span><br><span class="line">    int a[]&#x3D;&#123;1,2,3&#125;;</span><br><span class="line">    int i&#x3D;1;</span><br><span class="line">    void change(String str,int a[],int i)&#123;</span><br><span class="line">        </span><br><span class="line">        str&#x3D;&quot;cbd&quot;;</span><br><span class="line">        a[0]&#x3D;4;</span><br><span class="line">        i&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        Test t&#x3D;new Test();</span><br><span class="line">        t.change(t.str,t.a,t.i);</span><br><span class="line">        System.out.println(t.str);</span><br><span class="line">        System.out.println(t.a[0]);</span><br><span class="line">        System.out.println(t.i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>运行结果<br>abc<br>4<br>1</p></blockquote><h3 id="1-按值传递是什么"><a href="#1-按值传递是什么" class="headerlink" title="1.按值传递是什么"></a>1.按值传递是什么</h3><p>指的是在方法调用时，传递的参数是按值的拷贝传递。<br>按值传递重要特点:传递的是值的拷贝，也就是说传递后就互不相关了。</p><h3 id="2-按引用传递是什么"><a href="#2-按引用传递是什么" class="headerlink" title="2.按引用传递是什么"></a>2.按引用传递是什么</h3><p>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。<br>按引用传递的重要特点:<br>传递的是值的引用，也就是说传递前和传递后都指向同一个引用(也就是同一个内存空间)。</p><p>详细博文见<a href="http://blog.csdn.net/zzp_403184692/article/details/8184751" target="_blank" rel="noopener">&gt;&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 由一道面试题引发的问题：java是值传递还是引用传递？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String str&amp;#x3D;&amp;quot;abc&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a[]&amp;#x3D;&amp;#123;1,2,3&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i&amp;#x3D;1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void change(String str,int a[],int i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        str&amp;#x3D;&amp;quot;cbd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[0]&amp;#x3D;4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i&amp;#x3D;2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Test t&amp;#x3D;new Test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.change(t.str,t.a,t.i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(t.str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(t.a[0]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(t.i++);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java8中如何处理时间</title>
    <link href="http://dduggs.top/2017/04/01/LocalDate/"/>
    <id>http://dduggs.top/2017/04/01/LocalDate/</id>
    <published>2017-04-01T05:12:06.000Z</published>
    <updated>2020-07-02T03:34:03.658Z</updated>
    
    <content type="html"><![CDATA[<p>Java8之前，Date类都是可变类<br>当我们在多线程环境下使用它<br>编程人员应该确认Date对象的线程安全<br>Java8的Date和Time API提供了线程安全的不可变类<br>编程人员不用考虑并发的问题<br><img src="/img/articleImg/time2.jpg" alt=""></p><a id="more"></a><h3 id="LocalDate用法"><a href="#LocalDate用法" class="headerlink" title="LocalDate用法"></a>LocalDate用法</h3><p>LocalDate只提供日期不提供时间信息。它是不可变类且线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取当前日期：</span><br><span class="line">LocalDate today &#x3D; LocalDate.now(); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class="line">&#x2F;&#x2F; 根据年月日取日期，04月就是04：</span><br><span class="line">LocalDate crischristmas &#x3D; LocalDate.of(2017, 04, 01); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class="line">&#x2F;&#x2F; 根据字符串取：</span><br><span class="line">LocalDate endOfFeb &#x3D; LocalDate.parse(&quot;2017-04-01&quot;); </span><br><span class="line">&#x2F;&#x2F; 严格按照ISO yyyy-MM-dd验证，04写成4都不行，当然也有一个重载方法允许自己定义格式</span><br><span class="line">LocalDate.parse(&quot;2017-02-29&quot;); &#x2F;&#x2F; 无效日期无法通过：DateTimeParseException: Invalid date...</span><br></pre></td></tr></table></figure><p>日期转换经常遇到，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取本月第1天：</span><br><span class="line">LocalDate firstDayOfThisMonth &#x3D; today.with(TemporalAdjusters.firstDayOfMonth()); &#x2F;&#x2F; 2017-04-01</span><br><span class="line">&#x2F;&#x2F; 取本月第2天：</span><br><span class="line">LocalDate secondDayOfThisMonth &#x3D; today.withDayOfMonth(2); &#x2F;&#x2F; 2017-04-02</span><br><span class="line">&#x2F;&#x2F; 取本月最后一天，再也不用计算是28，29，30还是31：</span><br><span class="line">LocalDate lastDayOfThisMonth &#x3D; today.with(TemporalAdjusters.lastDayOfMonth()); &#x2F;&#x2F; 2017-04-30</span><br><span class="line">&#x2F;&#x2F; 取下一天：</span><br><span class="line">LocalDate nextDayOf &#x3D; lastDayOfThisMonth.plusDays(1); &#x2F;&#x2F; 变成了2017-05-01</span><br><span class="line">&#x2F;&#x2F; 取2017年1月第一个周一，这个计算用Calendar要死掉很多脑细胞：</span><br><span class="line">LocalDate firstMondayOf2017 &#x3D; LocalDate.parse(&quot;2017-01-01&quot;).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); &#x2F;&#x2F; 2017-01-02</span><br></pre></td></tr></table></figure><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now &#x3D; LocalTime.now(); &#x2F;&#x2F; 11:09:09.240</span><br><span class="line">清除毫秒数：</span><br><span class="line">LocalTime now &#x3D; LocalTime.now().withNano(0)); &#x2F;&#x2F; 11:09:09</span><br><span class="line">构造时间：</span><br><span class="line">LocalTime zero &#x3D; LocalTime.of(0, 0, 0); &#x2F;&#x2F; 00:00:00</span><br><span class="line">LocalTime mid &#x3D; LocalTime.parse(&quot;12:00:00&quot;); &#x2F;&#x2F; 12:00:00</span><br></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：</p><blockquote><p>date -&gt; LocalDate<br>time -&gt; LocalTime<br>timestamp -&gt; LocalDateTime</p></blockquote><p>再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8之前，Date类都是可变类&lt;br&gt;当我们在多线程环境下使用它&lt;br&gt;编程人员应该确认Date对象的线程安全&lt;br&gt;Java8的Date和Time API提供了线程安全的不可变类&lt;br&gt;编程人员不用考虑并发的问题&lt;br&gt;&lt;img src=&quot;/img/articleImg/time2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>springmvc导出Excel问题记录</title>
    <link href="http://dduggs.top/2017/03/31/springmvcPost/"/>
    <id>http://dduggs.top/2017/03/31/springmvcPost/</id>
    <published>2017-03-31T08:18:15.000Z</published>
    <updated>2020-07-02T03:34:52.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringMVC中获取不到POST形式的参数<br>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何<br>对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。<br>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为<br>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。<br>但代码里强制使用了multipart/form-data方式。</p></blockquote><a id="more"></a><p>所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;       </span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>并将commons-fileupload-1.3.2jar包引入到项目中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- POI导出Exl --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。</p><p>注：此问题是在上一个项目<a href="https://coding.net/u/letra/p/mvcdemo/git" target="_blank" rel="noopener">git地址</a>的基础上新增了导出Ecxel功能是发现，在此记录一二。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SpringMVC中获取不到POST形式的参数&lt;br&gt;这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何&lt;br&gt;对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。&lt;br&gt;就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为&lt;br&gt;ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。&lt;br&gt;但代码里强制使用了multipart/form-data方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>IDEA+Maven+SpringMVC+Hibernate环境搭建</title>
    <link href="http://dduggs.top/2017/03/20/mvcdemo/"/>
    <id>http://dduggs.top/2017/03/20/mvcdemo/</id>
    <published>2017-03-20T06:09:10.000Z</published>
    <updated>2020-07-02T03:34:19.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一篇十分详细的博文<a href="http://blog.lunhui.ren/archives/235" target="_blank" rel="noopener">地址</a><br><a href="https://git.coding.net/letra/MvcDemo.git" target="_blank" rel="noopener">源码地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一篇十分详细的博文&lt;a href=&quot;http://blog.lunhui.ren/archives/235&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地址&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://git.coding.
      
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Spring" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Spring/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Comparable 接口</title>
    <link href="http://dduggs.top/2017/03/15/Comparable/"/>
    <id>http://dduggs.top/2017/03/15/Comparable/</id>
    <published>2017-03-15T08:37:39.000Z</published>
    <updated>2020-07-02T03:39:58.701Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/articleImg/compare.png" alt=""></p><blockquote><p>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。</p></blockquote><a id="more"></a><h3 id="例1：通过重量排序苹果"><a href="#例1：通过重量排序苹果" class="headerlink" title="例1：通过重量排序苹果"></a>例1：通过重量排序苹果</h3><p>在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。</p><pre><code>Collections.sort(apples);</code></pre><p>上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。<br>让我们开始写苹果类吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Comparable &#123;</span><br><span class="line">    private String variety;</span><br><span class="line">    private Color color;</span><br><span class="line">    private int weight;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Apple other) &#123;</span><br><span class="line">        if (this.weight &lt; other.weight) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.weight &#x3D;&#x3D; other.weight) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。</p><h3 id="例2：通过多个特征排序苹果"><a href="#例2：通过多个特征排序苹果" class="headerlink" title="例2：通过多个特征排序苹果"></a>例2：通过多个特征排序苹果</h3><p>正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Comparable &#123;</span><br><span class="line">    private String variety;</span><br><span class="line">    private Color color;</span><br><span class="line">    private int weight;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Apple other) &#123;</span><br><span class="line">        int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class="line">        if (result !&#x3D; 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            result &#x3D; this.color.compareTo(other.color);</span><br><span class="line">        &#125;</span><br><span class="line">        if (result !&#x3D; 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Apple other) &#123;</span><br><span class="line">     int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class="line">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          result &#x3D; this.color.compareTo(other.color);</span><br><span class="line">     &#125;</span><br><span class="line">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。</p><h3 id="Comparable，hashCode以及Equals"><a href="#Comparable，hashCode以及Equals" class="headerlink" title="Comparable，hashCode以及Equals"></a>Comparable，hashCode以及Equals</h3><p>你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/articleImg/compare.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
