<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Karson&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dduggs.top/"/>
  <updated>2020-07-03T10:03:42.442Z</updated>
  <id>http://dduggs.top/</id>
  
  <author>
    <name>Karson</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP四次挥手</title>
    <link href="http://dduggs.top/2020/07/03/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://dduggs.top/2020/07/03/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2020-07-03T08:02:35.000Z</published>
    <updated>2020-07-03T10:03:42.442Z</updated>
    
    <content type="html"><![CDATA[<p>“挥手”是为了终止连接，TCP四次挥手的流程图如下：</p><p><img src="/articleImage/2020-07-03/4.png" alt="TCP Flags"></p><a id="more"></a><p><strong>第一次挥手：</strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br><strong>第二次挥手</strong>：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br><strong>第三次挥手</strong>：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br><strong>第四次挥手：</strong>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p>常见面试题：</p><p><strong>1.Time-Wait到Closed状态为什么需要等待2MSL(最长报文段生命)</strong><br>确保有足够的时间让对方收到ACK包<br>避免新旧连接混淆</p><p><strong>2.为什么需要四次握手才能断开连接</strong><br>因为全双工，发送方和接受方都需要FIN报文和ACK报文</p><p><strong>3.服务器出现大量CLOSE_WAIT状态的原因</strong><br>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<br>检查代码，特别是释放资源的代码<br>检查配置，特别是处理请求对的线程配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“挥手”是为了终止连接，TCP四次挥手的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-03/4.png&quot; alt=&quot;TCP Flags&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试计" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95%E8%AE%A1/"/>
    
      <category term="算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95%E8%AE%A1/%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手</title>
    <link href="http://dduggs.top/2020/07/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://dduggs.top/2020/07/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2020-07-03T05:53:37.000Z</published>
    <updated>2020-07-03T08:00:40.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传输控制协议TCP简介"><a href="#传输控制协议TCP简介" class="headerlink" title="传输控制协议TCP简介"></a>传输控制协议TCP简介</h3><ul><li>面向连接的、可靠的、基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><p><img src="/articleImage/2020-07-03/3.jpg" alt="TCP报文"></p><a id="more"></a><p><strong>序列号seq</strong>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。<br><strong>确认号ack</strong>：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。<br><strong>确认ACK</strong>：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效<br><strong>同步SYN</strong>：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。<br><strong>终止FIN</strong>：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</p><p><img src="/articleImage/2020-07-03/2.png" alt="TCP Flags"></p><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p><img src="/articleImage/2020-07-03/3.png" alt="TCP Flags"></p><p><strong>常见面试题：</strong><br><strong>1.为什么需要三次握手才能建立起连接</strong><br>        为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。</p><p><strong>2.首次握手的隐患—SYN超时</strong><br>        Server收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。<br>对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。<br>针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。</p><p><strong>3.建议连接后，client出现故障怎么办？</strong><br>        TCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;传输控制协议TCP简介&quot;&gt;&lt;a href=&quot;#传输控制协议TCP简介&quot; class=&quot;headerlink&quot; title=&quot;传输控制协议TCP简介&quot;&gt;&lt;/a&gt;传输控制协议TCP简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;面向连接的、可靠的、基于字节流的传输层通信协议&lt;/li&gt;
&lt;li&gt;将应用层的数据流分割成报文段并发送给目标节点的TCP层&lt;/li&gt;
&lt;li&gt;数据包都有序号，对方收到则发送ACK确认，未收到则重传&lt;/li&gt;
&lt;li&gt;使用校验和来检验数据在传输过程中是否有误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-03/3.jpg&quot; alt=&quot;TCP报文&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Java面试宝典之-计算机网络</title>
    <link href="http://dduggs.top/2020/07/03/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://dduggs.top/2020/07/03/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-03T03:18:54.000Z</published>
    <updated>2020-07-03T05:51:32.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h3><p><img src="/articleImage/2020-07-03/1.png" alt="七层协议"></p><h5 id="第一层：物理层"><a href="#第一层：物理层" class="headerlink" title="第一层：物理层"></a>第一层：物理层</h5><p>解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。<br>物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率<br>主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。<br>层数据：比特<br>存在的物理设备：网卡</p><a id="more"></a><h5 id="第二层：数据链路层"><a href="#第二层：数据链路层" class="headerlink" title="第二层：数据链路层"></a>第二层：数据链路层</h5><p>在传输比特流的时候会出现错传、传输不完整的情况，因此数据链路层应运而生，它定了如何格式化数据以进行传输，提供错误检测和纠正，以确保数据传输的可靠性<br>层数据：帧<br>存在的物理设备：交换机（对帧解码，并根据帧中包含的信息，把数据发送给正确的接收方）。</p><h5 id="第三层，网络层"><a href="#第三层，网络层" class="headerlink" title="第三层，网络层"></a>第三层，网络层</h5><p>随着网络节点的不断增加，点对点通信的时候需要经过多个结点，如何到达目标节点、如何选择最佳路径便成为了首要需求。<br>作用：是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先级，网络拥塞程度，服务质量，可选路由的花费决定从节点A到结点B的最佳路径。<br>层数据：（分组）数据报 存在的物理设备：路由器（由于网络层处理并智能指导数据传送，路由器连接网络各段）<br>需要关注的协议： IP</p><h5 id="第四层，传输层"><a href="#第四层，传输层" class="headerlink" title="第四层，传输层"></a>第四层，传输层</h5><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很多时间，而网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发出的数据进行切分，切割为一个一个的段落，即segment进行发送，其中一个段落丢失了该怎么办，要不要重传，每个段落要按照顺序到达吗。这便是传输层需要考虑的问题。<br>传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，同时传输层解决了传输质量的问题，该层是OSI模型中最重要的一层。具有传输协议，同时进行流量控制，或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网不能直接接收大于1500字节的数据包，发送方结点的传输层将数据分割成较小的数据片，同时为每一数据片安排序列号，以便数据到达接收方结点的传输层时能以正确的顺序重组，该过程称为排序。<br>层数据：分段<br>需要关注的协议：TCP/UDP</p><h5 id="第五层，会话层"><a href="#第五层，会话层" class="headerlink" title="第五层，会话层"></a>第五层，会话层</h5><p>现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道每次都需要调用tcp协议去打包，然后调IP协议去找路由，自己去发，这样当然不行。因此我们要建立一个自动收发包，自动寻址的功能。于是发明了会话层<br>作用：建立和管理应用程序间的通讯</p><h5 id="第六层，表示层"><a href="#第六层，表示层" class="headerlink" title="第六层，表示层"></a>第六层，表示层</h5><p>现在能保证应用程序能自动收发包和寻址，但我要用linux给windows发包，两个系统的语法不一致。<br>作用：解决不同系统之间的通信语法问题，在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用网络的类型不同而不同。</p><h5 id="第七层，应用层"><a href="#第七层，应用层" class="headerlink" title="第七层，应用层"></a>第七层，应用层</h5><p>此时虽然发送方知道发送的是什么东西，转换成字节数组有多长，但接收方不知道，所以应用层的网络协议诞生了<br>作用：规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，方便接受方能够正确解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层，你也可以直接在两台电脑传递，只不过都是1、0的字节数组。<br>需要关注的协议：http协议</p><p>从应用层开始都会对要传输信息的头部进行处理，加上本层的一些信息，最终物理层通过以太网，电缆等介质将数据解析成比特流，在网络中传输。数据传递到目标地址并自底而上的将头部的内容解析分离出来。</p><p>OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的指定。即OSI参考模型并不是一个标准，而是制定标准是所使用的概念性框架。<br>TCP\IP : OSI的一种实现</p><p><img src="/articleImage/2020-07-03/osi.gif" alt="OSI"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络基础知识&quot;&gt;&lt;a href=&quot;#网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;网络基础知识&quot;&gt;&lt;/a&gt;网络基础知识&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/articleImage/2020-07-03/1.png&quot; alt=&quot;七层协议&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;第一层：物理层&quot;&gt;&lt;a href=&quot;#第一层：物理层&quot; class=&quot;headerlink&quot; title=&quot;第一层：物理层&quot;&gt;&lt;/a&gt;第一层：物理层&lt;/h5&gt;&lt;p&gt;解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。&lt;br&gt;物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率&lt;br&gt;主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。&lt;br&gt;层数据：比特&lt;br&gt;存在的物理设备：网卡&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java面试" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://dduggs.top/categories/Java%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo博客多电脑同步（hexo+GitHub）</title>
    <link href="http://dduggs.top/2020/06/29/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5/"/>
    <id>http://dduggs.top/2020/06/29/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5/</id>
    <published>2020-06-29T01:58:13.000Z</published>
    <updated>2020-07-02T09:54:51.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-如何让公司电脑A、家里电脑B都能同步编辑博客。"><a href="#1-如何让公司电脑A、家里电脑B都能同步编辑博客。" class="headerlink" title="1.如何让公司电脑A、家里电脑B都能同步编辑博客。"></a>1.如何让公司电脑A、家里电脑B都能同步编辑博客。</h3><p><strong>上传博客工程到Github</strong></p><p> 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#git初始化</span><br><span class="line">git init</span><br><span class="line">#添加仓库地址</span><br><span class="line">git remote add origin https:<span class="comment">//github.com/用户名/你的GitHub用户名.github.io.git </span></span><br><span class="line">#新建分支并切换到新建的分支</span><br><span class="line">git checkout -b 分支名 </span><br><span class="line">#添加所有本地文件到git</span><br><span class="line">git add . </span><br><span class="line">#git提交</span><br><span class="line">git commit -m <span class="string">"这里填写你本次提交的备注，内容随意"</span> </span><br><span class="line">#文件推送到hexo分支</span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><p><strong>从另一台电脑下载博客工程</strong></p><p>B电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。</p><p>然后输入以下命令<a id="more"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b 分支名 https:<span class="comment">//github.com/用户名/你的GitHub用户</span></span><br></pre></td></tr></table></figure><p>克隆下载完成后，进入到你项目的文件夹，重新配置你的hexo环境，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置</span><br><span class="line">sudo npm install -g hexo-cli </span><br><span class="line">#安装依赖库</span><br><span class="line">sudo npm install </span><br><span class="line">#安装git部署相关配置</span><br><span class="line">sudo npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>之后就可以创建撰写新的文章，并使用sudo hexo g -d命令创建并部署您的网站。</p><p><strong>撰写完后如何再次同步</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"提交的备注，内容随意"</span></span><br><span class="line">git push origin 分支名</span><br><span class="line">#没错，这个样就够了~你B电脑上的数据也已经同步到Github上面了。</span><br><span class="line">#那第二天到A电脑跟前，只需要执行以下命令就行</span><br><span class="line"></span><br><span class="line">git pull</span><br><span class="line">#这样，你的数据就全部同步到A电脑了，以后在部署完后，再次执行</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"提交的备注，内容随意"</span></span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><hr><p><strong>常见问题</strong></p><p>（1）修改主题后，主题文件无法推送至GitHub</p><p>可能是该子文件夹下有.git文件夹导致无法上传，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#删除子文件夹下.git后，依然无法提交子文件夹下的文件。</span></span><br><span class="line"><span class="bullet">1. </span>git rm --cached themes/yilia</span><br><span class="line"><span class="bullet">2. </span>git add .</span><br><span class="line"><span class="bullet">3. </span>git commit -m "xxx"</span><br><span class="line"><span class="bullet">4. </span>git push origin master</span><br></pre></td></tr></table></figure><p>（2）文章多标签格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line">- Hexo</span><br><span class="line">- GitHub</span><br><span class="line">- Git</span><br></pre></td></tr></table></figure><p>（3）文章缩略标识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>（4）添加评论GitTalk</p><p><strong>创建 gitalk.ejs</strong></p><p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/post/</code> 目录下创建 <code>gitalk.ejs</code> 并写入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;blueimp-md5&#x2F;2.10.0&#x2F;js&#x2F;md5.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">  clientID: &#39;&lt;%&#x3D;theme.gitalk.clientID%&gt;&#39;,</span><br><span class="line">  clientSecret: &#39;&lt;%&#x3D;theme.gitalk.clientSecret%&gt;&#39;,</span><br><span class="line">  repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class="line">  owner: &#39;&lt;%&#x3D;theme.gitalk.owner%&gt;&#39;,</span><br><span class="line">  admin: [&#39;&lt;%&#x3D;theme.gitalk.admin%&gt;&#39;],</span><br><span class="line">  id: md5(window.location.pathname),</span><br><span class="line">  distractionFreeMode: &lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>修改 article.ejs</strong></p><p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/article.ejs</code> 文件中最后一行 <code>“&lt;% } %&gt;”</code> 之前添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.gitalk.enable &amp;&amp; theme.gitalk.distractionFreeMode)&#123; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class="line">      key: post.slug,</span><br><span class="line">      title: post.title,</span><br><span class="line">      url: config.url+url_for(post.path)</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><strong>添加配置文件</strong></p><p>在 yilia 的配置文件<code>_config.yml</code> 中 gitment 配置下面添加如下配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#6. Gitalk</span><br><span class="line">gitalk: </span><br><span class="line">  enable: true    #用来做启用判断可以不用</span><br><span class="line">  clientID: your clientID    #Github上生成的 Settings Developer&#x2F;settings&#x2F;OAuth Apps</span><br><span class="line">  clientSecret: your clientSecret   #同上</span><br><span class="line">  repo: git_comment    #评论所在的github project</span><br><span class="line">  owner: findtheonlyway    #github用户名</span><br><span class="line">  admin: erbiduo    #可以初始化评论issue的github账户名称</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure><p>（5）微信分享二维码失效</p><p>打开<code>themes\yilia\layout\_partial\post\share.ejs</code>文件</p><p>把第49行中的 <code>//pan.baidu.com/share/qrcode?url=</code>修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=</span></span><br></pre></td></tr></table></figure><p>（6）添加文章分类</p><p><strong>1、添加categories链接</strong><br>打开yilia/_config.yml文件，menu处做出以下修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: <span class="regexp">/</span></span><br><span class="line"><span class="regexp">  分类: /</span>categories</span><br><span class="line">  归档: <span class="regexp">/archives</span></span><br></pre></td></tr></table></figure><p><strong>2、分类页面的构建</strong><br>新建categories页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page categories</span><br><span class="line">#该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。</span><br></pre></td></tr></table></figure><p>修改categories/index.md为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2018-06-11 10:13:21</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>生成html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:4000/categories/" target="_blank" rel="noopener">http://localhost:4000/categories/</a> ，即可看到categories页面，只不过现在的页面只有标题。</p><p><strong>3、修改 yilia 主题</strong><br>修改<em>yilia\source\main.0cf68a.css</em>，将下面的内容添加进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">category-all-page &#123;</span><br><span class="line">    margin: <span class="number">30</span>px <span class="number">40</span>px <span class="number">30</span>px <span class="number">40</span>px;</span><br><span class="line">    position: relative;</span><br><span class="line">    min-height: <span class="number">70</span>vh;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page h2 &#123;</span><br><span class="line">    margin: <span class="number">20</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-all-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-all &#123;</span><br><span class="line">    margin-top: <span class="number">20</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list &#123;</span><br><span class="line">    margin: <span class="number">0</span>;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    list-style: none;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-item &#123;</span><br><span class="line">    margin: <span class="number">10</span>px <span class="number">15</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-count &#123;</span><br><span class="line">    color: $grey;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-count:before &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">" ("</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item-list-count:after &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">") "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-item &#123;</span><br><span class="line">    margin: <span class="number">10</span>px <span class="number">10</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-count &#123;</span><br><span class="line">    color: $grey;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-count:before &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">" ("</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-count:after &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    content: <span class="string">") "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .category-all-page .category-list-child &#123;</span><br><span class="line">    padding-left: <span class="number">10</span>px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>4、多层分类</strong><br>新建<em>yilia/layout/categories.ejs</em>，输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"article article-type-post show"</span>&gt;</span><br><span class="line">  &lt;header <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-header"</span> style=<span class="string">"border-bottom: 1px solid #ccc"</span>&gt;</span><br><span class="line">  &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-title"</span> itemprop=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;%= page.title %&gt;</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>header&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% <span class="keyword">if</span> (site.categories.length)&#123; %&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"category-all-page"</span>&gt;</span><br><span class="line">    &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%- list_categories(site.categories, &#123;</span></span><br><span class="line"><span class="regexp">      show_count: true,</span></span><br><span class="line"><span class="regexp">      class: 'category-list-item',</span></span><br><span class="line"><span class="regexp">      style: 'list',</span></span><br><span class="line"><span class="regexp">      depth: 2,</span></span><br><span class="line"><span class="regexp">      separator: ''</span></span><br><span class="line"><span class="regexp">    &#125;) %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;<span class="regexp">/article&gt;</span></span><br></pre></td></tr></table></figure><p>找到 <em>layout/_partial/article.ejs</em> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#然后找到&lt;div class&#x3D;&quot;article-entry&quot; itemprop&#x3D;&quot;articleBody&quot;&gt;</span><br><span class="line">#与&lt;% if ((theme.reward_type &#x3D;&#x3D;&#x3D; 2 || (theme.reward_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;之间的内容全部替换为：</span><br><span class="line"></span><br><span class="line">&lt;% if (page.type &#x3D;&#x3D;&#x3D; &quot;tags&quot;) &#123; %&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tag-cloud-title&quot;&gt;</span><br><span class="line">&lt;%- _p(&#39;counter.tag_cloud&#39;, site.tags.length) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tag-cloud-tags&quot;&gt;</span><br><span class="line">&lt;%- tagcloud(&#123;</span><br><span class="line">min_font: 12,</span><br><span class="line">max_font: 30,</span><br><span class="line">amount: 200,</span><br><span class="line">color: true,</span><br><span class="line">start_color: &#39;#ccc&#39;,</span><br><span class="line">end_color: &#39;#111&#39;</span><br><span class="line">&#125;) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;% &#125; </span><br><span class="line">else if (page.type &#x3D;&#x3D;&#x3D; &#39;categories&#39;) &#123; </span><br><span class="line">%&gt; &lt;div class&#x3D;&quot;category-all-page&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;category-all-title&quot;&gt;</span><br><span class="line">&lt;%- _p(&#39;&#39;, site.categories.length) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;category-all&quot;&gt;</span><br><span class="line">&lt;%- list_categories() %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;&lt;%- post.excerpt %&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">&lt;%- post.content %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><strong>5、修改自己的文章</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo博客多电脑同步（hexo+GitHub）</span><br><span class="line">date: <span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">09</span>:<span class="number">58</span>:<span class="number">13</span></span><br><span class="line">tags: </span><br><span class="line">- Hexo</span><br><span class="line">- GitHub</span><br><span class="line">- Git</span><br><span class="line">categories: </span><br><span class="line">- hexo</span><br></pre></td></tr></table></figure><p>（7）分页显示错误</p><p>首先找到<em>blog\themes\yilia\layout_partial\archive.ejs</em></p><p>修改两处，分别在8，9行与37，38行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br><span class="line">&lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class="line">  &lt;nav id&#x3D;&quot;page-nav&quot;&gt;</span><br><span class="line">    &lt;%- paginator(&#123;</span><br><span class="line">      prev_text: &#39;上一页&#39;,</span><br><span class="line">      next_text: &#39;下一页&#39;</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;nav&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后找到<em>blog\themes\yilia\layout_partial\script.ejs</em><br>ctrl + f 搜索 next &amp;raquo</p><p><img src="/articleImage/2020-06-29/1.png" alt="script.ejs"></p><p>找到图片中框选的两处， 分别改为上一页与下一页</p><p><img src="/articleImage/2020-06-29/2.png" alt="script.ejs"></p><p><a href="https://cloud.tencent.com/developer/article/1046404" target="_blank" rel="noopener">参考链接1</a></p><p><a href="https://blog.csdn.net/dta0502/article/details/89607895" target="_blank" rel="noopener">参考链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-如何让公司电脑A、家里电脑B都能同步编辑博客。&quot;&gt;&lt;a href=&quot;#1-如何让公司电脑A、家里电脑B都能同步编辑博客。&quot; class=&quot;headerlink&quot; title=&quot;1.如何让公司电脑A、家里电脑B都能同步编辑博客。&quot;&gt;&lt;/a&gt;1.如何让公司电脑A、家里电脑B都能同步编辑博客。&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;上传博客工程到Github&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#git初始化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#添加仓库地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin https:&lt;span class=&quot;comment&quot;&gt;//github.com/用户名/你的GitHub用户名.github.io.git &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#新建分支并切换到新建的分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b 分支名 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#添加所有本地文件到git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add . &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#git提交&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &lt;span class=&quot;string&quot;&gt;&quot;这里填写你本次提交的备注，内容随意&quot;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#文件推送到hexo分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin 分支名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;从另一台电脑下载博客工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。&lt;/p&gt;
&lt;p&gt;然后输入以下命令
    
    </summary>
    
    
      <category term="博客" scheme="http://dduggs.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://dduggs.top/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://dduggs.top/tags/GitHub/"/>
    
      <category term="Git" scheme="http://dduggs.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>无代码侵入调试dubbo服务</title>
    <link href="http://dduggs.top/2020/06/28/Local-Debug-Dubbo/"/>
    <id>http://dduggs.top/2020/06/28/Local-Debug-Dubbo/</id>
    <published>2020-06-28T10:58:48.000Z</published>
    <updated>2020-07-02T03:33:48.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-提供者（Provider-service）"><a href="#1-提供者（Provider-service）" class="headerlink" title="1.提供者（Provider-service）"></a>1.提供者（Provider-service）</h3><p>​    dubbo.xml中添加<strong>register=”false”</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"$&#123;zookeeper.cluster&#125;"</span> <span class="attr">register</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-消费者（Consumer-service）"><a href="#2-消费者（Consumer-service）" class="headerlink" title="2.消费者（Consumer-service）"></a>2.消费者（Consumer-service）</h3><p>​        在本地任意位置新建配置文件:dubbo-local-consumer.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是你们DubboServer.xml中配置的需要Export Service，</span></span><br><span class="line"><span class="comment"># 建议你有几个要Export Service都配置在这里，后面是请求本地的地址</span></span><br><span class="line"><span class="comment"># 地址格式：dubbo://ip:port，这里需要注意的是，需要修改为自己dubbo服务的端口</span></span><br><span class="line"><span class="meta">com.xxxService</span>=<span class="string">dubbo://localhost:20880</span></span><br></pre></td></tr></table></figure><p>​        设置启动参数指向该配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动参数：</span></span><br><span class="line"><span class="meta">-Ddubbo.resolve.file</span>=<span class="string">/C:\workspace\dubbo-local-consumer.properties</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-提供者（Provider-service）&quot;&gt;&lt;a href=&quot;#1-提供者（Provider-service）&quot; class=&quot;headerlink&quot; title=&quot;1.提供者（Provider-service）&quot;&gt;&lt;/a&gt;1.提供者（Provider-se
      
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="效率" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="dubbo" scheme="http://dduggs.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Centos6下redis安装配置</title>
    <link href="http://dduggs.top/2017/07/21/redis_install/"/>
    <id>http://dduggs.top/2017/07/21/redis_install/</id>
    <published>2017-07-21T05:34:00.000Z</published>
    <updated>2020-07-02T03:26:01.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Remote Dictionary Server(Redis)<br>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p></blockquote><a id="more"></a><h3 id="1、安装需要的支持环境"><a href="#1、安装需要的支持环境" class="headerlink" title="1、安装需要的支持环境"></a>1、安装需要的支持环境</h3><p>在安装Redis之前首要先做的是安装Unix的Tcl工具，如果不安装的话后期将无法对Redis进行测试。在后期执行make test的时候返回如下错误信息：You need tcl 8.xuyao de5 or newer in order to run the Redis test，具体的流程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;tcl&#x2F;tcl8.6.3-src.tar.gz</span><br><span class="line">tar -zxvf tcl8.6.3-src.tar.gz</span><br><span class="line">cd ​tcl8.6.3&#x2F;unix&#x2F;</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="2、安装redis"><a href="#2、安装redis" class="headerlink" title="2、安装redis"></a>2、安装redis</h3><p>安装redis的过程非常的简单，具体教程官网也有。具体如下：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class="line">tar zxvf redis-2.8.19.tar.gz</span><br><span class="line">cd redis-2.8.19</span><br><span class="line">make</span><br><span class="line">make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install</span><br></pre></td></tr></table></figure><p>其中PREFIX=/usr/local/redis可以省略，省略情况下redis会默认安装到/usr/local/bin目录下。</p><h3 id="3、测试Redis"><a href="#3、测试Redis" class="headerlink" title="3、测试Redis"></a>3、测试Redis</h3><pre><code>cd srcmake test通过以上命令就可以对redis进行加大的测试。</code></pre><h3 id="4、配置redis"><a href="#4、配置redis" class="headerlink" title="4、配置redis"></a>4、配置redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#拷贝并修改配置文档</span><br><span class="line">cp .&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#我只修改了如下几项：</span><br><span class="line">daemonize yes #redis将以守护进程的方式运行，默认为no会暂用你的终端</span><br><span class="line">timeout 300​ #当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">requirepass yourpassword #设置密码</span><br><span class="line">#bind 127.0.0.1 #限制了只能本地连接</span><br><span class="line">另外，设置密码后，使用redis-cli登录要带密码登录</span><br><span class="line">否则操作redis会出现身份认证的错误</span><br><span class="line">命令如下:</span><br><span class="line">redis-cli -a youPassword</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#B、启动或关闭服务</span><br><span class="line">service redis start</span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure><h3 id="5、使用redis"><a href="#5、使用redis" class="headerlink" title="5、使用redis"></a>5、使用redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">[root@localhost bin]# .&#x2F;redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set name cjs</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;cjs&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="6、java使用redis"><a href="#6、java使用redis" class="headerlink" title="6、java使用redis"></a>6、java使用redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><pre><code>public final class RedisUtil {//Redis服务器IPprivate static String ADDR = &quot;***.***.***.***&quot;;//Redis的端口号private static int PORT = 6379;//访问密码private static String AUTH = &quot;****&quot;;//可用连接实例的最大数目，默认值为8；//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。private static int MAX_ACTIVE = 1024;//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。private static int MAX_IDLE = 200;//等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；private static int MAX_WAIT = 10000;private static int TIMEOUT = 10000;//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；private static boolean TEST_ON_BORROW = true;private static JedisPool jedisPool = null;/** * 初始化Redis连接池 */static {    try {        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxIdle(MAX_IDLE);        //jedis高版本JedisPoolConfig没有maxActive改名为：        config.setMaxTotal(MAX_ACTIVE);        config.setMaxWaitMillis(MAX_WAIT);        config.setTestOnBorrow(TEST_ON_BORROW);        jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);    } catch (Exception e) {        e.printStackTrace();    }}/** * 获取Jedis实例 * @return */public synchronized static Jedis getJedis() {    try {        if (jedisPool != null) {            Jedis resource = jedisPool.getResource();            return resource;        } else {            return null;        }    } catch (Exception e) {        e.printStackTrace();        return null;    }}/** * 释放jedis资源 * @param jedis */public static void returnResource(final Jedis jedis) {    if (jedis != null) {        jedisPool.returnResource(jedis);    }}}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Remote Dictionary Server(Redis)&lt;br&gt;是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/p&gt;
&lt;p&gt;它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="http://dduggs.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>List集合按对象的某个字段去重</title>
    <link href="http://dduggs.top/2017/05/26/duplicateRemoval/"/>
    <id>http://dduggs.top/2017/05/26/duplicateRemoval/</id>
    <published>2017-05-26T07:37:46.000Z</published>
    <updated>2020-07-02T03:33:18.050Z</updated>
    
    <content type="html"><![CDATA[<p>思路:<br>利用Set(集合)的不可重复性：List–&gt;Set–&gt;List<br>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：<br>●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。<br>●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</p><a id="more"></a><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>set集合的构造方式列出来了三种:new Comparator; lambda表达式; Comparator.comparing(); </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CompareTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;CompanyMsgParam&gt; companyList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    CompanyMsgParam c1 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;001&quot;, &quot;A公司&quot;, &quot;0&quot;);</span><br><span class="line">    CompanyMsgParam c2 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;001&quot;, &quot;B公司&quot;, &quot;1&quot;);</span><br><span class="line">    CompanyMsgParam c3 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;002&quot;, &quot;C公司&quot;, &quot;2&quot;);</span><br><span class="line">    CompanyMsgParam c4 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;003&quot;, &quot;D公司&quot;, &quot;3&quot;);</span><br><span class="line">    companyList.add(c1);</span><br><span class="line">    companyList.add(c2);</span><br><span class="line">    companyList.add(c3);</span><br><span class="line">    companyList.add(c4);</span><br><span class="line">&#x2F;&#x2F;第一种</span><br><span class="line">    Set&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(new Comparator&lt;CompanyMsgParam&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(CompanyMsgParam com1, CompanyMsgParam com2) &#123;</span><br><span class="line">            return com1.getCompanyCode().compareTo(com2.getCompanyCode());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">    Set&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;((com1, com2) -&gt; com1.getCompanyCode().compareTo(com2.getCompanyCode()));</span><br><span class="line">&#x2F;&#x2F;第三种</span><br><span class="line">    Set&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(Comparator.comparing(CompanyMsgParam::getCompanyCode));</span><br><span class="line">    set.addAll(companyList);</span><br><span class="line"></span><br><span class="line">    companyList &#x3D; new ArrayList&lt;CompanyMsgParam&gt;(set);</span><br><span class="line"></span><br><span class="line">    for (CompanyMsgParam param : companyList) &#123;</span><br><span class="line">        System.out.println(param.getCompanyCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IDEA配置LanguageLevel和JavaCompiler版本的问题"><a href="#IDEA配置LanguageLevel和JavaCompiler版本的问题" class="headerlink" title="IDEA配置LanguageLevel和JavaCompiler版本的问题"></a>IDEA配置LanguageLevel和JavaCompiler版本的问题</h3><p>按个人需要修改下面的配置即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;思路:&lt;br&gt;利用Set(集合)的不可重复性：List–&amp;gt;Set–&amp;gt;List&lt;br&gt;Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：&lt;br&gt;●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。&lt;br&gt;●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>javaMail发送邮件</title>
    <link href="http://dduggs.top/2017/05/25/javaMail/"/>
    <id>http://dduggs.top/2017/05/25/javaMail/</id>
    <published>2017-05-25T06:39:47.000Z</published>
    <updated>2020-07-02T03:39:46.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..</p></blockquote><a id="more"></a>    <h3 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 发送邮件</span><br><span class="line"> * </span><br><span class="line"> * @param toAddress: 收件人邮箱</span><br><span class="line"> * @param mailSubject: 邮件主题</span><br><span class="line"> * @param mailBody: 邮件正文</span><br><span class="line"> * @param mailBodyIsHtml: 邮件正文格式,true:HTML格式;false:文本格式</span><br><span class="line"> * &#x2F;&#x2F;@param inLineFile: 内嵌文件</span><br><span class="line"> * @param attachments: 附件</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean sendMail (String toAddress, String mailSubject, String mailBody, </span><br><span class="line">boolean mailBodyIsHtml, File[] attachments)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">&#x2F;&#x2F; 创建邮件发送类 JavaMailSender (用于发送多元化邮件，包括附件，图片，html 等    )</span><br><span class="line">       JavaMailSenderImpl mailSender &#x3D; new JavaMailSenderImpl();</span><br><span class="line">       mailSender.setHost(host); &#x2F;&#x2F; 设置邮件服务主机    </span><br><span class="line">       mailSender.setUsername(username); &#x2F;&#x2F; 发送者邮箱的用户名</span><br><span class="line">       mailSender.setPassword(password); &#x2F;&#x2F; 发送者邮箱的密码</span><br><span class="line">       </span><br><span class="line">&#x2F;&#x2F;配置文件，用于实例化java.mail.session    </span><br><span class="line">Properties pro &#x3D; new Properties();</span><br><span class="line">pro.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</span><br><span class="line">pro.put(&quot;mail.smtp.socketFactory.port&quot;, port);</span><br><span class="line">pro.put(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;);</span><br><span class="line">pro.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);</span><br><span class="line">mailSender.setJavaMailProperties(pro);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建多元化邮件 (创建 mimeMessage 帮助类，用于封装信息至 mimeMessage)</span><br><span class="line">MimeMessage mimeMessage &#x3D; mailSender.createMimeMessage();</span><br><span class="line">MimeMessageHelper helper &#x3D; new MimeMessageHelper(mimeMessage, ArrayUtils.isNotEmpty(attachments), &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">helper.setFrom(sendFrom, sendNick);</span><br><span class="line">helper.setTo(toAddress);</span><br><span class="line"></span><br><span class="line">helper.setSubject(mailSubject);</span><br><span class="line">helper.setText(mailBody, mailBodyIsHtml); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加内嵌文件，第1个参数为cid标识这个文件,第2个参数为资源</span><br><span class="line">&#x2F;&#x2F;helper.addInline(MimeUtility.encodeText(inLineFile.getName()), inLineFile);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加附件    </span><br><span class="line">if (ArrayUtils.isNotEmpty(attachments)) &#123;</span><br><span class="line">for (File file : attachments) &#123;</span><br><span class="line">helper.addAttachment(MimeUtility.encodeText(file.getName()), file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mailSender.send(mimeMessage);</span><br><span class="line">return true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行报错："><a href="#运行报错：" class="headerlink" title="运行报错："></a>运行报错：</h3><blockquote><p>“Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 550 User has no permission…..”</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>网易163邮箱 “设置–POP3/SMTP/IMAP” 中 “客户端授权” 未开启。<br>开启授权码后，它将代替邮箱密码在客户端使用。<br><img src="/img/articleImg/163sqm.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="JavaMail" scheme="http://dduggs.top/tags/JavaMail/"/>
    
  </entry>
  
  <entry>
    <title>java值传递还是引用传递</title>
    <link href="http://dduggs.top/2017/05/24/paramPass/"/>
    <id>http://dduggs.top/2017/05/24/paramPass/</id>
    <published>2017-05-24T07:48:36.000Z</published>
    <updated>2020-07-02T03:34:27.564Z</updated>
    
    <content type="html"><![CDATA[<p> 由一道面试题引发的问题：java是值传递还是引用传递？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    String str&#x3D;&quot;abc&quot;;</span><br><span class="line">    int a[]&#x3D;&#123;1,2,3&#125;;</span><br><span class="line">    int i&#x3D;1;</span><br><span class="line">    void change(String str,int a[],int i)&#123;</span><br><span class="line">        </span><br><span class="line">        str&#x3D;&quot;cbd&quot;;</span><br><span class="line">        a[0]&#x3D;4;</span><br><span class="line">        i&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        Test t&#x3D;new Test();</span><br><span class="line">        t.change(t.str,t.a,t.i);</span><br><span class="line">        System.out.println(t.str);</span><br><span class="line">        System.out.println(t.a[0]);</span><br><span class="line">        System.out.println(t.i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>运行结果<br>abc<br>4<br>1</p></blockquote><h3 id="1-按值传递是什么"><a href="#1-按值传递是什么" class="headerlink" title="1.按值传递是什么"></a>1.按值传递是什么</h3><p>指的是在方法调用时，传递的参数是按值的拷贝传递。<br>按值传递重要特点:传递的是值的拷贝，也就是说传递后就互不相关了。</p><h3 id="2-按引用传递是什么"><a href="#2-按引用传递是什么" class="headerlink" title="2.按引用传递是什么"></a>2.按引用传递是什么</h3><p>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。<br>按引用传递的重要特点:<br>传递的是值的引用，也就是说传递前和传递后都指向同一个引用(也就是同一个内存空间)。</p><p>详细博文见<a href="http://blog.csdn.net/zzp_403184692/article/details/8184751" target="_blank" rel="noopener">&gt;&gt;&gt;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 由一道面试题引发的问题：java是值传递还是引用传递？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String str&amp;#x3D;&amp;quot;abc&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a[]&amp;#x3D;&amp;#123;1,2,3&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i&amp;#x3D;1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void change(String str,int a[],int i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        str&amp;#x3D;&amp;quot;cbd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[0]&amp;#x3D;4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i&amp;#x3D;2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Test t&amp;#x3D;new Test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.change(t.str,t.a,t.i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(t.str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(t.a[0]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(t.i++);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java8中如何处理时间</title>
    <link href="http://dduggs.top/2017/04/01/LocalDate/"/>
    <id>http://dduggs.top/2017/04/01/LocalDate/</id>
    <published>2017-04-01T05:12:06.000Z</published>
    <updated>2020-07-02T03:34:03.658Z</updated>
    
    <content type="html"><![CDATA[<p>Java8之前，Date类都是可变类<br>当我们在多线程环境下使用它<br>编程人员应该确认Date对象的线程安全<br>Java8的Date和Time API提供了线程安全的不可变类<br>编程人员不用考虑并发的问题<br><img src="/img/articleImg/time2.jpg" alt=""></p><a id="more"></a><h3 id="LocalDate用法"><a href="#LocalDate用法" class="headerlink" title="LocalDate用法"></a>LocalDate用法</h3><p>LocalDate只提供日期不提供时间信息。它是不可变类且线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取当前日期：</span><br><span class="line">LocalDate today &#x3D; LocalDate.now(); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class="line">&#x2F;&#x2F; 根据年月日取日期，04月就是04：</span><br><span class="line">LocalDate crischristmas &#x3D; LocalDate.of(2017, 04, 01); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class="line">&#x2F;&#x2F; 根据字符串取：</span><br><span class="line">LocalDate endOfFeb &#x3D; LocalDate.parse(&quot;2017-04-01&quot;); </span><br><span class="line">&#x2F;&#x2F; 严格按照ISO yyyy-MM-dd验证，04写成4都不行，当然也有一个重载方法允许自己定义格式</span><br><span class="line">LocalDate.parse(&quot;2017-02-29&quot;); &#x2F;&#x2F; 无效日期无法通过：DateTimeParseException: Invalid date...</span><br></pre></td></tr></table></figure><p>日期转换经常遇到，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取本月第1天：</span><br><span class="line">LocalDate firstDayOfThisMonth &#x3D; today.with(TemporalAdjusters.firstDayOfMonth()); &#x2F;&#x2F; 2017-04-01</span><br><span class="line">&#x2F;&#x2F; 取本月第2天：</span><br><span class="line">LocalDate secondDayOfThisMonth &#x3D; today.withDayOfMonth(2); &#x2F;&#x2F; 2017-04-02</span><br><span class="line">&#x2F;&#x2F; 取本月最后一天，再也不用计算是28，29，30还是31：</span><br><span class="line">LocalDate lastDayOfThisMonth &#x3D; today.with(TemporalAdjusters.lastDayOfMonth()); &#x2F;&#x2F; 2017-04-30</span><br><span class="line">&#x2F;&#x2F; 取下一天：</span><br><span class="line">LocalDate nextDayOf &#x3D; lastDayOfThisMonth.plusDays(1); &#x2F;&#x2F; 变成了2017-05-01</span><br><span class="line">&#x2F;&#x2F; 取2017年1月第一个周一，这个计算用Calendar要死掉很多脑细胞：</span><br><span class="line">LocalDate firstMondayOf2017 &#x3D; LocalDate.parse(&quot;2017-01-01&quot;).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); &#x2F;&#x2F; 2017-01-02</span><br></pre></td></tr></table></figure><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now &#x3D; LocalTime.now(); &#x2F;&#x2F; 11:09:09.240</span><br><span class="line">清除毫秒数：</span><br><span class="line">LocalTime now &#x3D; LocalTime.now().withNano(0)); &#x2F;&#x2F; 11:09:09</span><br><span class="line">构造时间：</span><br><span class="line">LocalTime zero &#x3D; LocalTime.of(0, 0, 0); &#x2F;&#x2F; 00:00:00</span><br><span class="line">LocalTime mid &#x3D; LocalTime.parse(&quot;12:00:00&quot;); &#x2F;&#x2F; 12:00:00</span><br></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：</p><blockquote><p>date -&gt; LocalDate<br>time -&gt; LocalTime<br>timestamp -&gt; LocalDateTime</p></blockquote><p>再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8之前，Date类都是可变类&lt;br&gt;当我们在多线程环境下使用它&lt;br&gt;编程人员应该确认Date对象的线程安全&lt;br&gt;Java8的Date和Time API提供了线程安全的不可变类&lt;br&gt;编程人员不用考虑并发的问题&lt;br&gt;&lt;img src=&quot;/img/articleImg/time2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>springmvc导出Excel问题记录</title>
    <link href="http://dduggs.top/2017/03/31/springmvcPost/"/>
    <id>http://dduggs.top/2017/03/31/springmvcPost/</id>
    <published>2017-03-31T08:18:15.000Z</published>
    <updated>2020-07-02T03:34:52.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringMVC中获取不到POST形式的参数<br>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何<br>对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。<br>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为<br>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。<br>但代码里强制使用了multipart/form-data方式。</p></blockquote><a id="more"></a><p>所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;       </span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>并将commons-fileupload-1.3.2jar包引入到项目中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- POI导出Exl --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。</p><p>注：此问题是在上一个项目<a href="https://coding.net/u/letra/p/mvcdemo/git" target="_blank" rel="noopener">git地址</a>的基础上新增了导出Ecxel功能是发现，在此记录一二。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SpringMVC中获取不到POST形式的参数&lt;br&gt;这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何&lt;br&gt;对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。&lt;br&gt;就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为&lt;br&gt;ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。&lt;br&gt;但代码里强制使用了multipart/form-data方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>IDEA+Maven+SpringMVC+Hibernate环境搭建</title>
    <link href="http://dduggs.top/2017/03/20/mvcdemo/"/>
    <id>http://dduggs.top/2017/03/20/mvcdemo/</id>
    <published>2017-03-20T06:09:10.000Z</published>
    <updated>2020-07-02T03:34:19.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一篇十分详细的博文<a href="http://blog.lunhui.ren/archives/235" target="_blank" rel="noopener">地址</a><br><a href="https://git.coding.net/letra/MvcDemo.git" target="_blank" rel="noopener">源码地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一篇十分详细的博文&lt;a href=&quot;http://blog.lunhui.ren/archives/235&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地址&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://git.coding.
      
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Spring" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Spring/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Comparable 接口</title>
    <link href="http://dduggs.top/2017/03/15/Comparable/"/>
    <id>http://dduggs.top/2017/03/15/Comparable/</id>
    <published>2017-03-15T08:37:39.000Z</published>
    <updated>2020-07-02T03:39:58.701Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/articleImg/compare.png" alt=""></p><blockquote><p>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。</p></blockquote><a id="more"></a><h3 id="例1：通过重量排序苹果"><a href="#例1：通过重量排序苹果" class="headerlink" title="例1：通过重量排序苹果"></a>例1：通过重量排序苹果</h3><p>在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。</p><pre><code>Collections.sort(apples);</code></pre><p>上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。<br>让我们开始写苹果类吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Comparable &#123;</span><br><span class="line">    private String variety;</span><br><span class="line">    private Color color;</span><br><span class="line">    private int weight;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Apple other) &#123;</span><br><span class="line">        if (this.weight &lt; other.weight) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.weight &#x3D;&#x3D; other.weight) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。</p><h3 id="例2：通过多个特征排序苹果"><a href="#例2：通过多个特征排序苹果" class="headerlink" title="例2：通过多个特征排序苹果"></a>例2：通过多个特征排序苹果</h3><p>正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Comparable &#123;</span><br><span class="line">    private String variety;</span><br><span class="line">    private Color color;</span><br><span class="line">    private int weight;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Apple other) &#123;</span><br><span class="line">        int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class="line">        if (result !&#x3D; 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            result &#x3D; this.color.compareTo(other.color);</span><br><span class="line">        &#125;</span><br><span class="line">        if (result !&#x3D; 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Apple other) &#123;</span><br><span class="line">     int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class="line">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          result &#x3D; this.color.compareTo(other.color);</span><br><span class="line">     &#125;</span><br><span class="line">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。</p><h3 id="Comparable，hashCode以及Equals"><a href="#Comparable，hashCode以及Equals" class="headerlink" title="Comparable，hashCode以及Equals"></a>Comparable，hashCode以及Equals</h3><p>你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/articleImg/compare.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Map按值排序</title>
    <link href="http://dduggs.top/2017/03/15/mapSort/"/>
    <id>http://dduggs.top/2017/03/15/mapSort/</id>
    <published>2017-03-15T05:37:37.000Z</published>
    <updated>2020-07-02T03:34:11.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Map按值排序"><a href="#Map按值排序" class="headerlink" title="Map按值排序"></a>Map按值排序</h3><p>问题描述如下：</p><blockquote><p>现有Map&lt;String,String&gt;结构的数据，需要对其中包含的date值按降序排列输出<br>直观了解：<br>{<br>“zhanshan” :”{“date”:”2010-03-09 17:52:49:074”,”age”:”21”},<br>“lisi” :”{“date”:”2015-01-09 10:52:49:088”,”age”:”19”},<br>“zhaowu” :”{“date”:”2016-06-01 17:52:49:574”,”age”:”30”}<br>}<br>注：此Map的值也为String类型</p></blockquote><p>程序代码如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public Object MapSortTest(Map&lt;String, String&gt; map) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Map&lt;String,String&gt;&gt; resList&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">  if(!MapUtils.isEmpty(map))&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取Map映射集，遍历时可以getKey()，getValue()</span><br><span class="line">    List&lt;Map.Entry&lt;String,String&gt;&gt; entryList&#x3D;new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());</span><br><span class="line">&#x2F;&#x2F;自定义比较器</span><br><span class="line">    Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Map.Entry&lt;String, String&gt; entry1, Map.Entry&lt;String, String&gt; entry2) &#123;</span><br><span class="line"></span><br><span class="line">             String str1&#x3D;entry1.getValue();</span><br><span class="line">             String str2&#x3D;entry2.getValue();</span><br><span class="line">&#x2F;&#x2F;切割截取date的值，subString前闭后开[)</span><br><span class="line">             String date1&#x3D;str1.substring(str1.indexOf(&quot;:&quot;)+2,str1.indexOf(&quot;,&quot;)-1);</span><br><span class="line">             String date2&#x3D;str2.substring(str2.indexOf(&quot;:&quot;)+2,str2.indexOf(&quot;,&quot;)-1);</span><br><span class="line">               try &#123;</span><br><span class="line">                  Date d1&#x3D;DateUtils.parseDate(date1,&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);</span><br><span class="line">                  Date d2&#x3D;DateUtils.parseDate(date2,&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);</span><br><span class="line">&#x2F;&#x2F;日期降序</span><br><span class="line">                  return d2.compareTo(d1);</span><br><span class="line">                &#125; catch (ParseException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     &#x2F;&#x2F;遍历排序后的映射集，封装返回</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter&#x3D;entryList.iterator();</span><br><span class="line">        Map.Entry&lt;String,String&gt; temEntry &#x3D;null;</span><br><span class="line">        while (iter.hasNext())&#123;</span><br><span class="line">            Map&lt;String,String&gt; sortedMap &#x3D; new LinkedHashMap&lt;String,String&gt;();</span><br><span class="line">            temEntry&#x3D;iter.next();</span><br><span class="line">            sortedMap.put(&quot;type&quot;,temEntry.getKey());</span><br><span class="line">            sortedMap.put(&quot;message&quot;,temEntry.getValue());</span><br><span class="line">            resList.add(sortedMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Map按值排序&quot;&gt;&lt;a href=&quot;#Map按值排序&quot; class=&quot;headerlink&quot; title=&quot;Map按值排序&quot;&gt;&lt;/a&gt;Map按值排序&lt;/h3&gt;&lt;p&gt;问题描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现有Map&amp;lt;String,String&amp;gt;结构的数据，需要对其中包含的date值按降序排列输出&lt;br&gt;直观了解：&lt;br&gt;{&lt;br&gt;“zhanshan” :”{“date”:”2010-03-09 17:52:49:074”,”age”:”21”},&lt;br&gt;“lisi” :”{“date”:”2015-01-09 10:52:49:088”,”age”:”19”},&lt;br&gt;“zhaowu” :”{“date”:”2016-06-01 17:52:49:574”,”age”:”30”}&lt;br&gt;}&lt;br&gt;注：此Map的值也为String类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Java基础" scheme="http://dduggs.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>connection holder is null</title>
    <link href="http://dduggs.top/2017/03/14/druidError/"/>
    <id>http://dduggs.top/2017/03/14/druidError/</id>
    <published>2017-03-14T02:58:24.000Z</published>
    <updated>2020-07-02T03:31:09.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证&gt;在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？”。<br>必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。<br>而抛出“connection holder is null”异常的原因可能在于：<br>removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000</p></blockquote><p>假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(holder &#x3D;&#x3D;null)</span><br><span class="line">    &#123;</span><br><span class="line">        if (disableError !&#x3D; null) &#123;</span><br><span class="line">            throw new SQLException(&quot;connection holder is null&quot;, disableError);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new SQLException(&quot;connection holder is null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证&amp;gt;在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？”。&lt;br&gt;必须在程序在缓存从Druid中取出的连
      
    
    </summary>
    
    
      <category term="其他" scheme="http://dduggs.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="druid" scheme="http://dduggs.top/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="http://dduggs.top/2017/03/13/Lambda/"/>
    <id>http://dduggs.top/2017/03/13/Lambda/</id>
    <published>2017-03-13T07:23:43.000Z</published>
    <updated>2020-07-02T03:33:23.248Z</updated>
    
    <content type="html"><![CDATA[<p>Java8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。<br>在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。</p><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h2><p>Java 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。<br>Java 8中使用新特性Lambda表达式来改善这一点。</p><a id="more"></a><h3 id="1-1-使用示例"><a href="#1-1-使用示例" class="headerlink" title="1.1 使用示例"></a>1.1 使用示例</h3><p>以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。<br>使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(()-&gt;System.out.println(&quot;Lambda&quot;)).start();</span><br></pre></td></tr></table></figure><h3 id="1-2-类型参数推断机制-Type-Argument-Inference"><a href="#1-2-类型参数推断机制-Type-Argument-Inference" class="headerlink" title="1.2 类型参数推断机制(Type Argument Inference)"></a>1.2 类型参数推断机制(Type Argument Inference)</h3><p>Lambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。</p><h3 id="1-3-函数接口-Functional-Interface"><a href="#1-3-函数接口-Functional-Interface" class="headerlink" title="1.3 函数接口(Functional Interface)"></a>1.3 函数接口(Functional Interface)</h3><p>一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。<br>Runnable的函数接口如下:<br><img src="/img/articleImg/jk82.png" alt=""><br>可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。<br>Java8中定义若干函数接口(位于包java.util.function)。<br><img src="/img/articleImg/jk8.png" alt=""><br>以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。</p><h3 id="1-4-并非语法糖"><a href="#1-4-并非语法糖" class="headerlink" title="1.4 并非语法糖"></a>1.4 并非语法糖</h3><p>从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Apple&#123;</span><br><span class="line">public String toString() &#123;return &quot;apple&quot;;&#125;;</span><br><span class="line">Runnable r1 &#x3D; ()-&gt;&#123;System.out.println(this);&#125;;</span><br><span class="line">Runnable r2 &#x3D; new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;执行两个线程得到的结果是</span><br><span class="line">apple</span><br><span class="line">Day0917.Apple$1@22e90474</span><br></pre></td></tr></table></figure><pre><code>正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。Lambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。Lambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final.</code></pre><h3 id="1-5-默认方法"><a href="#1-5-默认方法" class="headerlink" title="1.5 默认方法"></a>1.5 默认方法</h3><p>Java8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Apple&#123;</span><br><span class="line">default void show()&#123;</span><br><span class="line">System.out.println(&quot;interface&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyApple implements Apple&#123;</span><br><span class="line">@Override</span><br><span class="line">public void show() &#123;</span><br><span class="line">Apple.super.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。</p><h3 id="1-6-方法引用"><a href="#1-6-方法引用" class="headerlink" title="1.6 方法引用"></a>1.6 方法引用</h3><p>如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。<br>在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。</p><blockquote><p>//1,建立一个字符串<br>String::new<br>//2.建立一个字符串数组<br>String[]::new<br>注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。</p></blockquote><h2 id="2-流stream"><a href="#2-流stream" class="headerlink" title="2.流stream"></a>2.流stream</h2><p>任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; person &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">----init----</span><br><span class="line">&#x2F;&#x2F;1.由集合获得流对象</span><br><span class="line">Stream&lt;String&gt; steam &#x3D; person.stream();</span><br><span class="line">&#x2F;&#x2F;2.对流对象进行过滤和统计</span><br><span class="line">steam.filter((s)-&gt;s.startsWith(&quot;a&quot;)) &#x2F;&#x2F;1.流过滤</span><br><span class="line">.count(); &#x2F;&#x2F;2.计算流对象中元素数目</span><br></pre></td></tr></table></figure><p>使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T—&gt;boolean 的方法。<br>上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:<br>获得流对象Stream<br>对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。<br>对流对象Stream进行及早求值，返回值不在是一个Stream对象。</p><h3 id="2-1常见高阶函数"><a href="#2-1常见高阶函数" class="headerlink" title="2.1常见高阶函数"></a>2.1常见高阶函数</h3><h4 id="1-collect方法"><a href="#1-collect方法" class="headerlink" title="1.collect方法"></a>1.collect方法</h4><p>collect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。<br>这项工作由收集器Collector完成。java8为此提供了Collectors工具类。</p><h4 id="1-1-转换成集合"><a href="#1-1-转换成集合" class="headerlink" title="1.1 转换成集合"></a>1.1 转换成集合</h4><blockquote><p>List<Person> list = stream.collect(Collectors.toList());<br>List<Person> arraylist = stream.collect(Collectors.toCollection(ArrayList::new));<br>Set<Person> set = stream.collect(Collectors.toSet());<br>Set<Person> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));</p></blockquote><p>使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型；</p><h4 id="1-2-转换成值"><a href="#1-2-转换成值" class="headerlink" title="1.2 转换成值"></a>1.2 转换成值</h4><blockquote><p>//1.获得最大最小值<br>Function&lt;Person, Integer&gt; getLevel = p-&gt;p.age;<br>Comparator<Person> comparator = Comparator.comparing(getLevel);<br>stream.collect(Collectors.maxBy(comparator));<br>stream.collect(Collectors.minBy(comparator));<br>//2.获得平均值<br>ToIntFunction<Person> getAverage = p-&gt;p.age;<br>stream.collect(Collectors.averagingInt(getAverage));</p></blockquote><h4 id="1-3-数据分块"><a href="#1-3-数据分块" class="headerlink" title="1.3 数据分块"></a>1.3 数据分块</h4><p>将流对象按某种条件分成两部分</p><blockquote><p>Predicate<Person> isTang = p-&gt;p.country.equals(Country.Tang);<br>stream.collect(Collectors.partitioningBy(isTang));</p></blockquote><h4 id="1-4-数据分组"><a href="#1-4-数据分组" class="headerlink" title="1.4 数据分组"></a>1.4 数据分组</h4><blockquote><p>Function&lt;Person, Integer&gt; country= p -&gt; p.country.ordinal();<br>stream.collect(Collectors.groupingBy(country));</p></blockquote><p>分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。</p><h4 id="1-5-字符串"><a href="#1-5-字符串" class="headerlink" title="1.5 字符串"></a>1.5 字符串</h4><blockquote><p>stream.map(Person::getName).collect(Collectors.joining(“/“, “[“, “]”));</p></blockquote><h4 id="1-6-合并收集器"><a href="#1-6-合并收集器" class="headerlink" title="1.6 合并收集器"></a>1.6 合并收集器</h4><blockquote><p>stream.collect(Collectors.groupingBy(country,Collectors.counting()));</p></blockquote><h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h3><p>map是一个惰性求值方法。函数接口为Function&lt;T, R&gt;函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。</p><h3 id="3-filter"><a href="#3-filter" class="headerlink" title="3.filter"></a>3.filter</h3><p>filter 是一个惰性求值方法。函数接口为Pridicate<T>,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。</p><h3 id="4-flatMap系列"><a href="#4-flatMap系列" class="headerlink" title="4.flatMap系列"></a>4.flatMap系列</h3><p>flatMap 是一个惰性求值方法。其参数亦为Function&lt;T, R&gt;,将多个流组合为一个流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.a1,a2是两个列表，map处理后仍是两个列表</span><br><span class="line">Stream.of(a1,a2).map(s-&gt;s)</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.flatMap将二者合并为一个流</span><br><span class="line">Stream.of(a1,a2).map(s-&gt;s)</span><br><span class="line">.flatMap(s-&gt;s.stream())</span><br></pre></td></tr></table></figure><p>1234<br>看源码可知，flatMap中函数接口Function的输出类型为Stream<R>。</p><h3 id="5-max-min"><a href="#5-max-min" class="headerlink" title="5.max/min"></a>5.max/min</h3><p>属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。<br>min(Comparator.comparing(s-&gt;s.toString()));<br>max/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。</p><h3 id="6-reduce"><a href="#6-reduce" class="headerlink" title="6.reduce"></a>6.reduce</h3><p>属于一个及早求值方法。意为流数据的累加，有两个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.无初始值累加</span><br><span class="line">T t &#x3D; person.stream().reduce((a,b)-&gt;a+b);</span><br><span class="line">&#x2F;&#x2F;2.带初始值累加</span><br><span class="line">Optional&lt;T&gt; t &#x3D; person.stream().reduce(&quot;1&quot;,(a,b)-&gt;a+b);</span><br></pre></td></tr></table></figure><h3 id="7-foreach"><a href="#7-foreach" class="headerlink" title="7.foreach"></a>7.foreach</h3><p>属于一个及早求值方法，用来遍历流对象。<br>总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。&lt;br&gt;在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。&lt;/p&gt;
&lt;h2 id=&quot;1-Lambda表达式&quot;&gt;&lt;a href=&quot;#1-Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;1.Lambda表达式&quot;&gt;&lt;/a&gt;1.Lambda表达式&lt;/h2&gt;&lt;p&gt;Java 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。&lt;br&gt;Java 8中使用新特性Lambda表达式来改善这一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://dduggs.top/categories/%E7%BC%96%E7%A8%8B/Java/"/>
    
    
      <category term="Lambda" scheme="http://dduggs.top/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>hexo自动部署至VPS</title>
    <link href="http://dduggs.top/2017/03/03/webhook/"/>
    <id>http://dduggs.top/2017/03/03/webhook/</id>
    <published>2017-03-03T06:14:15.000Z</published>
    <updated>2020-07-02T03:38:14.828Z</updated>
    
    <content type="html"><![CDATA[<p>之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low<del>”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了</del>o(￣▽￣)o~ (小装一波~)。</p><blockquote><p>最终实现：自己电脑上新建文章后，hexo clean &amp;&amp; hexo g -d 即可。<br>实现原理：<br>1.hexo 提交代码渲染后文件至远程仓库(coding)<br>2.coding中对应项目配置webhook发送执行请求<br>3.vps 接收指定请求执行脚本(拉取最新代码)</p></blockquote><a id="more"></a><p>操作分为本机上和vps上的操作。</p><h3 id="hexo本地配置及部署"><a href="#hexo本地配置及部署" class="headerlink" title="hexo本地配置及部署"></a>hexo本地配置及部署</h3><blockquote><p>hexo是基于nodejs开发的，npm是nodejs的包管理工具<br>git用于部署代码<br>所以首页应确认本机环境：git，node.js环境<br>git,node.js安装可另查资料</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#安装hexo命令行工具</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">#创建blog目录，并初始化hexo项目</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">hexo new &quot;My First Post&quot;</span><br><span class="line">#生成相关静态文件</span><br><span class="line">hexo g</span><br><span class="line">#启动本地服务，查看效果（http:&#x2F;&#x2F;localhost:4000）</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>hexo的git配置，hexo根目录下_config.yml文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  message: update</span><br><span class="line">  repo: git@git.coding.net:letra&#x2F;hexo.git </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#代码部署</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了<br>重点来了！！！</p><h3 id="远程仓库配置WebHooks"><a href="#远程仓库配置WebHooks" class="headerlink" title="远程仓库配置WebHooks"></a>远程仓库配置WebHooks</h3><p><img src="/img/articleImg/webhook.png" alt=""><br>这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到<a href="http://karson.cc:4002/webhooks/push/123456。" target="_blank" rel="noopener">http://karson.cc:4002/webhooks/push/123456。</a></p><p>为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。</p><p>到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。</p><h3 id="VPS相关配置"><a href="#VPS相关配置" class="headerlink" title="VPS相关配置"></a>VPS相关配置</h3><p>在hexo目录中新建webhook.js,内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line">var exec &#x3D; require(&#39;child_process&#39;).exec</span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。</span><br><span class="line">if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;webhooks&#x2F;push&#x2F;123456&#39;)&#123;</span><br><span class="line">#如果url匹配，表示认证通过，则执行 sh .&#x2F;deploy.sh</span><br><span class="line">exec(&#39;sh .&#x2F;deploy.sh&#39;)</span><br><span class="line">&#125;</span><br><span class="line">res.end()</span><br><span class="line">&#125;).listen(4002)</span><br></pre></td></tr></table></figure><p>这段代码就能启动一个nodejs服务，监听4002端口。<br>当请求过来的url完全匹配的时候，执行deploy.sh。<br>再新建一个文件deploy.sh处理部署相关脚本，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>然后在服务器中启动nodejs服务监听webhooks<br>使用PM2执行脚本<a href="http://www.cnblogs.com/zhongweiv/p/pm2.html" target="_blank" rel="noopener">PM2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line">pm2 start webhook.js</span><br></pre></td></tr></table></figure><p>然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low&lt;del&gt;”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了&lt;/del&gt;o(￣▽￣)o~ (小装一波~)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最终实现：自己电脑上新建文章后，hexo clean &amp;amp;&amp;amp; hexo g -d 即可。&lt;br&gt;实现原理：&lt;br&gt;1.hexo 提交代码渲染后文件至远程仓库(coding)&lt;br&gt;2.coding中对应项目配置webhook发送执行请求&lt;br&gt;3.vps 接收指定请求执行脚本(拉取最新代码)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="其他" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Git" scheme="http://dduggs.top/tags/Git/"/>
    
      <category term="Webhook" scheme="http://dduggs.top/tags/Webhook/"/>
    
  </entry>
  
  <entry>
    <title>Linux下防御/减轻DDOS攻击</title>
    <link href="http://dduggs.top/2017/03/03/ddos/"/>
    <id>http://dduggs.top/2017/03/03/ddos/</id>
    <published>2017-03-03T05:30:03.000Z</published>
    <updated>2020-07-02T03:29:13.393Z</updated>
    
    <content type="html"><![CDATA[<p>好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。<br>登录后台就发现可能是被攻击了，导致被官方限制使用。<br><img src="/img/articleImg/vpsproblem.jpg" alt=""></p><a id="more"></a><p>被莫名的攻击后也是张二和尚摸不着头脑。<br>还能咋办叻?Goole<del>&amp;Baidu</del><br>然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~</p><h2 id="DDoS-deflate介绍"><a href="#DDoS-deflate介绍" class="headerlink" title="DDoS deflate介绍"></a>DDoS deflate介绍</h2><blockquote><p>DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过&gt;netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过<br>预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.</p></blockquote><h3 id="如何确认是否受到DDOS攻击？"><a href="#如何确认是否受到DDOS攻击？" class="headerlink" title="如何确认是否受到DDOS攻击？"></a>如何确认是否受到DDOS攻击？</h3><p>由于我是直接重装了系统，所以这一步仅供参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntu | awk &#39;&#123;print $5&#125;&#39; | cut -d: -f1 | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure><p>据说：执行后，将会显示服务器上所有的每个IP多少个连接数。</p><h3 id="1-安装DDoS-deflate"><a href="#1-安装DDoS-deflate" class="headerlink" title="1.安装DDoS deflate"></a>1.安装DDoS deflate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www.inetbase.com&#x2F;scripts&#x2F;ddos&#x2F;install.sh   &#x2F;&#x2F;下载DDoS  deflate</span><br><span class="line">chmod 0700 install.sh    &#x2F;&#x2F;添加权限</span><br><span class="line">.&#x2F;install.sh             &#x2F;&#x2F;执行</span><br></pre></td></tr></table></figure><h3 id="2-配置DDoS-deflate"><a href="#2-配置DDoS-deflate" class="headerlink" title="2.配置DDoS deflate"></a>2.配置DDoS deflate</h3><p>DDoS deflate的默认配置位于/usr/local/ddos/ddos.conf<br>内容如下<br><img src="/img/articleImg/ddosconf.png" alt=""></p><p>查看/usr/local/ddos/ddos.sh文件的第117行<br>(vim模式下 跳转命令：行号 即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST</span><br></pre></td></tr></table></figure><p>修改为以下代码即可！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sed -n ‘&#x2F;[0-9]&#x2F;p’ | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。&lt;br&gt;登录后台就发现可能是被攻击了，导致被官方限制使用。&lt;br&gt;&lt;img src=&quot;/img/articleImg/vpsproblem.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="安全" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ddos" scheme="http://dduggs.top/tags/ddos/"/>
    
  </entry>
  
  <entry>
    <title>VPS安装及配置nginx</title>
    <link href="http://dduggs.top/2017/01/04/vps-install-nginx/"/>
    <id>http://dduggs.top/2017/01/04/vps-install-nginx/</id>
    <published>2017-01-04T05:43:14.000Z</published>
    <updated>2020-07-02T03:35:07.618Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br><img src="/img/articleImg/nginx.jpg" alt=""></p><a id="more"></a><h2 id="环境确认"><a href="#环境确认" class="headerlink" title="环境确认"></a>环境确认</h2><p>系统环境：Centos 6<br>安装方式：源码编译安装 <a href="http://www.285868.com/a/xtjc/5635.html" target="_blank" rel="noopener">几种Linux软件的安装方法</a><br>安装位置：/usr/local/nginx</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>进入安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br></pre></td></tr></table></figure><h3 id="安装pcre-用于Nginx的HTTP-Rewrite-模块"><a href="#安装pcre-用于Nginx的HTTP-Rewrite-模块" class="headerlink" title="安装pcre(用于Nginx的HTTP Rewrite 模块)"></a>安装pcre(用于Nginx的HTTP Rewrite 模块)</h3><blockquote><p>注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。<br>另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src </span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.38.tar.gz     </span><br><span class="line">tar -zxvf pcre-8.38.tar.gz #解压文件</span><br><span class="line">mv pcre-8.38   pcre #修改解压后文件夹名称</span><br><span class="line">cd pcre</span><br><span class="line">.&#x2F;configure #准备编译</span><br><span class="line">make &amp; make install#编译及安装</span><br></pre></td></tr></table></figure><h3 id="安装zilb-一个压缩和解压模块"><a href="#安装zilb-一个压缩和解压模块" class="headerlink" title="安装zilb(一个压缩和解压模块)"></a>安装zilb(一个压缩和解压模块)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.8.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.8.tar.gz</span><br><span class="line">mv zlib-1.2.8 zlib</span><br><span class="line">cd zlib</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装SSl模块"><a href="#安装SSl模块" class="headerlink" title="安装SSl模块"></a>安装SSl模块</h3><blockquote><p>openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.1c.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.1c.tar.gz</span><br><span class="line">mv openssl-1.0.1c  openssl</span><br><span class="line">.&#x2F;config</span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.9.9.tar.gz</span><br><span class="line">tar -zxvf nginx-1.9.9.tar.gz</span><br><span class="line">cd nginx-1.9.9</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \</span><br><span class="line">--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_v2_module \</span><br><span class="line">--with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre \</span><br><span class="line">--with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib \</span><br><span class="line">--with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;openssl</span><br><span class="line"></span><br><span class="line">make &amp; make install</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx #进入nginx目录</span><br><span class="line">nginx#启动nginx</span><br></pre></td></tr></table></figure><p>启动后浏览器导航到<a href="http://IP" target="_blank" rel="noopener">http://IP</a> 就可以看到默认的欢迎界面了</p><h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop停止nginx</span><br><span class="line">nginx 运行nginx</span><br><span class="line">nginx -s reload 重启nginx</span><br><span class="line">nginx -t 测试nginx</span><br></pre></td></tr></table></figure><h3 id="nginx加入到环境变量"><a href="#nginx加入到环境变量" class="headerlink" title="nginx加入到环境变量"></a>nginx加入到环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>尾行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx #nginx安装目录</span><br><span class="line">export PATH </span><br></pre></td></tr></table></figure><p>保存关闭后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h3 id="修改网站默认根目录路径"><a href="#修改网站默认根目录路径" class="headerlink" title="修改网站默认根目录路径"></a>修改网站默认根目录路径</h3><blockquote><p>网站默认根目录放在/usr/local/nginx/html</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  你的IP;</span><br><span class="line">#charset koi8-r;</span><br><span class="line"></span><br><span class="line">#access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">root  &#x2F;www&#x2F;blog&#x2F;public;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root添加自己想要的根目录，重启nginx生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。&lt;br&gt;&lt;img src=&quot;/img/articleImg/nginx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/Linux/"/>
    
    
      <category term="Nginx" scheme="http://dduggs.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>VPS搭建多端口VPN</title>
    <link href="http://dduggs.top/2016/12/20/vps/"/>
    <id>http://dduggs.top/2016/12/20/vps/</id>
    <published>2016-12-20T08:37:45.000Z</published>
    <updated>2020-07-02T03:35:25.149Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/articleImg/naruto.jpg" alt=""></p><a id="more"></a><h2 id="所需"><a href="#所需" class="headerlink" title="所需"></a>所需</h2><p>1.他乡vps一台<br>2.xshell用于远程登录<br>3.shadowsocks应用程序。<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">点这里</a></p><h2 id="Ready"><a href="#Ready" class="headerlink" title="Ready."></a>Ready.</h2><p>1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。<br>2.<a href="http://hostingset.com/" target="_blank" rel="noopener">购买VPS</a><br>3.打开xshell连接<br><img src="/img/articleImg/xshell.png" alt=""></p><h2 id="GO！！"><a href="#GO！！" class="headerlink" title="GO！！"></a>GO！！</h2><p>1.安装所需组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install m2crypto python-setuptools</span><br><span class="line">easy_install pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>2.新建配置文件：shadowsocks.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;23.105.215.43&quot;,   #你服务器的ip</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;           #端口以及对应的密码</span><br><span class="line">         &quot;9000&quot;:&quot;password&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;password&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;rc4-md5&quot;,         #选择的加密方式</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start  #后台运行</span><br></pre></td></tr></table></figure><p>4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~<br>5.Android用户想要连接本文配置的vpn,请搜下图app.<br><img src="/img/articleImg/shadowsocks.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/articleImg/naruto.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://dduggs.top/categories/%E8%BF%90%E7%BB%B4/Linux/"/>
    
    
      <category term="vpn" scheme="http://dduggs.top/tags/vpn/"/>
    
  </entry>
  
</feed>
