{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/yilia/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/love.js","path":"love.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/assets/wx_pay.jpg","path":"assets/wx_pay.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/assets/9zai.jpg","path":"assets/9zai.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/assets/letra.jpg","path":"assets/letra.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-06-29/1.png","path":"articleImage/2020-06-29/1.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-06-29/2.png","path":"articleImage/2020-06-29/2.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-03/2.png","path":"articleImage/2020-07-03/2.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-03/4.png","path":"articleImage/2020-07-03/4.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-07/udp.png","path":"articleImage/2020-07-07/udp.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/1.jpg","path":"articleImage/2020-07-08/1.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/2.jpg","path":"articleImage/2020-07-08/2.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/3.jpg","path":"articleImage/2020-07-08/3.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/4.jpg","path":"articleImage/2020-07-08/4.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-09/socket1.jpg","path":"articleImage/2020-07-09/socket1.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-24/3.png","path":"articleImage/2020-07-24/3.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-28/1.jpg","path":"articleImage/2020-07-28/1.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-28/2.jpg","path":"articleImage/2020-07-28/2.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/assets/karon.jpg","path":"assets/karon.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-03/3.jpg","path":"articleImage/2020-07-03/3.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-03/3.png","path":"articleImage/2020-07-03/3.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-07/3.png","path":"articleImage/2020-07-07/3.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-07/4.png","path":"articleImage/2020-07-07/4.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-07/hdck1.png","path":"articleImage/2020-07-07/hdck1.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/5.png","path":"articleImage/2020-07-08/5.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-09/1.png","path":"articleImage/2020-07-09/1.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-24/线程池添加线程规则.png","path":"articleImage/2020-07-24/线程池添加线程规则.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/3.png","path":"articleImage/2020-07-08/3.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-24/线程池结构.png","path":"articleImage/2020-07-24/线程池结构.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-28/1.png","path":"articleImage/2020-07-28/1.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-03/1.png","path":"articleImage/2020-07-03/1.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-08/4.png","path":"articleImage/2020-07-08/4.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-24/线程池构造函数的参数.png","path":"articleImage/2020-07-24/线程池构造函数的参数.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-03/osi.gif","path":"articleImage/2020-07-03/osi.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-09/B-tree.png","path":"articleImage/2020-07-09/B-tree.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-07/2.png","path":"articleImage/2020-07-07/2.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/articleImage/2020-07-09/B+-Tree.png","path":"articleImage/2020-07-09/B+-Tree.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"bcbff434d61bbae2ba5fff5a6d583eebcd48a742","modified":1593311931718},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1592977545749},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1592977545749},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1592977545750},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1592977545750},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1592977545750},{"_id":"themes/yilia/_config.yml","hash":"8b12aac2526eedb3e0ab4d7761bf32feb0425773","modified":1593683564154},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1592977545752},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1592977545776},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1592977545822},{"_id":"source/_posts/Comparable.md","hash":"4b1b572353c3052997532ad954a3aadee3e63ed0","modified":1593661198701},{"_id":"source/_posts/HTTP相关.md","hash":"3ad7f8f3cda4b3fcde26ea0cd034cbf54ee7bee7","modified":1594197303869},{"_id":"source/_posts/Hexo博客多电脑同步.md","hash":"d14405c1e0bec80136b85b876f2dfed0c36c1bc0","modified":1593683691255},{"_id":"source/_posts/Http与Https.md","hash":"19a9756afd4057beda831d06b8c7ed8f3bef274f","modified":1594200755018},{"_id":"source/_posts/Lambda.md","hash":"208779782e801cfb4c7c7c7e1c5b80a704d097eb","modified":1593660803248},{"_id":"source/_posts/Local-Debug-Dubbo.md","hash":"055be0a41b53a05a473fb9aed1462fbffd325507","modified":1593660828252},{"_id":"source/_posts/LocalDate.md","hash":"b1c711c28a1cbfd4c35da9a1594e47423fce7a1b","modified":1593660843658},{"_id":"source/_posts/TCP三次握手.md","hash":"802a624a483d9ae0dcd1da8db9e1b1172f44d218","modified":1593763240856},{"_id":"source/_posts/TCP和UDP的区别.md","hash":"b008ef16aee0f6e998e3c68f6cf75f0cb065555e","modified":1594091104385},{"_id":"source/_posts/TCP四次挥手.md","hash":"f0cf94cf9a1318d4aaec8a97a02527fa53038bb6","modified":1593771623751},{"_id":"source/_posts/TCP滑动窗口.md","hash":"ce8bc117366f5e37be3fb5a4ed460175a8ad1353","modified":1594102741673},{"_id":"source/_posts/ddos.md","hash":"e6d0ebf87c22db186dfd3543287d89dd440f8700","modified":1593660553393},{"_id":"source/_posts/druidError.md","hash":"44db9f0ca070cffae1eca4009ae87c3dd13d9b0e","modified":1593660669965},{"_id":"source/_posts/duplicateRemoval.md","hash":"ed05e1a324abb6b77d0353ae986a15078c22713a","modified":1593660798050},{"_id":"source/_posts/javaMail.md","hash":"7caabf0d39da7f512537d11a9c8a7c21c6f3c57f","modified":1593661186170},{"_id":"source/_posts/mapSort.md","hash":"c43d6e87ba91a860c1b3b92d14ee3a07a0919da3","modified":1593660851063},{"_id":"source/_posts/paramPass.md","hash":"44ffd815540e757cf058e23f64ee7e9711fdf1ac","modified":1593660867564},{"_id":"source/_posts/mvcdemo.md","hash":"74c74ff3e1154a8be6e318111a5adda3252c2be4","modified":1593660859576},{"_id":"source/_posts/redis_install.md","hash":"ac16685851203eae1c15ca5421fd301e9e421e5f","modified":1593660361632},{"_id":"source/_posts/socket.md","hash":"937d961b7034b46681774e030bd8ebbe6e012f5a","modified":1594274893462},{"_id":"source/_posts/springmvcPost.md","hash":"fec4d48e9e0bc61cef4f0719584f1ccb407a6257","modified":1593660892962},{"_id":"source/_posts/threadLocal.md","hash":"3200f3b45dedf4148fafa6a64783f9c4a6506d19","modified":1595934941563},{"_id":"source/_posts/vps-install-nginx.md","hash":"386e19ffe5473e764ad345323525e901e540433d","modified":1593660907618},{"_id":"source/_posts/vps.md","hash":"ab8eac4eca9d14bb5d44fb4596f32f5a8728d470","modified":1593660925149},{"_id":"source/_posts/webhook.md","hash":"cb2517e86ea81f3f9ed5bb8d20166ccabc622086","modified":1593661094828},{"_id":"source/_posts/线程池.md","hash":"97ccfb2b3788cbd919f4e18a08b7cb38d5c38614","modified":1595578026981},{"_id":"source/_posts/计算机网络.md","hash":"64b2f4a3c3080ae6986f592a1675eb39fde6821b","modified":1594201110476},{"_id":"source/_posts/自定义注解.md","hash":"aea0257224447b86cb23873644a616f3099d145d","modified":1595583859897},{"_id":"source/categories/index.md","hash":"660e43af185e4fd21d39e673c403de54b167c695","modified":1593575654737},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1592977545753},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1592977545753},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1592977545754},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1592977545754},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1592977545755},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1592977545755},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1592977545755},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1592977545773},{"_id":"themes/yilia/layout/categories.ejs","hash":"8bc6394fbeb1cc6e98d63778b5c197a29fd076e5","modified":1593575866831},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1592977545774},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1592977545774},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1592977545775},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1592977545775},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1592977545776},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1592977545776},{"_id":"themes/yilia/source/favicon.png","hash":"6a26261e5d86e062340fcb4bb96764389d04d3ec","modified":1593579231748},{"_id":"themes/yilia/source/love.js","hash":"82f281edb49e48cf2f3817445b23cab465f8e5a9","modified":1593588188191},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"2bd1d7183da75057565018886ba400f8b249eaef","modified":1593575811440},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1592977545821},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1592977545777},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1592977545811},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1592977545770},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1592977545819},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1592977545820},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1592977545757},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1592977545757},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"69361558e97d5d1a6a06af22501b62a07e04c912","modified":1593655175637},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"321681ce752a6b8a8cc25f0b90d27ba992fc2e76","modified":1593583105146},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1592977545759},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1592977545759},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1592977545760},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"b97fd8885fae2cda556e9024ad8bfd5b346eb5b7","modified":1593588237336},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1592977545760},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1592977545761},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1592977545762},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1592977545762},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1592977545763},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1592977545763},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1592977545772},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1592977545772},{"_id":"themes/yilia/source/assets/wx_pay.jpg","hash":"100a8beb3bf715471f65465eecc5b506217fba2f","modified":1593579271674},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1592977545812},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1592977545813},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1592977545814},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1592977545815},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1592977545815},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1592977545816},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1592977545817},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1592977545818},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1592977545817},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1592977545778},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1592977545779},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1592977545779},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1592977545780},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1592977545780},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1592977545781},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1592977545782},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1592977545781},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"df921497bc49e66545c78787cfaa7147c0f08167","modified":1593428574887},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1592977545786},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1592977545791},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1592977545791},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1592977545791},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1592977545792},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1592977545795},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1592977545794},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1592977545796},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1592977545796},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1592977545797},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1592977545797},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1592977545798},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1592977545798},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1592977545799},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1592977545800},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1592977545800},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1592977545801},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1592977545802},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1592977545803},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1592977545804},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1592977545803},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1592977545805},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1592977545805},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1592977545806},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1592977545807},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1592977545808},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1592977545807},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1592977545809},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1592977545810},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1592977545810},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"ba92cf9bcee18bc1f5a190e8c0ea21e185d0382b","modified":1593655175639},{"_id":"themes/yilia/source/assets/9zai.jpg","hash":"f7e2644145a458f7cfb6a5d98e6684d601e3377d","modified":1593334218634},{"_id":"themes/yilia/source/assets/letra.jpg","hash":"9c378bbf7c0c90d0e29b1e799bb7371ab1f85e34","modified":1593590598145},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1592977545765},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1592977545764},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1592977545765},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1592977545766},{"_id":"themes/yilia/layout/_partial/post/gitalk.ejs","hash":"032d8d94b3b0eeac492d8d655762dac4ccb8aacd","modified":1593428512597},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1592977545766},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1592977545767},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"f464a06d565ec2b207857ca88429648be5b9a5ad","modified":1593486753306},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1592977545768},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1592977545768},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1592977545769},{"_id":"themes/yilia/source/articleImage/2020-06-29/1.png","hash":"1b86b2b6f4ccb86607415693b8e41eb991125191","modified":1593655175640},{"_id":"themes/yilia/source/articleImage/2020-06-29/2.png","hash":"0fe7118e0dbe7ab40306189e90b6b9c7c9190a7f","modified":1593655175640},{"_id":"themes/yilia/source/articleImage/2020-07-03/2.png","hash":"7aae332feaa655274c396ca52b128e47bb5b4dc7","modified":1593756446716},{"_id":"themes/yilia/source/articleImage/2020-07-03/4.png","hash":"155cfe6a669077b47ba0faa3a934843f4c39776f","modified":1594089958402},{"_id":"themes/yilia/source/articleImage/2020-07-07/udp.png","hash":"bdcb9bcf8acb27cfe54352dc7880db177dd77323","modified":1594089992899},{"_id":"themes/yilia/source/articleImage/2020-07-08/1.jpg","hash":"5fd37f618ed26f5bbc5a2b5b76232023a7657f86","modified":1594193180626},{"_id":"themes/yilia/source/articleImage/2020-07-08/2.jpg","hash":"8a585a511da5607b51da55f3d23c5fcf26e22280","modified":1594193792668},{"_id":"themes/yilia/source/articleImage/2020-07-08/3.jpg","hash":"eb028567e7f76fc94ec9fdfd8cce70410b2657e6","modified":1594194378621},{"_id":"themes/yilia/source/articleImage/2020-07-08/4.jpg","hash":"88cb717366595c4227db9eab3da5f1db3d908391","modified":1594199660068},{"_id":"themes/yilia/source/articleImage/2020-07-09/socket1.jpg","hash":"156542b7179789941f9d4dc7c1cbc3657adde84d","modified":1594267046386},{"_id":"themes/yilia/source/articleImage/2020-07-24/3.png","hash":"7b098525fe01eec8e8be8fe7281641ca6122490d","modified":1595583329072},{"_id":"themes/yilia/source/articleImage/2020-07-28/1.jpg","hash":"4385747d64c1c33f44d55889cd461124e952e001","modified":1595933372456},{"_id":"themes/yilia/source/articleImage/2020-07-28/2.jpg","hash":"7683da1d61c077c162343ffabf566511a3a14acb","modified":1595933407321},{"_id":"themes/yilia/source/assets/karon.jpg","hash":"41cb22ef5b1f858d0830dcedec9482fd873eaf07","modified":1593334184192},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1592977545784},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1592977545783},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1592977545784},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1592977545785},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1592977545786},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1592977545789},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1592977545788},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1592977545789},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1592977545790},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1592977545793},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1592977545793},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1592977545794},{"_id":"themes/yilia/source/articleImage/2020-07-03/3.jpg","hash":"c2a205a8715b74cb65ebc2d2574fb92f40ae04f0","modified":1594089806859},{"_id":"themes/yilia/source/articleImage/2020-07-03/3.png","hash":"bcbeb5ddb5653dd4f4cfb66851bbce619095b1df","modified":1594089916504},{"_id":"themes/yilia/source/articleImage/2020-07-07/3.png","hash":"191a9127234bbee1e9c8849e54520c9de9258db2","modified":1594102578385},{"_id":"themes/yilia/source/articleImage/2020-07-07/4.png","hash":"4cbf7773c58ce616c96e7769271c5a3d105b9300","modified":1594102585758},{"_id":"themes/yilia/source/articleImage/2020-07-07/hdck1.png","hash":"d4c92a5ebeb09f06c01d39c3bed627ff561e8747","modified":1594100660459},{"_id":"themes/yilia/source/articleImage/2020-07-08/5.png","hash":"b54ecf43d0d66789f649b9067f13102c203ad969","modified":1594200178276},{"_id":"themes/yilia/source/articleImage/2020-07-09/1.png","hash":"700c2260bdb7a07098f5744ec6950ee0833150ca","modified":1594266920624},{"_id":"themes/yilia/source/articleImage/2020-07-24/线程池添加线程规则.png","hash":"0b647c72d15ae03c9ae758fce76d3a2bb8b97a9e","modified":1577898368000},{"_id":"themes/yilia/source/articleImage/2020-07-08/3.png","hash":"176ba96337db4656ac45ee4784d863e306e9babb","modified":1594194058241},{"_id":"themes/yilia/source/articleImage/2020-07-24/线程池结构.png","hash":"e31263deefeef4525debdf14564eb42f505c9a00","modified":1577898368000},{"_id":"themes/yilia/source/articleImage/2020-07-28/1.png","hash":"1cb22ac59da54cc1126149d31df3c449b0fcb153","modified":1577898368000},{"_id":"themes/yilia/source/articleImage/2020-07-03/1.png","hash":"0ec2d4a686189a67ab4d20bd11007e0bd014e77b","modified":1593748379575},{"_id":"themes/yilia/source/articleImage/2020-07-08/4.png","hash":"53793e0b34f43cee938644d4d5c181bc83136c02","modified":1594194387741},{"_id":"themes/yilia/source/articleImage/2020-07-24/线程池构造函数的参数.png","hash":"0447bf3d4382406c5c268ceb3edce866ee4454ac","modified":1577898368000},{"_id":"themes/yilia/source/articleImage/2020-07-03/osi.gif","hash":"d8ad371232dff39d27a4f47547861191ee7b104e","modified":1593755208655},{"_id":"themes/yilia/source/articleImage/2020-07-09/B-tree.png","hash":"da53bf174ddeee44f30d01ee72748c347a986112","modified":1594360647899},{"_id":"themes/yilia/source/articleImage/2020-07-07/2.png","hash":"9528a81e8e588fd5cf7de19749e3685f6e008b28","modified":1594101619568},{"_id":"themes/yilia/source/articleImage/2020-07-09/B+-Tree.png","hash":"df151366c0aaa4bf88e98fc2b40ecbe81ab309b4","modified":1594360906760},{"_id":"public/atom.xml","hash":"4c7680cdb67dd6445c420279355d30d0c55c2e30","modified":1595934955286},{"_id":"public/content.json","hash":"fb78210b6416ed3d2ee04f082c729ad604c1d830","modified":1595934955286},{"_id":"public/categories/index.html","hash":"31ff8ac75d6b934436cef2a5cf4bffbb9f9ddb52","modified":1595934955286},{"_id":"public/2020/07/28/threadLocal/index.html","hash":"f3615d5569cf1dbf8e660763036f6fc7617f3224","modified":1595934955286},{"_id":"public/2020/07/24/自定义注解/index.html","hash":"d5c3e7227fdf374971d2e725f069750016e23244","modified":1595934955286},{"_id":"public/2020/07/24/线程池/index.html","hash":"ae739531da3e3e6fd93777e4faf4440a04c9abf6","modified":1595934955286},{"_id":"public/2020/07/09/socket/index.html","hash":"1e8f06510f8db38b6673bf95605c3b0ed1f80241","modified":1595934955286},{"_id":"public/2020/07/08/Http与Https/index.html","hash":"6a72d81bc762464b78d15841da7d8e36ccad16ab","modified":1595934955286},{"_id":"public/2020/07/08/HTTP相关/index.html","hash":"9d07d6a47990124c3f2d15fd95d067a02e320d9b","modified":1595934955286},{"_id":"public/2020/07/07/TCP滑动窗口/index.html","hash":"083e6339c24baa6eb4d7d8668c3d0aec497531e9","modified":1595934955286},{"_id":"public/2020/07/07/TCP和UDP的区别/index.html","hash":"6225cf915afcc17e1cbe5fced28b501e7a875505","modified":1595934955286},{"_id":"public/2020/07/03/TCP四次挥手/index.html","hash":"14c591f719259670fbccc998f1496c1cb3bbdb7d","modified":1595934955286},{"_id":"public/2020/07/03/TCP三次握手/index.html","hash":"b54d0a779fb611eed55b3a5338ddfc5d0562a54c","modified":1595934955286},{"_id":"public/2020/07/03/计算机网络/index.html","hash":"7681f64b7238f0436b3986e200c8b959529a3bef","modified":1595934955286},{"_id":"public/2020/06/29/Hexo博客多电脑同步/index.html","hash":"3bf1fb7ed941a9da0bbfa557174b3a14807f99c6","modified":1595934955286},{"_id":"public/2020/06/28/Local-Debug-Dubbo/index.html","hash":"85c8b34733710a5d92973aac5fbfc80951d4f141","modified":1595934955286},{"_id":"public/2017/07/21/redis_install/index.html","hash":"b3871300408c798e8a49da129dd948e809697e95","modified":1595934955286},{"_id":"public/2017/05/26/duplicateRemoval/index.html","hash":"925156084f52b0ee327df7e6ed88313860447182","modified":1595934955286},{"_id":"public/2017/05/25/javaMail/index.html","hash":"a29619209237d817067fc0d7fa73d547fabf5a5d","modified":1595934955286},{"_id":"public/2017/05/24/paramPass/index.html","hash":"885d2d6db4655b4da6b65aa073b6a68ccdaebdca","modified":1595934955286},{"_id":"public/2017/04/01/LocalDate/index.html","hash":"1f27503bd9ae48493aaa26dc75799f6d8a8a5eec","modified":1595934955286},{"_id":"public/2017/03/31/springmvcPost/index.html","hash":"7fc21bfbfad777dbfba2fb08c641832715bef0f9","modified":1595934955286},{"_id":"public/2017/03/20/mvcdemo/index.html","hash":"64a97d7d8aba9de3fe0e660b989b36dd7c29bc89","modified":1595934955286},{"_id":"public/2017/03/15/Comparable/index.html","hash":"44c8ff73885e7e64e13e50bdb9819f4220320b85","modified":1595934955286},{"_id":"public/2017/03/15/mapSort/index.html","hash":"455889a8e3e78b026680dec4ac53c117e61b46c4","modified":1595934955286},{"_id":"public/2017/03/14/druidError/index.html","hash":"0f1450c3c2d2d1cd636af702a79896e7ff8d6cba","modified":1595934955286},{"_id":"public/2017/03/13/Lambda/index.html","hash":"5040968269c4f0e4983e2648c7c2a7f0b0d75d73","modified":1595934955286},{"_id":"public/2017/03/03/webhook/index.html","hash":"9ff721ab8240dde5dc863ba0ff30cf9b2426b1f6","modified":1595934955286},{"_id":"public/2017/03/03/ddos/index.html","hash":"ac4bb01e7afdeb574c59a427bcde64f3e03a96bf","modified":1595934955286},{"_id":"public/2017/01/04/vps-install-nginx/index.html","hash":"2b597e0607eecd47261a1ec97c6eea18ed84624c","modified":1595934955286},{"_id":"public/2016/12/20/vps/index.html","hash":"d57446da79515633991dbf1c62a99229294b23f7","modified":1595934955286},{"_id":"public/archives/index.html","hash":"0914fa4849de369e5ff1a12b8b607cbc43ba75e1","modified":1595934955286},{"_id":"public/archives/page/2/index.html","hash":"b957c8d17dea7c13cd03d455fd106e1c481dfb4f","modified":1595934955286},{"_id":"public/archives/page/3/index.html","hash":"5bf555af05e1351887421b8673934568d934eb1c","modified":1595934955286},{"_id":"public/archives/2016/index.html","hash":"547d60c3ae6a9bd7cc0062829d6c5fcf4dac4985","modified":1595934955286},{"_id":"public/archives/2016/12/index.html","hash":"e86f799b8ec08b00197b4bb120d6c2c2562ada16","modified":1595934955286},{"_id":"public/archives/2017/index.html","hash":"c1965fe4f54cd09c78e2ef2b323c402619ff9bd6","modified":1595934955286},{"_id":"public/archives/2017/page/2/index.html","hash":"848f7732b8395c864ca787a2703979bce46005ad","modified":1595934955286},{"_id":"public/archives/2017/01/index.html","hash":"e8075401d38c73e1b01ae2f6742d8110a40126e3","modified":1595934955286},{"_id":"public/archives/2017/03/index.html","hash":"9f66b0216c6fab6faff9c52e0d6ba0243ae39bb9","modified":1595934955286},{"_id":"public/archives/2017/04/index.html","hash":"6059b996c610a01cdf7d339aa2c15582bcfc7c13","modified":1595934955286},{"_id":"public/archives/2017/05/index.html","hash":"746d5c155a626fd182af965a3ea268a50b8c67d2","modified":1595934955286},{"_id":"public/archives/2017/07/index.html","hash":"7cfd42620766d5d5efed1e61140b0a4c0f494fe5","modified":1595934955286},{"_id":"public/archives/2020/index.html","hash":"665bcf4a53c7848a5f7cb2b9012ca4146b7633e2","modified":1595934955286},{"_id":"public/archives/2020/page/2/index.html","hash":"15a51f14f62c5beda60192eb49d1353807aed702","modified":1595934955286},{"_id":"public/archives/2020/06/index.html","hash":"050ad8bdf12e4cd29a2b40d0a60ae21c794f0b00","modified":1595934955286},{"_id":"public/archives/2020/07/index.html","hash":"521491baa81f6d112cf0a77e76f6a04773b83327","modified":1595934955286},{"_id":"public/archives/2020/07/page/2/index.html","hash":"d673cbf3c444fa217d8997d130c099eefa850adb","modified":1595934955286},{"_id":"public/categories/编程/index.html","hash":"4155f5e3b65ff8349a2e453c3a2481f4f2ca598b","modified":1595934955286},{"_id":"public/categories/编程/page/2/index.html","hash":"d3a60e286344ac1ff38a56b30d75957156e98479","modified":1595934955286},{"_id":"public/categories/Java面试/index.html","hash":"defb1badea8e42c54f71df34f8476aafd2c1dcad","modified":1595934955286},{"_id":"public/categories/博客/index.html","hash":"e2d2adf7a018b329b7d25bfa3c98e809b0a9a947","modified":1595934955286},{"_id":"public/categories/编程/Java/index.html","hash":"6c41acd5d34907bbbef544b503fbf9b2276c0715","modified":1595934955286},{"_id":"public/categories/Java面试/计算机网络/index.html","hash":"f2dab83999262df88a1861e8db8b8ed46a7f172d","modified":1595934955286},{"_id":"public/categories/编程/效率/index.html","hash":"cbbd3d6753149612d37cf95a902acea56ba5e8a7","modified":1595934955286},{"_id":"public/categories/运维/index.html","hash":"cc7a840cdef9b3deaf55401602ab6e94ba6645e7","modified":1595934955286},{"_id":"public/categories/其他/index.html","hash":"c0f0510755ec2a098ad7bb61e4465d84d88ef1a4","modified":1595934955286},{"_id":"public/categories/编程/Spring/index.html","hash":"9ccb92f425634dae7b591f3827d6553d8a4e42ba","modified":1595934955286},{"_id":"public/categories/Java并发/index.html","hash":"1a216e294ba958cd55c4e370a8dcfcce927a1b49","modified":1595934955286},{"_id":"public/categories/运维/安全/index.html","hash":"310fcf7d5637b843aa56205d94f45408ba425d96","modified":1595934955286},{"_id":"public/categories/运维/Linux/index.html","hash":"209e4f0c619f8a7576434ece0f34309a3e796407","modified":1595934955286},{"_id":"public/categories/Java并发/线程池/index.html","hash":"fcb7a33c6411265c72ca61af6674d7e7e6171337","modified":1595934955286},{"_id":"public/categories/运维/其他/index.html","hash":"beb597e3479ab4adcd52edd6f2d273d5c1313093","modified":1595934955286},{"_id":"public/index.html","hash":"dc93020e1461ae3b72722fe4a1cfee2f8009d8af","modified":1595934955286},{"_id":"public/page/2/index.html","hash":"f385555f4bc74d82260acfa5268ccb162250ea71","modified":1595934955286},{"_id":"public/page/3/index.html","hash":"9f557a95d4000b134e2b0cbf42d7f7114c4a5f18","modified":1595934955286},{"_id":"public/tags/Java基础/index.html","hash":"fff342ac6b5297ded132f3d2eee6e85b5854112e","modified":1595934955286},{"_id":"public/tags/Hexo/index.html","hash":"2e79b54bdaa3754608ef596bc89c4463e8851b67","modified":1595934955286},{"_id":"public/tags/GitHub/index.html","hash":"689a6a667df900b916a4b1bcde54e20f31afd4da","modified":1595934955286},{"_id":"public/tags/Git/index.html","hash":"600a5b12a71b0dd9cc4ec4cbd7f9c5727b65a126","modified":1595934955286},{"_id":"public/tags/Lambda/index.html","hash":"115289a25c843d220f1d346f741db3f41d8d5779","modified":1595934955286},{"_id":"public/tags/dubbo/index.html","hash":"73845ac68dc67b3d900db99c8f2ed50dd0d2d403","modified":1595934955286},{"_id":"public/tags/ddos/index.html","hash":"6dfb24e86a5416608352308539a5b6f92f7e8b42","modified":1595934955286},{"_id":"public/tags/druid/index.html","hash":"beda49c5b5574a9ee360046e2fedb37e747cb3ee","modified":1595934955286},{"_id":"public/tags/JavaMail/index.html","hash":"cca53699681cd6131df6b94749da307181293fc8","modified":1595934955286},{"_id":"public/tags/Redis/index.html","hash":"ab836cb3dfda6e24dcf43e4852907de2f7356ca7","modified":1595934955286},{"_id":"public/tags/Nginx/index.html","hash":"fc78d383a03ad1b8f53890434201cdcdff5f36fb","modified":1595934955286},{"_id":"public/tags/vpn/index.html","hash":"9cf9aa3db493d580eeb53a30684c615139d6e56a","modified":1595934955286},{"_id":"public/tags/Webhook/index.html","hash":"814b39d8d282757a252cb4191ef4d63e82e182ee","modified":1595934955286},{"_id":"public/favicon.png","hash":"6a26261e5d86e062340fcb4bb96764389d04d3ec","modified":1595934955286},{"_id":"public/CNAME","hash":"bcbff434d61bbae2ba5fff5a6d583eebcd48a742","modified":1595934955286},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1595934955286},{"_id":"public/assets/wx_pay.jpg","hash":"100a8beb3bf715471f65465eecc5b506217fba2f","modified":1595934955286},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1595934955286},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1595934955286},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1595934955286},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1595934955286},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1595934955286},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1595934955286},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1595934955286},{"_id":"public/articleImage/2020-06-29/2.png","hash":"0fe7118e0dbe7ab40306189e90b6b9c7c9190a7f","modified":1595934955286},{"_id":"public/articleImage/2020-07-03/2.png","hash":"7aae332feaa655274c396ca52b128e47bb5b4dc7","modified":1595934955286},{"_id":"public/articleImage/2020-07-03/4.png","hash":"155cfe6a669077b47ba0faa3a934843f4c39776f","modified":1595934955286},{"_id":"public/articleImage/2020-07-07/udp.png","hash":"bdcb9bcf8acb27cfe54352dc7880db177dd77323","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/1.jpg","hash":"5fd37f618ed26f5bbc5a2b5b76232023a7657f86","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/2.jpg","hash":"8a585a511da5607b51da55f3d23c5fcf26e22280","modified":1595934955286},{"_id":"public/articleImage/2020-07-24/3.png","hash":"7b098525fe01eec8e8be8fe7281641ca6122490d","modified":1595934955286},{"_id":"public/articleImage/2020-07-09/socket1.jpg","hash":"156542b7179789941f9d4dc7c1cbc3657adde84d","modified":1595934955286},{"_id":"public/articleImage/2020-07-28/1.jpg","hash":"4385747d64c1c33f44d55889cd461124e952e001","modified":1595934955286},{"_id":"public/articleImage/2020-07-03/3.png","hash":"bcbeb5ddb5653dd4f4cfb66851bbce619095b1df","modified":1595934955286},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1595934955286},{"_id":"public/articleImage/2020-06-29/1.png","hash":"1b86b2b6f4ccb86607415693b8e41eb991125191","modified":1595934955286},{"_id":"public/assets/9zai.jpg","hash":"f7e2644145a458f7cfb6a5d98e6684d601e3377d","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/3.jpg","hash":"eb028567e7f76fc94ec9fdfd8cce70410b2657e6","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/4.jpg","hash":"88cb717366595c4227db9eab3da5f1db3d908391","modified":1595934955286},{"_id":"public/articleImage/2020-07-28/2.jpg","hash":"7683da1d61c077c162343ffabf566511a3a14acb","modified":1595934955286},{"_id":"public/articleImage/2020-07-03/3.jpg","hash":"c2a205a8715b74cb65ebc2d2574fb92f40ae04f0","modified":1595934955286},{"_id":"public/articleImage/2020-07-07/3.png","hash":"191a9127234bbee1e9c8849e54520c9de9258db2","modified":1595934955286},{"_id":"public/articleImage/2020-07-07/4.png","hash":"4cbf7773c58ce616c96e7769271c5a3d105b9300","modified":1595934955286},{"_id":"public/articleImage/2020-07-07/hdck1.png","hash":"d4c92a5ebeb09f06c01d39c3bed627ff561e8747","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/5.png","hash":"b54ecf43d0d66789f649b9067f13102c203ad969","modified":1595934955286},{"_id":"public/articleImage/2020-07-09/1.png","hash":"700c2260bdb7a07098f5744ec6950ee0833150ca","modified":1595934955286},{"_id":"public/love.js","hash":"9b8af64e70aeb7b193d30fe79afd1f90ca4a2078","modified":1595934955286},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1595934955286},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1595934955286},{"_id":"public/main.0cf68a.css","hash":"5e20dbd3771f519da6ae597218be9f4dba28a022","modified":1595934955286},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1595934955286},{"_id":"public/assets/letra.jpg","hash":"9c378bbf7c0c90d0e29b1e799bb7371ab1f85e34","modified":1595934955286},{"_id":"public/articleImage/2020-07-24/线程池添加线程规则.png","hash":"0b647c72d15ae03c9ae758fce76d3a2bb8b97a9e","modified":1595934955286},{"_id":"public/articleImage/2020-07-24/线程池构造函数的参数.png","hash":"0447bf3d4382406c5c268ceb3edce866ee4454ac","modified":1595934955286},{"_id":"public/assets/karon.jpg","hash":"41cb22ef5b1f858d0830dcedec9482fd873eaf07","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/3.png","hash":"176ba96337db4656ac45ee4784d863e306e9babb","modified":1595934955286},{"_id":"public/articleImage/2020-07-28/1.png","hash":"1cb22ac59da54cc1126149d31df3c449b0fcb153","modified":1595934955286},{"_id":"public/articleImage/2020-07-03/1.png","hash":"0ec2d4a686189a67ab4d20bd11007e0bd014e77b","modified":1595934955286},{"_id":"public/articleImage/2020-07-08/4.png","hash":"53793e0b34f43cee938644d4d5c181bc83136c02","modified":1595934955286},{"_id":"public/articleImage/2020-07-24/线程池结构.png","hash":"e31263deefeef4525debdf14564eb42f505c9a00","modified":1595934955286},{"_id":"public/articleImage/2020-07-03/osi.gif","hash":"d8ad371232dff39d27a4f47547861191ee7b104e","modified":1595934955286},{"_id":"public/articleImage/2020-07-09/B-tree.png","hash":"da53bf174ddeee44f30d01ee72748c347a986112","modified":1595934955286},{"_id":"public/articleImage/2020-07-07/2.png","hash":"9528a81e8e588fd5cf7de19749e3685f6e008b28","modified":1595934955286},{"_id":"public/articleImage/2020-07-09/B+-Tree.png","hash":"df151366c0aaa4bf88e98fc2b40ecbe81ab309b4","modified":1595934955286}],"Category":[{"name":"编程","_id":"ckd5ugtso0003yctodj8q7w09"},{"name":"Java面试","_id":"ckd5ugtsu0008yctoesfh8w7s"},{"name":"博客","_id":"ckd5ugtt5000iycto9x0t8atv"},{"name":"Java","parent":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtta000mycto4ln83qpo"},{"name":"计算机网络","parent":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtto0016ycto6cnxfjci"},{"name":"效率","parent":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtu1001oyctob6b3b0yn"},{"name":"运维","_id":"ckd5ugtug002byctob0c833cr"},{"name":"其他","_id":"ckd5ugtul002pyctogjft90rb"},{"name":"Spring","parent":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtum002sycto6pecgi8y"},{"name":"Java并发","_id":"ckd5ugtup0035yctohrkt5mvo"},{"name":"安全","parent":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtur003bycto6pu64xoa"},{"name":"Linux","parent":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtus003eyctohtn47c4y"},{"name":"线程池","parent":"ckd5ugtup0035yctohrkt5mvo","_id":"ckd5ugtut003kycto7x3udc7t"},{"name":"其他","parent":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtuu003oycto4lu35794"}],"Data":[],"Page":[{"title":"文章分类","date":"2020-07-01T04:00:00.000Z","type":"categories","comments":0,"_content":"\n","source":"categories/index.md","raw":"---\n\ntitle: 文章分类\ndate: 2020-07-01 12:00:00\ntype: \"categories\"\ncomments: false\n\n---\n\n","updated":"2020-07-01T03:54:14.737Z","path":"categories/index.html","layout":"page","_id":"ckd5ugtsi0001ycto7aqmead4","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Comparable 接口","date":"2017-03-15T08:37:39.000Z","_content":"![](/img/articleImg/compare.png)\n\n>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。\n<!--more-->\n\n### 例1：通过重量排序苹果\n在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。\n\n\tCollections.sort(apples);\n上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。\n让我们开始写苹果类吧。\n{% codeblock %}\npublic class Apple implements Comparable {\n    private String variety;\n    private Color color;\n    private int weight;\n    @Override\n    public int compareTo(Apple other) {\n        if (this.weight < other.weight) {\n            return -1;\n        }\n        if (this.weight == other.weight) {\n            return 0;\n        }\n        return 1;\n    }\n}\n{% endcodeblock %}\n这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。\n\n### 例2：通过多个特征排序苹果\n正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。\n{% codeblock %}\npublic class Apple implements Comparable {\n    private String variety;\n    private Color color;\n    private int weight;\n    @Override\n    public int compareTo(Apple other) {\n        int result = this.variety.compareTo(other.variety);\n        if (result != 0) {\n            return result;\n        }\n        if (result == 0) {\n            result = this.color.compareTo(other.color);\n        }\n        if (result != 0) {\n            return result;\n        }\n        if (result == 0) {\n            result = Integer.compare(this.weight, other.weight);\n        }\n        return result;\n    }\n}\n{% endcodeblock %}\n\n在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。\n{% codeblock %}\n@Override\npublic int compareTo(Apple other) {\n     int result = this.variety.compareTo(other.variety);\n     if (result == 0) {\n          result = this.color.compareTo(other.color);\n     }\n     if (result == 0) {\n          result = Integer.compare(this.weight, other.weight);\n     }\n     return result;\n}\n{% endcodeblock %}\n正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。\n\n### Comparable，hashCode以及Equals\n你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。\n\n### 结论\n在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。\n\n","source":"_posts/Comparable.md","raw":"---\ntitle: Comparable 接口\ndate: 2017-03-15 16:37:39\ntags:\n\t- Java基础\ncategories:\n\t- 编程\n\t- Java\n\n---\n![](/img/articleImg/compare.png)\n\n>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。\n<!--more-->\n\n### 例1：通过重量排序苹果\n在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。\n\n\tCollections.sort(apples);\n上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。\n让我们开始写苹果类吧。\n{% codeblock %}\npublic class Apple implements Comparable {\n    private String variety;\n    private Color color;\n    private int weight;\n    @Override\n    public int compareTo(Apple other) {\n        if (this.weight < other.weight) {\n            return -1;\n        }\n        if (this.weight == other.weight) {\n            return 0;\n        }\n        return 1;\n    }\n}\n{% endcodeblock %}\n这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。\n\n### 例2：通过多个特征排序苹果\n正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。\n{% codeblock %}\npublic class Apple implements Comparable {\n    private String variety;\n    private Color color;\n    private int weight;\n    @Override\n    public int compareTo(Apple other) {\n        int result = this.variety.compareTo(other.variety);\n        if (result != 0) {\n            return result;\n        }\n        if (result == 0) {\n            result = this.color.compareTo(other.color);\n        }\n        if (result != 0) {\n            return result;\n        }\n        if (result == 0) {\n            result = Integer.compare(this.weight, other.weight);\n        }\n        return result;\n    }\n}\n{% endcodeblock %}\n\n在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。\n{% codeblock %}\n@Override\npublic int compareTo(Apple other) {\n     int result = this.variety.compareTo(other.variety);\n     if (result == 0) {\n          result = this.color.compareTo(other.color);\n     }\n     if (result == 0) {\n          result = Integer.compare(this.weight, other.weight);\n     }\n     return result;\n}\n{% endcodeblock %}\n正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。\n\n### Comparable，hashCode以及Equals\n你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。\n\n### 结论\n在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。\n\n","slug":"Comparable","published":1,"updated":"2020-07-02T03:39:58.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtsb0000ycto5vay3tcz","content":"<p><img src=\"/img/articleImg/compare.png\" alt=\"\"></p>\n<blockquote>\n<p>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"例1：通过重量排序苹果\"><a href=\"#例1：通过重量排序苹果\" class=\"headerlink\" title=\"例1：通过重量排序苹果\"></a>例1：通过重量排序苹果</h3><p>在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。</p>\n<pre><code>Collections.sort(apples);</code></pre><p>上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。<br>让我们开始写苹果类吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Apple implements Comparable &#123;</span><br><span class=\"line\">    private String variety;</span><br><span class=\"line\">    private Color color;</span><br><span class=\"line\">    private int weight;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Apple other) &#123;</span><br><span class=\"line\">        if (this.weight &lt; other.weight) &#123;</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (this.weight &#x3D;&#x3D; other.weight) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。</p>\n<h3 id=\"例2：通过多个特征排序苹果\"><a href=\"#例2：通过多个特征排序苹果\" class=\"headerlink\" title=\"例2：通过多个特征排序苹果\"></a>例2：通过多个特征排序苹果</h3><p>正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Apple implements Comparable &#123;</span><br><span class=\"line\">    private String variety;</span><br><span class=\"line\">    private Color color;</span><br><span class=\"line\">    private int weight;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Apple other) &#123;</span><br><span class=\"line\">        int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class=\"line\">        if (result !&#x3D; 0) &#123;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            result &#x3D; this.color.compareTo(other.color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result !&#x3D; 0) &#123;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int compareTo(Apple other) &#123;</span><br><span class=\"line\">     int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class=\"line\">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">          result &#x3D; this.color.compareTo(other.color);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">          result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。</p>\n<h3 id=\"Comparable，hashCode以及Equals\"><a href=\"#Comparable，hashCode以及Equals\" class=\"headerlink\" title=\"Comparable，hashCode以及Equals\"></a>Comparable，hashCode以及Equals</h3><p>你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/img/articleImg/compare.png\" alt=\"\"></p>\n<blockquote>\n<p>compareTo()方法的工作原理是返回一个int值——或正，或负，或为零。它通过调用作为参数的对象来比较对象。负数表示调用的对象比参数“轻”。如果我们用大小来比较苹果，那么上面的调用会返回一个负数，例如-400，因为红苹果比青苹果小。如果两个苹果重量相等，那么调用将返回0。如果红苹果更重，那么compareTo()将返回一个正数，例如68。</p>\n</blockquote>","more":"<h3 id=\"例1：通过重量排序苹果\"><a href=\"#例1：通过重量排序苹果\" class=\"headerlink\" title=\"例1：通过重量排序苹果\"></a>例1：通过重量排序苹果</h3><p>在第一个例子中，我们将通过重量对苹果排序。只需要一行代码。</p>\n<pre><code>Collections.sort(apples);</code></pre><p>上面的代码行可以为我们做到所有的排序工作，只要我们事先定义好如何对苹果进行排序（这就需要多行代码了）。<br>让我们开始写苹果类吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Apple implements Comparable &#123;</span><br><span class=\"line\">    private String variety;</span><br><span class=\"line\">    private Color color;</span><br><span class=\"line\">    private int weight;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Apple other) &#123;</span><br><span class=\"line\">        if (this.weight &lt; other.weight) &#123;</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (this.weight &#x3D;&#x3D; other.weight) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是Apple类的第一个版本。由于我们使用的是compareTo方法，并且正在排序苹果，所以我实现了Comparable接口。在这第一个版本中，我们通过重量比较对象。在我们的compareTo()方法中，我们写一个if条件，说明如果这个苹果的重量小于其他的苹果，那么返回一个负数，为了保持简单，我们假定它为-1。请记住，这意味着这个苹果轻于Apple ‘other’。在第二个if语句中，我们要说明，如果苹果重量相等，那么返回一个0。当然，如果这个苹果既不是更轻，又不是一样重，那就只能比其他苹果更重了。在这种情况下，我们返回一个正数，假定为1。</p>\n<h3 id=\"例2：通过多个特征排序苹果\"><a href=\"#例2：通过多个特征排序苹果\" class=\"headerlink\" title=\"例2：通过多个特征排序苹果\"></a>例2：通过多个特征排序苹果</h3><p>正如我前面提到的，我们还可以使用compareTo()比较多个特征。比方说，我们第一通过品种排序苹果，但如果两个苹果是同一品种，那么我们就按颜色排序。最后，如果这两个特性相同，那么我们将按重量排序。虽然我们可以手动实现这件事，就像我在最后一个例子中做的那样，但是其实可以用一种简洁得多的方式实现。一般来说，最好是重用现有的代码，而不是自己写。我们可以在Integer、String和枚举类中使用compareTo方法来比较值。由于我们没有使用Integer对象，用了int，所以我们不得不使用来自于Integer包装器类的一个静态的helper方法来比较两个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Apple implements Comparable &#123;</span><br><span class=\"line\">    private String variety;</span><br><span class=\"line\">    private Color color;</span><br><span class=\"line\">    private int weight;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compareTo(Apple other) &#123;</span><br><span class=\"line\">        int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class=\"line\">        if (result !&#x3D; 0) &#123;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            result &#x3D; this.color.compareTo(other.color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result !&#x3D; 0) &#123;</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上例中，我们比较了客户指定的苹果的第一特性，它们的品种。如果compareTo()调用的结果为非零，那么我们返回值。否则，我们调用另一个compareTo()直到得到一个非零值，或者直到已经比较完这三个特征。尽管此代码可以工作，但它不是最有效或干净的解决方案。在例3中，我们重构我们的代码，使其更简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int compareTo(Apple other) &#123;</span><br><span class=\"line\">     int result &#x3D; this.variety.compareTo(other.variety);</span><br><span class=\"line\">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">          result &#x3D; this.color.compareTo(other.color);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     if (result &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">          result &#x3D; Integer.compare(this.weight, other.weight);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如你所看到的，这大大减少了代码，并且每一次比较只要一行代码。如果一个compareTo()调用的结果是零，那么我们就转移到下一个相同if语句的比较中。顺便说一句，这是成为Clean Coder的一个很好的例子。通常情况下，你不需要立即写出干净的代码；你可以从一个粗略的想法开始，使其可以工作，然后不断改进，直到你尽可能得让它干净就可以了。</p>\n<h3 id=\"Comparable，hashCode以及Equals\"><a href=\"#Comparable，hashCode以及Equals\" class=\"headerlink\" title=\"Comparable，hashCode以及Equals\"></a>Comparable，hashCode以及Equals</h3><p>你可能会注意到compareTo()看起来有点像hashCode()和equals()方法。但是，它们有一个重要的区别。对于hashCode()和equals()方法，比较个体属性的顺序不影响返回的值，但是，在compareTo()中，通过你比较对象的顺序来定义对象的顺序。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>在结论中我只想强调Comparable接口是多么的重要。它既用于java.util.Arrays，也用于java.util.Collections实用程序类，来排序元素和搜索排序集合中的元素。使用TreeSet和Tree Map，就更简单了——想要它们会自动排序必须实现Comparable接口的元素。</p>"},{"title":"HTTP与HTTPS","date":"2020-07-08T08:37:13.000Z","_content":"\n#### HTTPS\n\n>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。\n>\n>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。\n\n### SSL\n\n>SSL（Security Sockets Layer，安全套接层）\n>为网络通信提供安全及数据完整性的一种安全协议\n>是操作系统对外的API，SSL3.0后更名为TLS\n>采用身份验证和数据加密保证网络通信的安全和数据的完整性\n\n<!--more-->\n\n#### 加密的方式\n\n对称加密：加密和解密都使用同一个密钥\n非对称加密：加密使用的密钥和解密使用的密钥是不相同的\n哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 （例如：MD5）\n数字签名：证明某个消息或者文件是某人发出/认同的/未被修改过的。（将要发送的内容hash后的值一同传输）\n\n#### HTTPS数据传输流程\n\n![HTTP](/articleImage/2020-07-08/4.jpg)\n\n1. 首先客户端通过URL访问服务器建立SSL连接。\n2. 浏览器将支持的加密算法信息发送给服务器。\n3. 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。\n4. 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器。\n5. 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器。\n6. 浏览器解密响应消息，并对消息整形验证，之后进行加密交互数据。\n\n![HTTP](/articleImage/2020-07-08/5.png)\n\n**数字证书内容**\n包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。\n\n**验证证书安全性过程**\n当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。\n然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。\n那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。\n\n#### HTTP与HTTPS的区别\n\n1. HTTPS需要到CA申请证书，HTTP不需要。\n2. HTTPS密文传输，HTTP明文传输。\n3. 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口。\n4. HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全。\n\n#### HTTPS真的安全吗？\n\n浏览器默认填充http:// ，请求需要进行跳转，有被劫持的风险\n*可以使用HSTS优化*","source":"_posts/Http与Https.md","raw":"---\ntitle: HTTP与HTTPS\ndate: 2020-07-08 16:37:13\ncategories:\n\t- Java面试\n\t- 计算机网络\n\n---\n\n#### HTTPS\n\n>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。\n>\n>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。\n\n### SSL\n\n>SSL（Security Sockets Layer，安全套接层）\n>为网络通信提供安全及数据完整性的一种安全协议\n>是操作系统对外的API，SSL3.0后更名为TLS\n>采用身份验证和数据加密保证网络通信的安全和数据的完整性\n\n<!--more-->\n\n#### 加密的方式\n\n对称加密：加密和解密都使用同一个密钥\n非对称加密：加密使用的密钥和解密使用的密钥是不相同的\n哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 （例如：MD5）\n数字签名：证明某个消息或者文件是某人发出/认同的/未被修改过的。（将要发送的内容hash后的值一同传输）\n\n#### HTTPS数据传输流程\n\n![HTTP](/articleImage/2020-07-08/4.jpg)\n\n1. 首先客户端通过URL访问服务器建立SSL连接。\n2. 浏览器将支持的加密算法信息发送给服务器。\n3. 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。\n4. 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器。\n5. 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器。\n6. 浏览器解密响应消息，并对消息整形验证，之后进行加密交互数据。\n\n![HTTP](/articleImage/2020-07-08/5.png)\n\n**数字证书内容**\n包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。\n\n**验证证书安全性过程**\n当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。\n然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。\n那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。\n\n#### HTTP与HTTPS的区别\n\n1. HTTPS需要到CA申请证书，HTTP不需要。\n2. HTTPS密文传输，HTTP明文传输。\n3. 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口。\n4. HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全。\n\n#### HTTPS真的安全吗？\n\n浏览器默认填充http:// ，请求需要进行跳转，有被劫持的风险\n*可以使用HSTS优化*","slug":"Http与Https","published":1,"updated":"2020-07-08T09:32:35.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtsj0002ycto3bgp26gb","content":"<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><blockquote>\n<p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p>\n<p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>\n</blockquote>\n<h3 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h3><blockquote>\n<p>SSL（Security Sockets Layer，安全套接层）<br>为网络通信提供安全及数据完整性的一种安全协议<br>是操作系统对外的API，SSL3.0后更名为TLS<br>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h4 id=\"加密的方式\"><a href=\"#加密的方式\" class=\"headerlink\" title=\"加密的方式\"></a>加密的方式</h4><p>对称加密：加密和解密都使用同一个密钥<br>非对称加密：加密使用的密钥和解密使用的密钥是不相同的<br>哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 （例如：MD5）<br>数字签名：证明某个消息或者文件是某人发出/认同的/未被修改过的。（将要发送的内容hash后的值一同传输）</p>\n<h4 id=\"HTTPS数据传输流程\"><a href=\"#HTTPS数据传输流程\" class=\"headerlink\" title=\"HTTPS数据传输流程\"></a>HTTPS数据传输流程</h4><p><img src=\"/articleImage/2020-07-08/4.jpg\" alt=\"HTTP\"></p>\n<ol>\n<li>首先客户端通过URL访问服务器建立SSL连接。</li>\n<li>浏览器将支持的加密算法信息发送给服务器。</li>\n<li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。</li>\n<li>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器。</li>\n<li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器。</li>\n<li>浏览器解密响应消息，并对消息整形验证，之后进行加密交互数据。</li>\n</ol>\n<p><img src=\"/articleImage/2020-07-08/5.png\" alt=\"HTTP\"></p>\n<p><strong>数字证书内容</strong><br>包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。</p>\n<p><strong>验证证书安全性过程</strong><br>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。<br>然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。<br>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。</p>\n<h4 id=\"HTTP与HTTPS的区别\"><a href=\"#HTTP与HTTPS的区别\" class=\"headerlink\" title=\"HTTP与HTTPS的区别\"></a>HTTP与HTTPS的区别</h4><ol>\n<li>HTTPS需要到CA申请证书，HTTP不需要。</li>\n<li>HTTPS密文传输，HTTP明文传输。</li>\n<li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口。</li>\n<li>HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全。</li>\n</ol>\n<h4 id=\"HTTPS真的安全吗？\"><a href=\"#HTTPS真的安全吗？\" class=\"headerlink\" title=\"HTTPS真的安全吗？\"></a>HTTPS真的安全吗？</h4><p>浏览器默认填充http:// ，请求需要进行跳转，有被劫持的风险<br><em>可以使用HSTS优化</em></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><blockquote>\n<p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p>\n<p>PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。</p>\n</blockquote>\n<h3 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h3><blockquote>\n<p>SSL（Security Sockets Layer，安全套接层）<br>为网络通信提供安全及数据完整性的一种安全协议<br>是操作系统对外的API，SSL3.0后更名为TLS<br>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p>\n</blockquote>","more":"<h4 id=\"加密的方式\"><a href=\"#加密的方式\" class=\"headerlink\" title=\"加密的方式\"></a>加密的方式</h4><p>对称加密：加密和解密都使用同一个密钥<br>非对称加密：加密使用的密钥和解密使用的密钥是不相同的<br>哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 （例如：MD5）<br>数字签名：证明某个消息或者文件是某人发出/认同的/未被修改过的。（将要发送的内容hash后的值一同传输）</p>\n<h4 id=\"HTTPS数据传输流程\"><a href=\"#HTTPS数据传输流程\" class=\"headerlink\" title=\"HTTPS数据传输流程\"></a>HTTPS数据传输流程</h4><p><img src=\"/articleImage/2020-07-08/4.jpg\" alt=\"HTTP\"></p>\n<ol>\n<li>首先客户端通过URL访问服务器建立SSL连接。</li>\n<li>浏览器将支持的加密算法信息发送给服务器。</li>\n<li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。</li>\n<li>浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器。</li>\n<li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器。</li>\n<li>浏览器解密响应消息，并对消息整形验证，之后进行加密交互数据。</li>\n</ol>\n<p><img src=\"/articleImage/2020-07-08/5.png\" alt=\"HTTP\"></p>\n<p><strong>数字证书内容</strong><br>包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。</p>\n<p><strong>验证证书安全性过程</strong><br>当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。<br>然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。<br>那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。</p>\n<h4 id=\"HTTP与HTTPS的区别\"><a href=\"#HTTP与HTTPS的区别\" class=\"headerlink\" title=\"HTTP与HTTPS的区别\"></a>HTTP与HTTPS的区别</h4><ol>\n<li>HTTPS需要到CA申请证书，HTTP不需要。</li>\n<li>HTTPS密文传输，HTTP明文传输。</li>\n<li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口。</li>\n<li>HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全。</li>\n</ol>\n<h4 id=\"HTTPS真的安全吗？\"><a href=\"#HTTPS真的安全吗？\" class=\"headerlink\" title=\"HTTPS真的安全吗？\"></a>HTTPS真的安全吗？</h4><p>浏览器默认填充http:// ，请求需要进行跳转，有被劫持的风险<br><em>可以使用HSTS优化</em></p>"},{"title":"HTTP相关","date":"2020-07-08T07:15:07.000Z","_content":"\n#### Http简介\n\n>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。\n>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。\n>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。\n>\n>HTTP是一个属于应用层的面向对象的协议，HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n\n\n<!--more-->\n\n![HTTP](/articleImage/2020-07-08/1.jpg)\n\n#### Http特点\n\n**1.支持客户/服务器模式**\n\tHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n**2.简单快速**\n\t客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n**3.灵活**\n\tHTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n**4.无连接**\n\t无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n**5.无状态**\n\tHTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n#### Http请求\n\n![HTTP](/articleImage/2020-07-08/2.jpg)\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：\n第一部分：请求行，第一行明了是post请求，以及http1.1版本。\n第二部分：请求头部，第二行至第六行。\n第三部分：空行，第七行的空行。\n第四部分：请求数据，第八行。\n\n![HTTP](/articleImage/2020-07-08/3.png)\n\n#### Http响应\n\n![HTTP](/articleImage/2020-07-08/3.jpg)\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n第二部分：消息报头，用来说明客户端要使用的一些附加信息\n第三部分：空行，消息报头后面的空行是必须的\n第四部分：响应正文，服务器返回给客户端的文本信息。\n\n![HTTP](/articleImage/2020-07-08/4.png)\n\n#### Http状态码\n\n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n\n> **1xx：指示信息--表示请求已接收，继续处理**\n> **2xx：成功--表示请求已被成功接收、理解、接受**\n> **3xx：重定向--要完成请求必须进行更进一步的操作**\n> **4xx：客户端错误--请求有语法错误或请求无法实现**\n> **5xx：服务器端错误--服务器未能实现合法的请求**\n\n**常见状态码：**\n\n- 200 OK                        //客户端请求成功\n- 400 Bad Request               //客户端请求有语法错误，不能被服务器所理解\n- 401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n- 403 Forbidden                 //服务器收到请求，但是拒绝提供服务\n- 404 Not Found                 //请求资源不存在，eg：输入了错误的URL\n- 500 Internal Server Error     //服务器发生不可预期的错误\n- 503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n\n#### HTTP请求方法\n\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n- GET     请求指定的页面信息，并返回实体主体。\n- HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。\n- POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。\n  POST请求可能会导致新的资源的建立和/或已有资源的修改。\n- PUT     从客户端向服务器传送的数据取代指定的文档的内容。\n- DELETE      请求服务器删除指定的页面。\n- CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n- OPTIONS     允许客户端查看服务器的性能。\n- TRACE     回显服务器收到的请求，主要用于测试或诊断。\n\n#### HTTP工作原理\n\nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n以下是 HTTP 请求/响应的步骤：\n\n1、客户端连接到Web服务器\n\t一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。\n2、发送HTTP请求\n\t通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n3、服务器接受请求并返回HTTP响应\n\tWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n4、释放连接TCP连接\n\t若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。\n5、客户端浏览器解析HTML内容\n\t客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n\n1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;\n3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;\n4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n5、释放 TCP连接;\n6、浏览器将该 html 文本并显示内容;\n\n#### GET和POST请求的区别\n\nHttp报文层面：GET请求的信息放在URL，POST请求信息放置在报文体中。\n数据库层面：GET请求符合幂等性和安全性的，POST不符合。\n其他层面：GET可以被缓存（浏览器书签、CDN）、存储，POST依赖Web服务端。\n\n#### Cookie与Session\n\nCookie简介\n\n- 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端\n- 客户端再次请求的时候，会把Cookie回发\n- 服务器接收到后，会解析Cookie生成与客户端相对应的内容\n\nSession简介\n\n- 服务器端的机制，在服务器上保存的信息\n- 解析客户端请求并操作session id，按需保存状态信息\n\nSession的实现方式\n\n- 使用Cookie实现\n- 使用URL回写来实现，带上JSESSIONID参数\n\nCookie和Session的区别\n\n- Cookie数据存放在客户的浏览器上，Session数据放在服务器上\n- Session相对于Cookie更安全\n- 若考虑减轻服务器负担，应当使用Cookie\n\n","source":"_posts/HTTP相关.md","raw":"---\ntitle: HTTP相关\ndate: 2020-07-08 15:15:07\ncategories:\n\t- Java面试\n\t- 计算机网络\n---\n\n#### Http简介\n\n>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。\n>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。\n>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。\n>\n>HTTP是一个属于应用层的面向对象的协议，HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n\n\n<!--more-->\n\n![HTTP](/articleImage/2020-07-08/1.jpg)\n\n#### Http特点\n\n**1.支持客户/服务器模式**\n\tHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n**2.简单快速**\n\t客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n**3.灵活**\n\tHTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n**4.无连接**\n\t无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n**5.无状态**\n\tHTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n#### Http请求\n\n![HTTP](/articleImage/2020-07-08/2.jpg)\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：\n第一部分：请求行，第一行明了是post请求，以及http1.1版本。\n第二部分：请求头部，第二行至第六行。\n第三部分：空行，第七行的空行。\n第四部分：请求数据，第八行。\n\n![HTTP](/articleImage/2020-07-08/3.png)\n\n#### Http响应\n\n![HTTP](/articleImage/2020-07-08/3.jpg)\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n第二部分：消息报头，用来说明客户端要使用的一些附加信息\n第三部分：空行，消息报头后面的空行是必须的\n第四部分：响应正文，服务器返回给客户端的文本信息。\n\n![HTTP](/articleImage/2020-07-08/4.png)\n\n#### Http状态码\n\n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n\n> **1xx：指示信息--表示请求已接收，继续处理**\n> **2xx：成功--表示请求已被成功接收、理解、接受**\n> **3xx：重定向--要完成请求必须进行更进一步的操作**\n> **4xx：客户端错误--请求有语法错误或请求无法实现**\n> **5xx：服务器端错误--服务器未能实现合法的请求**\n\n**常见状态码：**\n\n- 200 OK                        //客户端请求成功\n- 400 Bad Request               //客户端请求有语法错误，不能被服务器所理解\n- 401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n- 403 Forbidden                 //服务器收到请求，但是拒绝提供服务\n- 404 Not Found                 //请求资源不存在，eg：输入了错误的URL\n- 500 Internal Server Error     //服务器发生不可预期的错误\n- 503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n\n#### HTTP请求方法\n\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n- GET     请求指定的页面信息，并返回实体主体。\n- HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。\n- POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。\n  POST请求可能会导致新的资源的建立和/或已有资源的修改。\n- PUT     从客户端向服务器传送的数据取代指定的文档的内容。\n- DELETE      请求服务器删除指定的页面。\n- CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n- OPTIONS     允许客户端查看服务器的性能。\n- TRACE     回显服务器收到的请求，主要用于测试或诊断。\n\n#### HTTP工作原理\n\nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n以下是 HTTP 请求/响应的步骤：\n\n1、客户端连接到Web服务器\n\t一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。\n2、发送HTTP请求\n\t通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n3、服务器接受请求并返回HTTP响应\n\tWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n4、释放连接TCP连接\n\t若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。\n5、客户端浏览器解析HTML内容\n\t客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n\n1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;\n3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;\n4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n5、释放 TCP连接;\n6、浏览器将该 html 文本并显示内容;\n\n#### GET和POST请求的区别\n\nHttp报文层面：GET请求的信息放在URL，POST请求信息放置在报文体中。\n数据库层面：GET请求符合幂等性和安全性的，POST不符合。\n其他层面：GET可以被缓存（浏览器书签、CDN）、存储，POST依赖Web服务端。\n\n#### Cookie与Session\n\nCookie简介\n\n- 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端\n- 客户端再次请求的时候，会把Cookie回发\n- 服务器接收到后，会解析Cookie生成与客户端相对应的内容\n\nSession简介\n\n- 服务器端的机制，在服务器上保存的信息\n- 解析客户端请求并操作session id，按需保存状态信息\n\nSession的实现方式\n\n- 使用Cookie实现\n- 使用URL回写来实现，带上JSESSIONID参数\n\nCookie和Session的区别\n\n- Cookie数据存放在客户的浏览器上，Session数据放在服务器上\n- Session相对于Cookie更安全\n- 若考虑减轻服务器负担，应当使用Cookie\n\n","slug":"HTTP相关","published":1,"updated":"2020-07-08T08:35:03.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtsq0005ycto4asognjq","content":"<h4 id=\"Http简介\"><a href=\"#Http简介\" class=\"headerlink\" title=\"Http简介\"></a>Http简介</h4><blockquote>\n<p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。<br>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。<br>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p>\n<p>HTTP是一个属于应用层的面向对象的协议，HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p><img src=\"/articleImage/2020-07-08/1.jpg\" alt=\"HTTP\"></p>\n<h4 id=\"Http特点\"><a href=\"#Http特点\" class=\"headerlink\" title=\"Http特点\"></a>Http特点</h4><p><strong>1.支持客户/服务器模式</strong><br>    HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>\n<p><strong>2.简单快速</strong><br>    客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n<p><strong>3.灵活</strong><br>    HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>\n<p><strong>4.无连接</strong><br>    无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n<p><strong>5.无状态</strong><br>    HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>\n<h4 id=\"Http请求\"><a href=\"#Http请求\" class=\"headerlink\" title=\"Http请求\"></a>Http请求</h4><p><img src=\"/articleImage/2020-07-08/2.jpg\" alt=\"HTTP\"></p>\n<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<br>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>\n<p><img src=\"/articleImage/2020-07-08/3.png\" alt=\"HTTP\"></p>\n<h4 id=\"Http响应\"><a href=\"#Http响应\" class=\"headerlink\" title=\"Http响应\"></a>Http响应</h4><p><img src=\"/articleImage/2020-07-08/3.jpg\" alt=\"HTTP\"></p>\n<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>第二部分：消息报头，用来说明客户端要使用的一些附加信息<br>第三部分：空行，消息报头后面的空行是必须的<br>第四部分：响应正文，服务器返回给客户端的文本信息。</p>\n<p><img src=\"/articleImage/2020-07-08/4.png\" alt=\"HTTP\"></p>\n<h4 id=\"Http状态码\"><a href=\"#Http状态码\" class=\"headerlink\" title=\"Http状态码\"></a>Http状态码</h4><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>\n<blockquote>\n<p><strong>1xx：指示信息–表示请求已接收，继续处理</strong><br><strong>2xx：成功–表示请求已被成功接收、理解、接受</strong><br><strong>3xx：重定向–要完成请求必须进行更进一步的操作</strong><br><strong>4xx：客户端错误–请求有语法错误或请求无法实现</strong><br><strong>5xx：服务器端错误–服务器未能实现合法的请求</strong></p>\n</blockquote>\n<p><strong>常见状态码：</strong></p>\n<ul>\n<li>200 OK                        //客户端请求成功</li>\n<li>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</li>\n<li>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li>\n<li>403 Forbidden                 //服务器收到请求，但是拒绝提供服务</li>\n<li>404 Not Found                 //请求资源不存在，eg：输入了错误的URL</li>\n<li>500 Internal Server Error     //服务器发生不可预期的错误</li>\n<li>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>\n</ul>\n<h4 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n<ul>\n<li>GET     请求指定的页面信息，并返回实体主体。</li>\n<li>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</li>\n<li>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<br>POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>\n<li>PUT     从客户端向服务器传送的数据取代指定的文档的内容。</li>\n<li>DELETE      请求服务器删除指定的页面。</li>\n<li>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>\n<li>OPTIONS     允许客户端查看服务器的性能。</li>\n<li>TRACE     回显服务器收到的请求，主要用于测试或诊断。</li>\n</ul>\n<h4 id=\"HTTP工作原理\"><a href=\"#HTTP工作原理\" class=\"headerlink\" title=\"HTTP工作原理\"></a>HTTP工作原理</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。<br>以下是 HTTP 请求/响应的步骤：</p>\n<p>1、客户端连接到Web服务器<br>    一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。<br>2、发送HTTP请求<br>    通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。<br>3、服务器接受请求并返回HTTP响应<br>    Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。<br>4、释放连接TCP连接<br>    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。<br>5、客户端浏览器解析HTML内容<br>    客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>\n<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>\n<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<br>6、浏览器将该 html 文本并显示内容;</p>\n<h4 id=\"GET和POST请求的区别\"><a href=\"#GET和POST请求的区别\" class=\"headerlink\" title=\"GET和POST请求的区别\"></a>GET和POST请求的区别</h4><p>Http报文层面：GET请求的信息放在URL，POST请求信息放置在报文体中。<br>数据库层面：GET请求符合幂等性和安全性的，POST不符合。<br>其他层面：GET可以被缓存（浏览器书签、CDN）、存储，POST依赖Web服务端。</p>\n<h4 id=\"Cookie与Session\"><a href=\"#Cookie与Session\" class=\"headerlink\" title=\"Cookie与Session\"></a>Cookie与Session</h4><p>Cookie简介</p>\n<ul>\n<li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li>\n<li>客户端再次请求的时候，会把Cookie回发</li>\n<li>服务器接收到后，会解析Cookie生成与客户端相对应的内容</li>\n</ul>\n<p>Session简介</p>\n<ul>\n<li>服务器端的机制，在服务器上保存的信息</li>\n<li>解析客户端请求并操作session id，按需保存状态信息</li>\n</ul>\n<p>Session的实现方式</p>\n<ul>\n<li>使用Cookie实现</li>\n<li>使用URL回写来实现，带上JSESSIONID参数</li>\n</ul>\n<p>Cookie和Session的区别</p>\n<ul>\n<li>Cookie数据存放在客户的浏览器上，Session数据放在服务器上</li>\n<li>Session相对于Cookie更安全</li>\n<li>若考虑减轻服务器负担，应当使用Cookie</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"Http简介\"><a href=\"#Http简介\" class=\"headerlink\" title=\"Http简介\"></a>Http简介</h4><blockquote>\n<p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。<br>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。<br>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p>\n<p>HTTP是一个属于应用层的面向对象的协议，HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>","more":"<p><img src=\"/articleImage/2020-07-08/1.jpg\" alt=\"HTTP\"></p>\n<h4 id=\"Http特点\"><a href=\"#Http特点\" class=\"headerlink\" title=\"Http特点\"></a>Http特点</h4><p><strong>1.支持客户/服务器模式</strong><br>    HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>\n<p><strong>2.简单快速</strong><br>    客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n<p><strong>3.灵活</strong><br>    HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>\n<p><strong>4.无连接</strong><br>    无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n<p><strong>5.无状态</strong><br>    HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>\n<h4 id=\"Http请求\"><a href=\"#Http请求\" class=\"headerlink\" title=\"Http请求\"></a>Http请求</h4><p><img src=\"/articleImage/2020-07-08/2.jpg\" alt=\"HTTP\"></p>\n<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<br>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>\n<p><img src=\"/articleImage/2020-07-08/3.png\" alt=\"HTTP\"></p>\n<h4 id=\"Http响应\"><a href=\"#Http响应\" class=\"headerlink\" title=\"Http响应\"></a>Http响应</h4><p><img src=\"/articleImage/2020-07-08/3.jpg\" alt=\"HTTP\"></p>\n<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>第二部分：消息报头，用来说明客户端要使用的一些附加信息<br>第三部分：空行，消息报头后面的空行是必须的<br>第四部分：响应正文，服务器返回给客户端的文本信息。</p>\n<p><img src=\"/articleImage/2020-07-08/4.png\" alt=\"HTTP\"></p>\n<h4 id=\"Http状态码\"><a href=\"#Http状态码\" class=\"headerlink\" title=\"Http状态码\"></a>Http状态码</h4><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>\n<blockquote>\n<p><strong>1xx：指示信息–表示请求已接收，继续处理</strong><br><strong>2xx：成功–表示请求已被成功接收、理解、接受</strong><br><strong>3xx：重定向–要完成请求必须进行更进一步的操作</strong><br><strong>4xx：客户端错误–请求有语法错误或请求无法实现</strong><br><strong>5xx：服务器端错误–服务器未能实现合法的请求</strong></p>\n</blockquote>\n<p><strong>常见状态码：</strong></p>\n<ul>\n<li>200 OK                        //客户端请求成功</li>\n<li>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</li>\n<li>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li>\n<li>403 Forbidden                 //服务器收到请求，但是拒绝提供服务</li>\n<li>404 Not Found                 //请求资源不存在，eg：输入了错误的URL</li>\n<li>500 Internal Server Error     //服务器发生不可预期的错误</li>\n<li>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>\n</ul>\n<h4 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n<ul>\n<li>GET     请求指定的页面信息，并返回实体主体。</li>\n<li>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</li>\n<li>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<br>POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>\n<li>PUT     从客户端向服务器传送的数据取代指定的文档的内容。</li>\n<li>DELETE      请求服务器删除指定的页面。</li>\n<li>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>\n<li>OPTIONS     允许客户端查看服务器的性能。</li>\n<li>TRACE     回显服务器收到的请求，主要用于测试或诊断。</li>\n</ul>\n<h4 id=\"HTTP工作原理\"><a href=\"#HTTP工作原理\" class=\"headerlink\" title=\"HTTP工作原理\"></a>HTTP工作原理</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。<br>以下是 HTTP 请求/响应的步骤：</p>\n<p>1、客户端连接到Web服务器<br>    一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。<br>2、发送HTTP请求<br>    通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。<br>3、服务器接受请求并返回HTTP响应<br>    Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。<br>4、释放连接TCP连接<br>    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。<br>5、客户端浏览器解析HTML内容<br>    客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>\n<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>\n<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<br>6、浏览器将该 html 文本并显示内容;</p>\n<h4 id=\"GET和POST请求的区别\"><a href=\"#GET和POST请求的区别\" class=\"headerlink\" title=\"GET和POST请求的区别\"></a>GET和POST请求的区别</h4><p>Http报文层面：GET请求的信息放在URL，POST请求信息放置在报文体中。<br>数据库层面：GET请求符合幂等性和安全性的，POST不符合。<br>其他层面：GET可以被缓存（浏览器书签、CDN）、存储，POST依赖Web服务端。</p>\n<h4 id=\"Cookie与Session\"><a href=\"#Cookie与Session\" class=\"headerlink\" title=\"Cookie与Session\"></a>Cookie与Session</h4><p>Cookie简介</p>\n<ul>\n<li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li>\n<li>客户端再次请求的时候，会把Cookie回发</li>\n<li>服务器接收到后，会解析Cookie生成与客户端相对应的内容</li>\n</ul>\n<p>Session简介</p>\n<ul>\n<li>服务器端的机制，在服务器上保存的信息</li>\n<li>解析客户端请求并操作session id，按需保存状态信息</li>\n</ul>\n<p>Session的实现方式</p>\n<ul>\n<li>使用Cookie实现</li>\n<li>使用URL回写来实现，带上JSESSIONID参数</li>\n</ul>\n<p>Cookie和Session的区别</p>\n<ul>\n<li>Cookie数据存放在客户的浏览器上，Session数据放在服务器上</li>\n<li>Session相对于Cookie更安全</li>\n<li>若考虑减轻服务器负担，应当使用Cookie</li>\n</ul>"},{"title":"Hexo博客多电脑同步（hexo+GitHub）","date":"2020-06-29T01:58:13.000Z","_content":"\n### 1.如何让公司电脑A、家里电脑B都能同步编辑博客。\n\n**上传博客工程到Github**\n\n 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:\n\n```js\n#git初始化\ngit init\n#添加仓库地址\ngit remote add origin https://github.com/用户名/你的GitHub用户名.github.io.git \n#新建分支并切换到新建的分支\ngit checkout -b 分支名 \n#添加所有本地文件到git\ngit add . \n#git提交\ngit commit -m \"这里填写你本次提交的备注，内容随意\" \n#文件推送到hexo分支\ngit push origin 分支名 \n```\n\n**从另一台电脑下载博客工程**\n\nB电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。\n\n然后输入以下命令<!--more-->\n\n```js\ngit clone -b 分支名 https://github.com/用户名/你的GitHub用户\n\n```\n\n克隆下载完成后，进入到你项目的文件夹，重新配置你的hexo环境，命令如下：\n\n```js\n#安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置\nsudo npm install -g hexo-cli \n#安装依赖库\nsudo npm install \n#安装git部署相关配置\nsudo npm install hexo-deployer-git \n```\n\n之后就可以创建撰写新的文章，并使用sudo hexo g -d命令创建并部署您的网站。\n\n**撰写完后如何再次同步**\n\n```js\ngit add .\ngit commit -m \"提交的备注，内容随意\"\ngit push origin 分支名\n#没错，这个样就够了~你B电脑上的数据也已经同步到Github上面了。\n#那第二天到A电脑跟前，只需要执行以下命令就行\n\ngit pull\n#这样，你的数据就全部同步到A电脑了，以后在部署完后，再次执行\n\ngit add .\ngit commit -m \"提交的备注，内容随意\"\ngit push origin 分支名\n```\n\n------\n\n**常见问题**\n\n（1）修改主题后，主题文件无法推送至GitHub\n\n可能是该子文件夹下有.git文件夹导致无法上传，\n\n```markdown\n#删除子文件夹下.git后，依然无法提交子文件夹下的文件。\n1. git rm --cached themes/yilia\n2. git add .\n3. git commit -m \"xxx\"\n4. git push origin master\n```\n\n（2）文章多标签格式：\n\n```js\ntags: \n- Hexo\n- GitHub\n- Git\n```\n\n（3）文章缩略标识\n\n```\n<!--more-->\n```\n\n\n\n（4）添加评论GitTalk\n\n**创建 gitalk.ejs**\n\n在你的 hexo 目录 `/theme/yilia/layout/_partial/post/` 目录下创建 `gitalk.ejs` 并写入如下内容：\n\n```\n<div id=\"gitalk-container\"></div>\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js\"></script>\n\n<script>\nvar gitalk = new Gitalk({\n  clientID: '<%=theme.gitalk.clientID%>',\n  clientSecret: '<%=theme.gitalk.clientSecret%>',\n  repo: '<%=theme.gitalk.repo%>',\n  owner: '<%=theme.gitalk.owner%>',\n  admin: ['<%=theme.gitalk.admin%>'],\n  id: md5(window.location.pathname),\n  distractionFreeMode: <%=theme.gitalk.distractionFreeMode%>\n})\n\ngitalk.render('gitalk-container')\n</script>\n```\n\n**修改 article.ejs**\n\n在你的 hexo 目录 `/theme/yilia/layout/_partial/article.ejs` 文件中最后一行 `“<% } %>”` 之前添加如下内容：\n\n```\n<% if(theme.gitalk.enable && theme.gitalk.distractionFreeMode){ %>\n      <%- partial('post/gitalk', {\n      key: post.slug,\n      title: post.title,\n      url: config.url+url_for(post.path)\n    }) %>\n  <% } %>\n```\n\n**添加配置文件**\n\n在 yilia 的配置文件`_config.yml` 中 gitment 配置下面添加如下配置文件\n\n```\n#6. Gitalk\ngitalk: \n  enable: true    #用来做启用判断可以不用\n  clientID: your clientID    #Github上生成的 Settings Developer/settings/OAuth Apps\n  clientSecret: your clientSecret   #同上\n  repo: git_comment    #评论所在的github project\n  owner: findtheonlyway    #github用户名\n  admin: erbiduo    #可以初始化评论issue的github账户名称\n  distractionFreeMode: true\n```\n\n（5）微信分享二维码失效\n\n打开`themes\\yilia\\layout\\_partial\\post\\share.ejs`文件\n\n把第49行中的 `//pan.baidu.com/share/qrcode?url=`修改为：\n\n```js\n//api.qrserver.com/v1/create-qr-code/?size=150x150&data=\n```\n\n（6）添加文章分类\n\n**1、添加categories链接**\n打开yilia/_config.yml文件，menu处做出以下修改：\n\n```js\nmenu:\n  主页: /\n  分类: /categories\n  归档: /archives\n```\n\n**2、分类页面的构建**\n新建categories页面\n\n```js\nhexo new page categories\n#该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。\n```\n\n修改categories/index.md为：\n\n```\n---\ntitle: 文章分类\ndate: 2018-06-11 10:13:21\ntype: \"categories\"\ncomments: false\n---\n```\n\n\n生成html\n\n```\nhexo g\nhexo s\n```\n\n访问 http://localhost:4000/categories/ ，即可看到categories页面，只不过现在的页面只有标题。\n\n**3、修改 yilia 主题**\n修改*yilia\\source\\main.0cf68a.css*，将下面的内容添加进去：\n\n```js\ncategory-all-page {\n    margin: 30px 40px 30px 40px;\n    position: relative;\n    min-height: 70vh;\n  }\n  .category-all-page h2 {\n    margin: 20px 0;\n  }\n  .category-all-page .category-all-title {\n    text-align: center;\n  }\n  .category-all-page .category-all {\n    margin-top: 20px;\n  }\n  .category-all-page .category-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n  .category-all-page .category-list-item-list-item {\n    margin: 10px 15px;\n  }\n  .category-all-page .category-list-item-list-count {\n    color: $grey;\n  }\n  .category-all-page .category-list-item-list-count:before {\n    display: inline;\n    content: \" (\";\n  }\n  .category-all-page .category-list-item-list-count:after {\n    display: inline;\n    content: \") \";\n  }\n  .category-all-page .category-list-item {\n    margin: 10px 10px;\n  }\n  .category-all-page .category-list-count {\n    color: $grey;\n  }\n  .category-all-page .category-list-count:before {\n    display: inline;\n    content: \" (\";\n  }\n  .category-all-page .category-list-count:after {\n    display: inline;\n    content: \") \";\n  }\n  .category-all-page .category-list-child {\n    padding-left: 10px;\n  }\n```\n\n**4、多层分类**\n新建*yilia/layout/categories.ejs*，输入：\n\n```js\n<article class=\"article article-type-post show\">\n  <header class=\"article-header\" style=\"border-bottom: 1px solid #ccc\">\n  <h1 class=\"article-title\" itemprop=\"name\">\n    <%= page.title %>\n  </h1>\n  </header>\n\n  <% if (site.categories.length){ %>\n  <div class=\"category-all-page\">\n    <h2>共计&nbsp;<%= site.categories.length %>&nbsp;个分类</h2>\n    <%- list_categories(site.categories, {\n      show_count: true,\n      class: 'category-list-item',\n      style: 'list',\n      depth: 2,\n      separator: ''\n    }) %>\n  </div>\n  <% } %>\n</article>\n```\n\n找到 *layout/_partial/article.ejs* \n\n```\n#然后找到<div class=\"article-entry\" itemprop=\"articleBody\">\n#与<% if ((theme.reward_type === 2 || (theme.reward_type === 1 && post.reward)) && !index){ %>之间的内容全部替换为：\n\n<% if (page.type === \"tags\") { %>\n<div class=\"tag-cloud\">\n\t<div class=\"tag-cloud-title\">\n\t<%- _p('counter.tag_cloud', site.tags.length) %>\n\t</div>\n\t<div class=\"tag-cloud-tags\">\n\t<%- tagcloud({\n\t\tmin_font: 12,\n\t\tmax_font: 30,\n\t\tamount: 200,\n\t\tcolor: true,\n\t\tstart_color: '#ccc',\n\t\tend_color: '#111'\n\t\t}) %>\n\t</div>\n</div>\n<% } \nelse if (page.type === 'categories') { \n%> <div class=\"category-all-page\">\n\t<div class=\"category-all-title\">\n\t<%- _p('', site.categories.length) %>\n\t</div>\n\t<div class=\"category-all\">\n\t<%- list_categories() %>\n\t</div>\n</div>\n<% } else { %>\n\t<% if (post.excerpt && index){ %>\t\t<%- post.excerpt %>\n\t<% } else { %>\n\t\t<%- post.content %>\n\t<% } %>\n<% } %>\n```\n\n**5、修改自己的文章**\n\n```js\ntitle: Hexo博客多电脑同步（hexo+GitHub）\ndate: 2020-06-29 09:58:13\ntags: \n- Hexo\n- GitHub\n- Git\ncategories: \n- hexo\n```\n\n（7）分页显示错误\n\n首先找到*blog\\themes\\yilia\\layout_partial\\archive.ejs*\n\n修改两处，分别在8，9行与37，38行\n\n```\n  <% page.posts.each(function(post){ %>\n    <%- partial('article', {post: post, index: true}) %>\n  <% }) %>\n  <% if (page.total > 1){ %>\n    <nav id=\"page-nav\">\n      <%- paginator({\n        prev_text: '上一页',\n        next_text: '下一页'\n      }) %>\n    </nav>\n  <% } %>\n```\n\n然后找到*blog\\themes\\yilia\\layout_partial\\script.ejs*\nctrl + f 搜索 next &raquo\n\n![script.ejs](/articleImage/2020-06-29/1.png)\n\n找到图片中框选的两处， 分别改为上一页与下一页\n\n![script.ejs](/articleImage/2020-06-29/2.png)\n\n\n\n\n[参考链接1](https://cloud.tencent.com/developer/article/1046404)\n\n[参考链接2](https://blog.csdn.net/dta0502/article/details/89607895)","source":"_posts/Hexo博客多电脑同步.md","raw":"---\n\ntitle: Hexo博客多电脑同步（hexo+GitHub）\ndate: 2020-06-29 09:58:13\ntags: \n\t- Hexo\n\t- GitHub\n\t- Git\ncategories: \n\t- 博客\n---\n\n### 1.如何让公司电脑A、家里电脑B都能同步编辑博客。\n\n**上传博客工程到Github**\n\n 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:\n\n```js\n#git初始化\ngit init\n#添加仓库地址\ngit remote add origin https://github.com/用户名/你的GitHub用户名.github.io.git \n#新建分支并切换到新建的分支\ngit checkout -b 分支名 \n#添加所有本地文件到git\ngit add . \n#git提交\ngit commit -m \"这里填写你本次提交的备注，内容随意\" \n#文件推送到hexo分支\ngit push origin 分支名 \n```\n\n**从另一台电脑下载博客工程**\n\nB电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。\n\n然后输入以下命令<!--more-->\n\n```js\ngit clone -b 分支名 https://github.com/用户名/你的GitHub用户\n\n```\n\n克隆下载完成后，进入到你项目的文件夹，重新配置你的hexo环境，命令如下：\n\n```js\n#安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置\nsudo npm install -g hexo-cli \n#安装依赖库\nsudo npm install \n#安装git部署相关配置\nsudo npm install hexo-deployer-git \n```\n\n之后就可以创建撰写新的文章，并使用sudo hexo g -d命令创建并部署您的网站。\n\n**撰写完后如何再次同步**\n\n```js\ngit add .\ngit commit -m \"提交的备注，内容随意\"\ngit push origin 分支名\n#没错，这个样就够了~你B电脑上的数据也已经同步到Github上面了。\n#那第二天到A电脑跟前，只需要执行以下命令就行\n\ngit pull\n#这样，你的数据就全部同步到A电脑了，以后在部署完后，再次执行\n\ngit add .\ngit commit -m \"提交的备注，内容随意\"\ngit push origin 分支名\n```\n\n------\n\n**常见问题**\n\n（1）修改主题后，主题文件无法推送至GitHub\n\n可能是该子文件夹下有.git文件夹导致无法上传，\n\n```markdown\n#删除子文件夹下.git后，依然无法提交子文件夹下的文件。\n1. git rm --cached themes/yilia\n2. git add .\n3. git commit -m \"xxx\"\n4. git push origin master\n```\n\n（2）文章多标签格式：\n\n```js\ntags: \n- Hexo\n- GitHub\n- Git\n```\n\n（3）文章缩略标识\n\n```\n<!--more-->\n```\n\n\n\n（4）添加评论GitTalk\n\n**创建 gitalk.ejs**\n\n在你的 hexo 目录 `/theme/yilia/layout/_partial/post/` 目录下创建 `gitalk.ejs` 并写入如下内容：\n\n```\n<div id=\"gitalk-container\"></div>\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css\">\n<script src=\"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js\"></script>\n<script src=\"https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js\"></script>\n\n<script>\nvar gitalk = new Gitalk({\n  clientID: '<%=theme.gitalk.clientID%>',\n  clientSecret: '<%=theme.gitalk.clientSecret%>',\n  repo: '<%=theme.gitalk.repo%>',\n  owner: '<%=theme.gitalk.owner%>',\n  admin: ['<%=theme.gitalk.admin%>'],\n  id: md5(window.location.pathname),\n  distractionFreeMode: <%=theme.gitalk.distractionFreeMode%>\n})\n\ngitalk.render('gitalk-container')\n</script>\n```\n\n**修改 article.ejs**\n\n在你的 hexo 目录 `/theme/yilia/layout/_partial/article.ejs` 文件中最后一行 `“<% } %>”` 之前添加如下内容：\n\n```\n<% if(theme.gitalk.enable && theme.gitalk.distractionFreeMode){ %>\n      <%- partial('post/gitalk', {\n      key: post.slug,\n      title: post.title,\n      url: config.url+url_for(post.path)\n    }) %>\n  <% } %>\n```\n\n**添加配置文件**\n\n在 yilia 的配置文件`_config.yml` 中 gitment 配置下面添加如下配置文件\n\n```\n#6. Gitalk\ngitalk: \n  enable: true    #用来做启用判断可以不用\n  clientID: your clientID    #Github上生成的 Settings Developer/settings/OAuth Apps\n  clientSecret: your clientSecret   #同上\n  repo: git_comment    #评论所在的github project\n  owner: findtheonlyway    #github用户名\n  admin: erbiduo    #可以初始化评论issue的github账户名称\n  distractionFreeMode: true\n```\n\n（5）微信分享二维码失效\n\n打开`themes\\yilia\\layout\\_partial\\post\\share.ejs`文件\n\n把第49行中的 `//pan.baidu.com/share/qrcode?url=`修改为：\n\n```js\n//api.qrserver.com/v1/create-qr-code/?size=150x150&data=\n```\n\n（6）添加文章分类\n\n**1、添加categories链接**\n打开yilia/_config.yml文件，menu处做出以下修改：\n\n```js\nmenu:\n  主页: /\n  分类: /categories\n  归档: /archives\n```\n\n**2、分类页面的构建**\n新建categories页面\n\n```js\nhexo new page categories\n#该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。\n```\n\n修改categories/index.md为：\n\n```\n---\ntitle: 文章分类\ndate: 2018-06-11 10:13:21\ntype: \"categories\"\ncomments: false\n---\n```\n\n\n生成html\n\n```\nhexo g\nhexo s\n```\n\n访问 http://localhost:4000/categories/ ，即可看到categories页面，只不过现在的页面只有标题。\n\n**3、修改 yilia 主题**\n修改*yilia\\source\\main.0cf68a.css*，将下面的内容添加进去：\n\n```js\ncategory-all-page {\n    margin: 30px 40px 30px 40px;\n    position: relative;\n    min-height: 70vh;\n  }\n  .category-all-page h2 {\n    margin: 20px 0;\n  }\n  .category-all-page .category-all-title {\n    text-align: center;\n  }\n  .category-all-page .category-all {\n    margin-top: 20px;\n  }\n  .category-all-page .category-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n  .category-all-page .category-list-item-list-item {\n    margin: 10px 15px;\n  }\n  .category-all-page .category-list-item-list-count {\n    color: $grey;\n  }\n  .category-all-page .category-list-item-list-count:before {\n    display: inline;\n    content: \" (\";\n  }\n  .category-all-page .category-list-item-list-count:after {\n    display: inline;\n    content: \") \";\n  }\n  .category-all-page .category-list-item {\n    margin: 10px 10px;\n  }\n  .category-all-page .category-list-count {\n    color: $grey;\n  }\n  .category-all-page .category-list-count:before {\n    display: inline;\n    content: \" (\";\n  }\n  .category-all-page .category-list-count:after {\n    display: inline;\n    content: \") \";\n  }\n  .category-all-page .category-list-child {\n    padding-left: 10px;\n  }\n```\n\n**4、多层分类**\n新建*yilia/layout/categories.ejs*，输入：\n\n```js\n<article class=\"article article-type-post show\">\n  <header class=\"article-header\" style=\"border-bottom: 1px solid #ccc\">\n  <h1 class=\"article-title\" itemprop=\"name\">\n    <%= page.title %>\n  </h1>\n  </header>\n\n  <% if (site.categories.length){ %>\n  <div class=\"category-all-page\">\n    <h2>共计&nbsp;<%= site.categories.length %>&nbsp;个分类</h2>\n    <%- list_categories(site.categories, {\n      show_count: true,\n      class: 'category-list-item',\n      style: 'list',\n      depth: 2,\n      separator: ''\n    }) %>\n  </div>\n  <% } %>\n</article>\n```\n\n找到 *layout/_partial/article.ejs* \n\n```\n#然后找到<div class=\"article-entry\" itemprop=\"articleBody\">\n#与<% if ((theme.reward_type === 2 || (theme.reward_type === 1 && post.reward)) && !index){ %>之间的内容全部替换为：\n\n<% if (page.type === \"tags\") { %>\n<div class=\"tag-cloud\">\n\t<div class=\"tag-cloud-title\">\n\t<%- _p('counter.tag_cloud', site.tags.length) %>\n\t</div>\n\t<div class=\"tag-cloud-tags\">\n\t<%- tagcloud({\n\t\tmin_font: 12,\n\t\tmax_font: 30,\n\t\tamount: 200,\n\t\tcolor: true,\n\t\tstart_color: '#ccc',\n\t\tend_color: '#111'\n\t\t}) %>\n\t</div>\n</div>\n<% } \nelse if (page.type === 'categories') { \n%> <div class=\"category-all-page\">\n\t<div class=\"category-all-title\">\n\t<%- _p('', site.categories.length) %>\n\t</div>\n\t<div class=\"category-all\">\n\t<%- list_categories() %>\n\t</div>\n</div>\n<% } else { %>\n\t<% if (post.excerpt && index){ %>\t\t<%- post.excerpt %>\n\t<% } else { %>\n\t\t<%- post.content %>\n\t<% } %>\n<% } %>\n```\n\n**5、修改自己的文章**\n\n```js\ntitle: Hexo博客多电脑同步（hexo+GitHub）\ndate: 2020-06-29 09:58:13\ntags: \n- Hexo\n- GitHub\n- Git\ncategories: \n- hexo\n```\n\n（7）分页显示错误\n\n首先找到*blog\\themes\\yilia\\layout_partial\\archive.ejs*\n\n修改两处，分别在8，9行与37，38行\n\n```\n  <% page.posts.each(function(post){ %>\n    <%- partial('article', {post: post, index: true}) %>\n  <% }) %>\n  <% if (page.total > 1){ %>\n    <nav id=\"page-nav\">\n      <%- paginator({\n        prev_text: '上一页',\n        next_text: '下一页'\n      }) %>\n    </nav>\n  <% } %>\n```\n\n然后找到*blog\\themes\\yilia\\layout_partial\\script.ejs*\nctrl + f 搜索 next &raquo\n\n![script.ejs](/articleImage/2020-06-29/1.png)\n\n找到图片中框选的两处， 分别改为上一页与下一页\n\n![script.ejs](/articleImage/2020-06-29/2.png)\n\n\n\n\n[参考链接1](https://cloud.tencent.com/developer/article/1046404)\n\n[参考链接2](https://blog.csdn.net/dta0502/article/details/89607895)","slug":"Hexo博客多电脑同步","published":1,"updated":"2020-07-02T09:54:51.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtss0006ycto1o4jghbi","content":"<h3 id=\"1-如何让公司电脑A、家里电脑B都能同步编辑博客。\"><a href=\"#1-如何让公司电脑A、家里电脑B都能同步编辑博客。\" class=\"headerlink\" title=\"1.如何让公司电脑A、家里电脑B都能同步编辑博客。\"></a>1.如何让公司电脑A、家里电脑B都能同步编辑博客。</h3><p><strong>上传博客工程到Github</strong></p>\n<p> 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#git初始化</span><br><span class=\"line\">git init</span><br><span class=\"line\">#添加仓库地址</span><br><span class=\"line\">git remote add origin https:<span class=\"comment\">//github.com/用户名/你的GitHub用户名.github.io.git </span></span><br><span class=\"line\">#新建分支并切换到新建的分支</span><br><span class=\"line\">git checkout -b 分支名 </span><br><span class=\"line\">#添加所有本地文件到git</span><br><span class=\"line\">git add . </span><br><span class=\"line\">#git提交</span><br><span class=\"line\">git commit -m <span class=\"string\">\"这里填写你本次提交的备注，内容随意\"</span> </span><br><span class=\"line\">#文件推送到hexo分支</span><br><span class=\"line\">git push origin 分支名</span><br></pre></td></tr></table></figure>\n\n<p><strong>从另一台电脑下载博客工程</strong></p>\n<p>B电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。</p>\n<p>然后输入以下命令<a id=\"more\"></a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b 分支名 https:<span class=\"comment\">//github.com/用户名/你的GitHub用户</span></span><br></pre></td></tr></table></figure>\n\n<p>克隆下载完成后，进入到你项目的文件夹，重新配置你的hexo环境，命令如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置</span><br><span class=\"line\">sudo npm install -g hexo-cli </span><br><span class=\"line\">#安装依赖库</span><br><span class=\"line\">sudo npm install </span><br><span class=\"line\">#安装git部署相关配置</span><br><span class=\"line\">sudo npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以创建撰写新的文章，并使用sudo hexo g -d命令创建并部署您的网站。</p>\n<p><strong>撰写完后如何再次同步</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"提交的备注，内容随意\"</span></span><br><span class=\"line\">git push origin 分支名</span><br><span class=\"line\">#没错，这个样就够了~你B电脑上的数据也已经同步到Github上面了。</span><br><span class=\"line\">#那第二天到A电脑跟前，只需要执行以下命令就行</span><br><span class=\"line\"></span><br><span class=\"line\">git pull</span><br><span class=\"line\">#这样，你的数据就全部同步到A电脑了，以后在部署完后，再次执行</span><br><span class=\"line\"></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"提交的备注，内容随意\"</span></span><br><span class=\"line\">git push origin 分支名</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>常见问题</strong></p>\n<p>（1）修改主题后，主题文件无法推送至GitHub</p>\n<p>可能是该子文件夹下有.git文件夹导致无法上传，</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">#删除子文件夹下.git后，依然无法提交子文件夹下的文件。</span></span><br><span class=\"line\"><span class=\"bullet\">1. </span>git rm --cached themes/yilia</span><br><span class=\"line\"><span class=\"bullet\">2. </span>git add .</span><br><span class=\"line\"><span class=\"bullet\">3. </span>git commit -m \"xxx\"</span><br><span class=\"line\"><span class=\"bullet\">4. </span>git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>（2）文章多标签格式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: </span><br><span class=\"line\">- Hexo</span><br><span class=\"line\">- GitHub</span><br><span class=\"line\">- Git</span><br></pre></td></tr></table></figure>\n\n<p>（3）文章缩略标识</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>（4）添加评论GitTalk</p>\n<p><strong>创建 gitalk.ejs</strong></p>\n<p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/post/</code> 目录下创建 <code>gitalk.ejs</code> 并写入如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;blueimp-md5&#x2F;2.10.0&#x2F;js&#x2F;md5.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class=\"line\">  clientID: &#39;&lt;%&#x3D;theme.gitalk.clientID%&gt;&#39;,</span><br><span class=\"line\">  clientSecret: &#39;&lt;%&#x3D;theme.gitalk.clientSecret%&gt;&#39;,</span><br><span class=\"line\">  repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class=\"line\">  owner: &#39;&lt;%&#x3D;theme.gitalk.owner%&gt;&#39;,</span><br><span class=\"line\">  admin: [&#39;&lt;%&#x3D;theme.gitalk.admin%&gt;&#39;],</span><br><span class=\"line\">  id: md5(window.location.pathname),</span><br><span class=\"line\">  distractionFreeMode: &lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>修改 article.ejs</strong></p>\n<p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/article.ejs</code> 文件中最后一行 <code>“&lt;% } %&gt;”</code> 之前添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if(theme.gitalk.enable &amp;&amp; theme.gitalk.distractionFreeMode)&#123; %&gt;</span><br><span class=\"line\">      &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class=\"line\">      key: post.slug,</span><br><span class=\"line\">      title: post.title,</span><br><span class=\"line\">      url: config.url+url_for(post.path)</span><br><span class=\"line\">    &#125;) %&gt;</span><br><span class=\"line\">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>添加配置文件</strong></p>\n<p>在 yilia 的配置文件<code>_config.yml</code> 中 gitment 配置下面添加如下配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#6. Gitalk</span><br><span class=\"line\">gitalk: </span><br><span class=\"line\">  enable: true    #用来做启用判断可以不用</span><br><span class=\"line\">  clientID: your clientID    #Github上生成的 Settings Developer&#x2F;settings&#x2F;OAuth Apps</span><br><span class=\"line\">  clientSecret: your clientSecret   #同上</span><br><span class=\"line\">  repo: git_comment    #评论所在的github project</span><br><span class=\"line\">  owner: findtheonlyway    #github用户名</span><br><span class=\"line\">  admin: erbiduo    #可以初始化评论issue的github账户名称</span><br><span class=\"line\">  distractionFreeMode: true</span><br></pre></td></tr></table></figure>\n\n<p>（5）微信分享二维码失效</p>\n<p>打开<code>themes\\yilia\\layout\\_partial\\post\\share.ejs</code>文件</p>\n<p>把第49行中的 <code>//pan.baidu.com/share/qrcode?url=</code>修改为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=</span></span><br></pre></td></tr></table></figure>\n\n<p>（6）添加文章分类</p>\n<p><strong>1、添加categories链接</strong><br>打开yilia/_config.yml文件，menu处做出以下修改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  主页: <span class=\"regexp\">/</span></span><br><span class=\"line\"><span class=\"regexp\">  分类: /</span>categories</span><br><span class=\"line\">  归档: <span class=\"regexp\">/archives</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>2、分类页面的构建</strong><br>新建categories页面</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> page categories</span><br><span class=\"line\">#该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。</span><br></pre></td></tr></table></figure>\n\n<p>修改categories/index.md为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 文章分类</span><br><span class=\"line\">date: 2018-06-11 10:13:21</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n\n<p>生成html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:4000/categories/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/categories/</a> ，即可看到categories页面，只不过现在的页面只有标题。</p>\n<p><strong>3、修改 yilia 主题</strong><br>修改<em>yilia\\source\\main.0cf68a.css</em>，将下面的内容添加进去：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">category-all-page &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">30</span>px <span class=\"number\">40</span>px <span class=\"number\">30</span>px <span class=\"number\">40</span>px;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    min-height: <span class=\"number\">70</span>vh;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page h2 &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">20</span>px <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-all-title &#123;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-all &#123;</span><br><span class=\"line\">    margin-top: <span class=\"number\">20</span>px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">0</span>;</span><br><span class=\"line\">    padding: <span class=\"number\">0</span>;</span><br><span class=\"line\">    list-style: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-item &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">10</span>px <span class=\"number\">15</span>px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-count &#123;</span><br><span class=\"line\">    color: $grey;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-count:before &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\" (\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-count:after &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\") \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">10</span>px <span class=\"number\">10</span>px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-count &#123;</span><br><span class=\"line\">    color: $grey;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-count:before &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\" (\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-count:after &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\") \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-child &#123;</span><br><span class=\"line\">    padding-left: <span class=\"number\">10</span>px;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4、多层分类</strong><br>新建<em>yilia/layout/categories.ejs</em>，输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;article <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"article article-type-post show\"</span>&gt;</span><br><span class=\"line\">  &lt;header <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"article-header\"</span> style=<span class=\"string\">\"border-bottom: 1px solid #ccc\"</span>&gt;</span><br><span class=\"line\">  &lt;h1 <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"article-title\"</span> itemprop=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\">    &lt;%= page.title %&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>header&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;% <span class=\"keyword\">if</span> (site.categories.length)&#123; %&gt;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"category-all-page\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;%- list_categories(site.categories, &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      show_count: true,</span></span><br><span class=\"line\"><span class=\"regexp\">      class: 'category-list-item',</span></span><br><span class=\"line\"><span class=\"regexp\">      style: 'list',</span></span><br><span class=\"line\"><span class=\"regexp\">      depth: 2,</span></span><br><span class=\"line\"><span class=\"regexp\">      separator: ''</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;) %&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">  &lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/article&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>找到 <em>layout/_partial/article.ejs</em> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#然后找到&lt;div class&#x3D;&quot;article-entry&quot; itemprop&#x3D;&quot;articleBody&quot;&gt;</span><br><span class=\"line\">#与&lt;% if ((theme.reward_type &#x3D;&#x3D;&#x3D; 2 || (theme.reward_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;之间的内容全部替换为：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;% if (page.type &#x3D;&#x3D;&#x3D; &quot;tags&quot;) &#123; %&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;tag-cloud-title&quot;&gt;</span><br><span class=\"line\">\t&lt;%- _p(&#39;counter.tag_cloud&#39;, site.tags.length) %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;tag-cloud-tags&quot;&gt;</span><br><span class=\"line\">\t&lt;%- tagcloud(&#123;</span><br><span class=\"line\">\t\tmin_font: 12,</span><br><span class=\"line\">\t\tmax_font: 30,</span><br><span class=\"line\">\t\tamount: 200,</span><br><span class=\"line\">\t\tcolor: true,</span><br><span class=\"line\">\t\tstart_color: &#39;#ccc&#39;,</span><br><span class=\"line\">\t\tend_color: &#39;#111&#39;</span><br><span class=\"line\">\t\t&#125;) %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;% &#125; </span><br><span class=\"line\">else if (page.type &#x3D;&#x3D;&#x3D; &#39;categories&#39;) &#123; </span><br><span class=\"line\">%&gt; &lt;div class&#x3D;&quot;category-all-page&quot;&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;category-all-title&quot;&gt;</span><br><span class=\"line\">\t&lt;%- _p(&#39;&#39;, site.categories.length) %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;category-all&quot;&gt;</span><br><span class=\"line\">\t&lt;%- list_categories() %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">\t&lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;\t\t&lt;%- post.excerpt %&gt;</span><br><span class=\"line\">\t&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">\t\t&lt;%- post.content %&gt;</span><br><span class=\"line\">\t&lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>5、修改自己的文章</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: Hexo博客多电脑同步（hexo+GitHub）</span><br><span class=\"line\">date: <span class=\"number\">2020</span><span class=\"number\">-06</span><span class=\"number\">-29</span> <span class=\"number\">09</span>:<span class=\"number\">58</span>:<span class=\"number\">13</span></span><br><span class=\"line\">tags: </span><br><span class=\"line\">- Hexo</span><br><span class=\"line\">- GitHub</span><br><span class=\"line\">- Git</span><br><span class=\"line\">categories: </span><br><span class=\"line\">- hexo</span><br></pre></td></tr></table></figure>\n\n<p>（7）分页显示错误</p>\n<p>首先找到<em>blog\\themes\\yilia\\layout_partial\\archive.ejs</em></p>\n<p>修改两处，分别在8，9行与37，38行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class=\"line\">  &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125;) %&gt;</span><br><span class=\"line\">&lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class=\"line\">  &lt;nav id&#x3D;&quot;page-nav&quot;&gt;</span><br><span class=\"line\">    &lt;%- paginator(&#123;</span><br><span class=\"line\">      prev_text: &#39;上一页&#39;,</span><br><span class=\"line\">      next_text: &#39;下一页&#39;</span><br><span class=\"line\">    &#125;) %&gt;</span><br><span class=\"line\">  &lt;&#x2F;nav&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后找到<em>blog\\themes\\yilia\\layout_partial\\script.ejs</em><br>ctrl + f 搜索 next &amp;raquo</p>\n<p><img src=\"/articleImage/2020-06-29/1.png\" alt=\"script.ejs\"></p>\n<p>找到图片中框选的两处， 分别改为上一页与下一页</p>\n<p><img src=\"/articleImage/2020-06-29/2.png\" alt=\"script.ejs\"></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1046404\" target=\"_blank\" rel=\"noopener\">参考链接1</a></p>\n<p><a href=\"https://blog.csdn.net/dta0502/article/details/89607895\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-如何让公司电脑A、家里电脑B都能同步编辑博客。\"><a href=\"#1-如何让公司电脑A、家里电脑B都能同步编辑博客。\" class=\"headerlink\" title=\"1.如何让公司电脑A、家里电脑B都能同步编辑博客。\"></a>1.如何让公司电脑A、家里电脑B都能同步编辑博客。</h3><p><strong>上传博客工程到Github</strong></p>\n<p> 首先在公司的A电脑搭建并部署完系统后，我们需要将项目上传到你的github上。在A电脑上执行如下命令:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#git初始化</span><br><span class=\"line\">git init</span><br><span class=\"line\">#添加仓库地址</span><br><span class=\"line\">git remote add origin https:<span class=\"comment\">//github.com/用户名/你的GitHub用户名.github.io.git </span></span><br><span class=\"line\">#新建分支并切换到新建的分支</span><br><span class=\"line\">git checkout -b 分支名 </span><br><span class=\"line\">#添加所有本地文件到git</span><br><span class=\"line\">git add . </span><br><span class=\"line\">#git提交</span><br><span class=\"line\">git commit -m <span class=\"string\">\"这里填写你本次提交的备注，内容随意\"</span> </span><br><span class=\"line\">#文件推送到hexo分支</span><br><span class=\"line\">git push origin 分支名</span><br></pre></td></tr></table></figure>\n\n<p><strong>从另一台电脑下载博客工程</strong></p>\n<p>B电脑如何下载项目文件呢？首先在B电脑上部署好Git和Node.js环境。</p>\n<p>然后输入以下命令","more":"</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b 分支名 https:<span class=\"comment\">//github.com/用户名/你的GitHub用户</span></span><br></pre></td></tr></table></figure>\n\n<p>克隆下载完成后，进入到你项目的文件夹，重新配置你的hexo环境，命令如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置</span><br><span class=\"line\">sudo npm install -g hexo-cli </span><br><span class=\"line\">#安装依赖库</span><br><span class=\"line\">sudo npm install </span><br><span class=\"line\">#安装git部署相关配置</span><br><span class=\"line\">sudo npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以创建撰写新的文章，并使用sudo hexo g -d命令创建并部署您的网站。</p>\n<p><strong>撰写完后如何再次同步</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"提交的备注，内容随意\"</span></span><br><span class=\"line\">git push origin 分支名</span><br><span class=\"line\">#没错，这个样就够了~你B电脑上的数据也已经同步到Github上面了。</span><br><span class=\"line\">#那第二天到A电脑跟前，只需要执行以下命令就行</span><br><span class=\"line\"></span><br><span class=\"line\">git pull</span><br><span class=\"line\">#这样，你的数据就全部同步到A电脑了，以后在部署完后，再次执行</span><br><span class=\"line\"></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"提交的备注，内容随意\"</span></span><br><span class=\"line\">git push origin 分支名</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>常见问题</strong></p>\n<p>（1）修改主题后，主题文件无法推送至GitHub</p>\n<p>可能是该子文件夹下有.git文件夹导致无法上传，</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">#删除子文件夹下.git后，依然无法提交子文件夹下的文件。</span></span><br><span class=\"line\"><span class=\"bullet\">1. </span>git rm --cached themes/yilia</span><br><span class=\"line\"><span class=\"bullet\">2. </span>git add .</span><br><span class=\"line\"><span class=\"bullet\">3. </span>git commit -m \"xxx\"</span><br><span class=\"line\"><span class=\"bullet\">4. </span>git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>（2）文章多标签格式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: </span><br><span class=\"line\">- Hexo</span><br><span class=\"line\">- GitHub</span><br><span class=\"line\">- Git</span><br></pre></td></tr></table></figure>\n\n<p>（3）文章缩略标识</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>（4）添加评论GitTalk</p>\n<p><strong>创建 gitalk.ejs</strong></p>\n<p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/post/</code> 目录下创建 <code>gitalk.ejs</code> 并写入如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;blueimp-md5&#x2F;2.10.0&#x2F;js&#x2F;md5.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class=\"line\">  clientID: &#39;&lt;%&#x3D;theme.gitalk.clientID%&gt;&#39;,</span><br><span class=\"line\">  clientSecret: &#39;&lt;%&#x3D;theme.gitalk.clientSecret%&gt;&#39;,</span><br><span class=\"line\">  repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class=\"line\">  owner: &#39;&lt;%&#x3D;theme.gitalk.owner%&gt;&#39;,</span><br><span class=\"line\">  admin: [&#39;&lt;%&#x3D;theme.gitalk.admin%&gt;&#39;],</span><br><span class=\"line\">  id: md5(window.location.pathname),</span><br><span class=\"line\">  distractionFreeMode: &lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>修改 article.ejs</strong></p>\n<p>在你的 hexo 目录 <code>/theme/yilia/layout/_partial/article.ejs</code> 文件中最后一行 <code>“&lt;% } %&gt;”</code> 之前添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if(theme.gitalk.enable &amp;&amp; theme.gitalk.distractionFreeMode)&#123; %&gt;</span><br><span class=\"line\">      &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class=\"line\">      key: post.slug,</span><br><span class=\"line\">      title: post.title,</span><br><span class=\"line\">      url: config.url+url_for(post.path)</span><br><span class=\"line\">    &#125;) %&gt;</span><br><span class=\"line\">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>添加配置文件</strong></p>\n<p>在 yilia 的配置文件<code>_config.yml</code> 中 gitment 配置下面添加如下配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#6. Gitalk</span><br><span class=\"line\">gitalk: </span><br><span class=\"line\">  enable: true    #用来做启用判断可以不用</span><br><span class=\"line\">  clientID: your clientID    #Github上生成的 Settings Developer&#x2F;settings&#x2F;OAuth Apps</span><br><span class=\"line\">  clientSecret: your clientSecret   #同上</span><br><span class=\"line\">  repo: git_comment    #评论所在的github project</span><br><span class=\"line\">  owner: findtheonlyway    #github用户名</span><br><span class=\"line\">  admin: erbiduo    #可以初始化评论issue的github账户名称</span><br><span class=\"line\">  distractionFreeMode: true</span><br></pre></td></tr></table></figure>\n\n<p>（5）微信分享二维码失效</p>\n<p>打开<code>themes\\yilia\\layout\\_partial\\post\\share.ejs</code>文件</p>\n<p>把第49行中的 <code>//pan.baidu.com/share/qrcode?url=</code>修改为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=</span></span><br></pre></td></tr></table></figure>\n\n<p>（6）添加文章分类</p>\n<p><strong>1、添加categories链接</strong><br>打开yilia/_config.yml文件，menu处做出以下修改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  主页: <span class=\"regexp\">/</span></span><br><span class=\"line\"><span class=\"regexp\">  分类: /</span>categories</span><br><span class=\"line\">  归档: <span class=\"regexp\">/archives</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>2、分类页面的构建</strong><br>新建categories页面</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> page categories</span><br><span class=\"line\">#该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。</span><br></pre></td></tr></table></figure>\n\n<p>修改categories/index.md为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 文章分类</span><br><span class=\"line\">date: 2018-06-11 10:13:21</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n\n<p>生成html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:4000/categories/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/categories/</a> ，即可看到categories页面，只不过现在的页面只有标题。</p>\n<p><strong>3、修改 yilia 主题</strong><br>修改<em>yilia\\source\\main.0cf68a.css</em>，将下面的内容添加进去：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">category-all-page &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">30</span>px <span class=\"number\">40</span>px <span class=\"number\">30</span>px <span class=\"number\">40</span>px;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    min-height: <span class=\"number\">70</span>vh;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page h2 &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">20</span>px <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-all-title &#123;</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-all &#123;</span><br><span class=\"line\">    margin-top: <span class=\"number\">20</span>px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">0</span>;</span><br><span class=\"line\">    padding: <span class=\"number\">0</span>;</span><br><span class=\"line\">    list-style: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-item &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">10</span>px <span class=\"number\">15</span>px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-count &#123;</span><br><span class=\"line\">    color: $grey;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-count:before &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\" (\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item-list-count:after &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\") \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-item &#123;</span><br><span class=\"line\">    margin: <span class=\"number\">10</span>px <span class=\"number\">10</span>px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-count &#123;</span><br><span class=\"line\">    color: $grey;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-count:before &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\" (\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-count:after &#123;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">    content: <span class=\"string\">\") \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .category-all-page .category-list-child &#123;</span><br><span class=\"line\">    padding-left: <span class=\"number\">10</span>px;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4、多层分类</strong><br>新建<em>yilia/layout/categories.ejs</em>，输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;article <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"article article-type-post show\"</span>&gt;</span><br><span class=\"line\">  &lt;header <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"article-header\"</span> style=<span class=\"string\">\"border-bottom: 1px solid #ccc\"</span>&gt;</span><br><span class=\"line\">  &lt;h1 <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"article-title\"</span> itemprop=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\">    &lt;%= page.title %&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>header&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;% <span class=\"keyword\">if</span> (site.categories.length)&#123; %&gt;</span><br><span class=\"line\">  &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"category-all-page\"</span>&gt;</span><br><span class=\"line\">    &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;%- list_categories(site.categories, &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      show_count: true,</span></span><br><span class=\"line\"><span class=\"regexp\">      class: 'category-list-item',</span></span><br><span class=\"line\"><span class=\"regexp\">      style: 'list',</span></span><br><span class=\"line\"><span class=\"regexp\">      depth: 2,</span></span><br><span class=\"line\"><span class=\"regexp\">      separator: ''</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;) %&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">  &lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/article&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>找到 <em>layout/_partial/article.ejs</em> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#然后找到&lt;div class&#x3D;&quot;article-entry&quot; itemprop&#x3D;&quot;articleBody&quot;&gt;</span><br><span class=\"line\">#与&lt;% if ((theme.reward_type &#x3D;&#x3D;&#x3D; 2 || (theme.reward_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;之间的内容全部替换为：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;% if (page.type &#x3D;&#x3D;&#x3D; &quot;tags&quot;) &#123; %&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;tag-cloud&quot;&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;tag-cloud-title&quot;&gt;</span><br><span class=\"line\">\t&lt;%- _p(&#39;counter.tag_cloud&#39;, site.tags.length) %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;tag-cloud-tags&quot;&gt;</span><br><span class=\"line\">\t&lt;%- tagcloud(&#123;</span><br><span class=\"line\">\t\tmin_font: 12,</span><br><span class=\"line\">\t\tmax_font: 30,</span><br><span class=\"line\">\t\tamount: 200,</span><br><span class=\"line\">\t\tcolor: true,</span><br><span class=\"line\">\t\tstart_color: &#39;#ccc&#39;,</span><br><span class=\"line\">\t\tend_color: &#39;#111&#39;</span><br><span class=\"line\">\t\t&#125;) %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;% &#125; </span><br><span class=\"line\">else if (page.type &#x3D;&#x3D;&#x3D; &#39;categories&#39;) &#123; </span><br><span class=\"line\">%&gt; &lt;div class&#x3D;&quot;category-all-page&quot;&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;category-all-title&quot;&gt;</span><br><span class=\"line\">\t&lt;%- _p(&#39;&#39;, site.categories.length) %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;category-all&quot;&gt;</span><br><span class=\"line\">\t&lt;%- list_categories() %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">\t&lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;\t\t&lt;%- post.excerpt %&gt;</span><br><span class=\"line\">\t&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">\t\t&lt;%- post.content %&gt;</span><br><span class=\"line\">\t&lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>5、修改自己的文章</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: Hexo博客多电脑同步（hexo+GitHub）</span><br><span class=\"line\">date: <span class=\"number\">2020</span><span class=\"number\">-06</span><span class=\"number\">-29</span> <span class=\"number\">09</span>:<span class=\"number\">58</span>:<span class=\"number\">13</span></span><br><span class=\"line\">tags: </span><br><span class=\"line\">- Hexo</span><br><span class=\"line\">- GitHub</span><br><span class=\"line\">- Git</span><br><span class=\"line\">categories: </span><br><span class=\"line\">- hexo</span><br></pre></td></tr></table></figure>\n\n<p>（7）分页显示错误</p>\n<p>首先找到<em>blog\\themes\\yilia\\layout_partial\\archive.ejs</em></p>\n<p>修改两处，分别在8，9行与37，38行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% page.posts.each(function(post)&#123; %&gt;</span><br><span class=\"line\">  &lt;%- partial(&#39;article&#39;, &#123;post: post, index: true&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125;) %&gt;</span><br><span class=\"line\">&lt;% if (page.total &gt; 1)&#123; %&gt;</span><br><span class=\"line\">  &lt;nav id&#x3D;&quot;page-nav&quot;&gt;</span><br><span class=\"line\">    &lt;%- paginator(&#123;</span><br><span class=\"line\">      prev_text: &#39;上一页&#39;,</span><br><span class=\"line\">      next_text: &#39;下一页&#39;</span><br><span class=\"line\">    &#125;) %&gt;</span><br><span class=\"line\">  &lt;&#x2F;nav&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后找到<em>blog\\themes\\yilia\\layout_partial\\script.ejs</em><br>ctrl + f 搜索 next &amp;raquo</p>\n<p><img src=\"/articleImage/2020-06-29/1.png\" alt=\"script.ejs\"></p>\n<p>找到图片中框选的两处， 分别改为上一页与下一页</p>\n<p><img src=\"/articleImage/2020-06-29/2.png\" alt=\"script.ejs\"></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1046404\" target=\"_blank\" rel=\"noopener\">参考链接1</a></p>\n<p><a href=\"https://blog.csdn.net/dta0502/article/details/89607895\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>"},{"title":"Lambda","date":"2017-03-13T07:23:43.000Z","_content":"\nJava8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。\n在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。\n\n## 1.Lambda表达式\nJava 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。\nJava 8中使用新特性Lambda表达式来改善这一点。\n<!--more-->\n### 1.1 使用示例\n以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。\n使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。\n{% codeblock %}\nnew Thread(()->System.out.println(\"Lambda\")).start();\n{% endcodeblock %}\n### 1.2 类型参数推断机制(Type Argument Inference)\nLambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。\n\n### 1.3 函数接口(Functional Interface)\n一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。\nRunnable的函数接口如下:\n![](/img/articleImg/jk82.png)\n可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。\nJava8中定义若干函数接口(位于包java.util.function)。\n![](/img/articleImg/jk8.png)\n以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。\n\n### 1.4 并非语法糖\n从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。\n{% codeblock %}\nclass Apple{\n\tpublic String toString() {return \"apple\";};\n\tRunnable r1 = ()->{System.out.println(this);};\n\tRunnable r2 = new Runnable() {\n\t\tpublic void run() {\n\t\t\tSystem.out.println(this);\n\t\t}\n\t};\n}\n//执行两个线程得到的结果是\napple\nDay0917.Apple$1@22e90474\n{% endcodeblock %}\n\n\t正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。\n\tLambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。\n\tLambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final.\n\n### 1.5 默认方法\nJava8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。\n{% codeblock %}\ninterface Apple{\n\tdefault void show(){\n\t\tSystem.out.println(\"interface\");\n\t}\n}\nclass MyApple implements Apple{\n\t@Override\n\tpublic void show() {\n\t\tApple.super.show();\n\t}\n}\n{% endcodeblock %}\n如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。\n\n### 1.6 方法引用\n如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。\n在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。\n\n>//1,建立一个字符串\n>String::new \n>//2.建立一个字符串数组\n>String[]::new\n>注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。\n\n## 2.流stream\n任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:\n{% codeblock %}\nArrayList<String> person = new ArrayList<>();\n----init----\n//1.由集合获得流对象\nStream<String> steam = person.stream();\n//2.对流对象进行过滤和统计\nsteam.filter((s)->s.startsWith(\"a\")) //1.流过滤\n.count(); //2.计算流对象中元素数目\n{% endcodeblock %}\n使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T--->boolean 的方法。\n上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:\n获得流对象Stream\n对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。\n对流对象Stream进行及早求值，返回值不在是一个Stream对象。\n\n### 2.1常见高阶函数\n#### 1.collect方法\ncollect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。\n这项工作由收集器Collector完成。java8为此提供了Collectors工具类。\n#### 1.1 转换成集合\n>List<Person> list = stream.collect(Collectors.toList());\n>List<Person> arraylist = stream.collect(Collectors.toCollection(ArrayList::new));       \n>Set<Person> set = stream.collect(Collectors.toSet());\n>Set<Person> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));\n\n使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型；\n#### 1.2 转换成值\n>//1.获得最大最小值\n>Function<Person, Integer> getLevel = p->p.age; \n>Comparator<Person> comparator = Comparator.comparing(getLevel);\n>stream.collect(Collectors.maxBy(comparator));\n>stream.collect(Collectors.minBy(comparator));\n>//2.获得平均值\n>ToIntFunction<Person> getAverage = p->p.age;\n>stream.collect(Collectors.averagingInt(getAverage));\n\n#### 1.3 数据分块\n将流对象按某种条件分成两部分\n>Predicate<Person> isTang = p->p.country.equals(Country.Tang);\n>stream.collect(Collectors.partitioningBy(isTang));\n\n#### 1.4 数据分组\n>Function<Person, Integer> country= p -> p.country.ordinal();\n>stream.collect(Collectors.groupingBy(country));\n\n分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。\n#### 1.5 字符串\n>stream.map(Person::getName).collect(Collectors.joining(\"/\", \"[\", \"]\"));\n\n#### 1.6 合并收集器\n>stream.collect(Collectors.groupingBy(country,Collectors.counting()));\n\n### 2.map\nmap是一个惰性求值方法。函数接口为Function<T, R>函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。\n### 3.filter\nfilter 是一个惰性求值方法。函数接口为Pridicate<T>,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。\n### 4.flatMap系列\nflatMap 是一个惰性求值方法。其参数亦为Function<T, R>,将多个流组合为一个流。\n{% codeblock %}\n//1.a1,a2是两个列表，map处理后仍是两个列表\nStream.of(a1,a2).map(s->s)\n\n[1, 2, 3, 4]\n[]\n\n//2.flatMap将二者合并为一个流\nStream.of(a1,a2).map(s->s)\n.flatMap(s->s.stream())\n{% endcodeblock %}\n1234\n看源码可知，flatMap中函数接口Function的输出类型为Stream<R>。\n### 5.max/min\n属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。\nmin(Comparator.comparing(s->s.toString()));\nmax/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。\n### 6.reduce\n属于一个及早求值方法。意为流数据的累加，有两个版本。\n{% codeblock %}\n//1.无初始值累加\nT t = person.stream().reduce((a,b)->a+b);\n//2.带初始值累加\nOptional<T> t = person.stream().reduce(\"1\",(a,b)->a+b);\n{% endcodeblock %}\n### 7.foreach\n属于一个及早求值方法，用来遍历流对象。\n总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。","source":"_posts/Lambda.md","raw":"---\ntitle: Lambda\ndate: 2017-03-13 15:23:43\ntags:\n\t- Lambda\ncategories:\n\t- 编程\n\t- Java\n---\n\nJava8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。\n在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。\n\n## 1.Lambda表达式\nJava 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。\nJava 8中使用新特性Lambda表达式来改善这一点。\n<!--more-->\n### 1.1 使用示例\n以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。\n使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。\n{% codeblock %}\nnew Thread(()->System.out.println(\"Lambda\")).start();\n{% endcodeblock %}\n### 1.2 类型参数推断机制(Type Argument Inference)\nLambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。\n\n### 1.3 函数接口(Functional Interface)\n一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。\nRunnable的函数接口如下:\n![](/img/articleImg/jk82.png)\n可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。\nJava8中定义若干函数接口(位于包java.util.function)。\n![](/img/articleImg/jk8.png)\n以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。\n\n### 1.4 并非语法糖\n从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。\n{% codeblock %}\nclass Apple{\n\tpublic String toString() {return \"apple\";};\n\tRunnable r1 = ()->{System.out.println(this);};\n\tRunnable r2 = new Runnable() {\n\t\tpublic void run() {\n\t\t\tSystem.out.println(this);\n\t\t}\n\t};\n}\n//执行两个线程得到的结果是\napple\nDay0917.Apple$1@22e90474\n{% endcodeblock %}\n\n\t正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。\n\tLambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。\n\tLambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final.\n\n### 1.5 默认方法\nJava8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。\n{% codeblock %}\ninterface Apple{\n\tdefault void show(){\n\t\tSystem.out.println(\"interface\");\n\t}\n}\nclass MyApple implements Apple{\n\t@Override\n\tpublic void show() {\n\t\tApple.super.show();\n\t}\n}\n{% endcodeblock %}\n如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。\n\n### 1.6 方法引用\n如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。\n在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。\n\n>//1,建立一个字符串\n>String::new \n>//2.建立一个字符串数组\n>String[]::new\n>注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。\n\n## 2.流stream\n任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:\n{% codeblock %}\nArrayList<String> person = new ArrayList<>();\n----init----\n//1.由集合获得流对象\nStream<String> steam = person.stream();\n//2.对流对象进行过滤和统计\nsteam.filter((s)->s.startsWith(\"a\")) //1.流过滤\n.count(); //2.计算流对象中元素数目\n{% endcodeblock %}\n使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T--->boolean 的方法。\n上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:\n获得流对象Stream\n对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。\n对流对象Stream进行及早求值，返回值不在是一个Stream对象。\n\n### 2.1常见高阶函数\n#### 1.collect方法\ncollect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。\n这项工作由收集器Collector完成。java8为此提供了Collectors工具类。\n#### 1.1 转换成集合\n>List<Person> list = stream.collect(Collectors.toList());\n>List<Person> arraylist = stream.collect(Collectors.toCollection(ArrayList::new));       \n>Set<Person> set = stream.collect(Collectors.toSet());\n>Set<Person> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));\n\n使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型；\n#### 1.2 转换成值\n>//1.获得最大最小值\n>Function<Person, Integer> getLevel = p->p.age; \n>Comparator<Person> comparator = Comparator.comparing(getLevel);\n>stream.collect(Collectors.maxBy(comparator));\n>stream.collect(Collectors.minBy(comparator));\n>//2.获得平均值\n>ToIntFunction<Person> getAverage = p->p.age;\n>stream.collect(Collectors.averagingInt(getAverage));\n\n#### 1.3 数据分块\n将流对象按某种条件分成两部分\n>Predicate<Person> isTang = p->p.country.equals(Country.Tang);\n>stream.collect(Collectors.partitioningBy(isTang));\n\n#### 1.4 数据分组\n>Function<Person, Integer> country= p -> p.country.ordinal();\n>stream.collect(Collectors.groupingBy(country));\n\n分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。\n#### 1.5 字符串\n>stream.map(Person::getName).collect(Collectors.joining(\"/\", \"[\", \"]\"));\n\n#### 1.6 合并收集器\n>stream.collect(Collectors.groupingBy(country,Collectors.counting()));\n\n### 2.map\nmap是一个惰性求值方法。函数接口为Function<T, R>函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。\n### 3.filter\nfilter 是一个惰性求值方法。函数接口为Pridicate<T>,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。\n### 4.flatMap系列\nflatMap 是一个惰性求值方法。其参数亦为Function<T, R>,将多个流组合为一个流。\n{% codeblock %}\n//1.a1,a2是两个列表，map处理后仍是两个列表\nStream.of(a1,a2).map(s->s)\n\n[1, 2, 3, 4]\n[]\n\n//2.flatMap将二者合并为一个流\nStream.of(a1,a2).map(s->s)\n.flatMap(s->s.stream())\n{% endcodeblock %}\n1234\n看源码可知，flatMap中函数接口Function的输出类型为Stream<R>。\n### 5.max/min\n属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。\nmin(Comparator.comparing(s->s.toString()));\nmax/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。\n### 6.reduce\n属于一个及早求值方法。意为流数据的累加，有两个版本。\n{% codeblock %}\n//1.无初始值累加\nT t = person.stream().reduce((a,b)->a+b);\n//2.带初始值累加\nOptional<T> t = person.stream().reduce(\"1\",(a,b)->a+b);\n{% endcodeblock %}\n### 7.foreach\n属于一个及早求值方法，用来遍历流对象。\n总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。","slug":"Lambda","published":1,"updated":"2020-07-02T03:33:23.248Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtst0007yctoal7nejt7","content":"<p>Java8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。<br>在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。</p>\n<h2 id=\"1-Lambda表达式\"><a href=\"#1-Lambda表达式\" class=\"headerlink\" title=\"1.Lambda表达式\"></a>1.Lambda表达式</h2><p>Java 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。<br>Java 8中使用新特性Lambda表达式来改善这一点。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-1-使用示例\"><a href=\"#1-1-使用示例\" class=\"headerlink\" title=\"1.1 使用示例\"></a>1.1 使用示例</h3><p>以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。<br>使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(()-&gt;System.out.println(&quot;Lambda&quot;)).start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-类型参数推断机制-Type-Argument-Inference\"><a href=\"#1-2-类型参数推断机制-Type-Argument-Inference\" class=\"headerlink\" title=\"1.2 类型参数推断机制(Type Argument Inference)\"></a>1.2 类型参数推断机制(Type Argument Inference)</h3><p>Lambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。</p>\n<h3 id=\"1-3-函数接口-Functional-Interface\"><a href=\"#1-3-函数接口-Functional-Interface\" class=\"headerlink\" title=\"1.3 函数接口(Functional Interface)\"></a>1.3 函数接口(Functional Interface)</h3><p>一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。<br>Runnable的函数接口如下:<br><img src=\"/img/articleImg/jk82.png\" alt=\"\"><br>可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。<br>Java8中定义若干函数接口(位于包java.util.function)。<br><img src=\"/img/articleImg/jk8.png\" alt=\"\"><br>以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。</p>\n<h3 id=\"1-4-并非语法糖\"><a href=\"#1-4-并非语法糖\" class=\"headerlink\" title=\"1.4 并非语法糖\"></a>1.4 并非语法糖</h3><p>从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">\tpublic String toString() &#123;return &quot;apple&quot;;&#125;;</span><br><span class=\"line\">\tRunnable r1 &#x3D; ()-&gt;&#123;System.out.println(this);&#125;;</span><br><span class=\"line\">\tRunnable r2 &#x3D; new Runnable() &#123;</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(this);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;执行两个线程得到的结果是</span><br><span class=\"line\">apple</span><br><span class=\"line\">Day0917.Apple$1@22e90474</span><br></pre></td></tr></table></figure>\n\n<pre><code>正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。\nLambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。\nLambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final.</code></pre><h3 id=\"1-5-默认方法\"><a href=\"#1-5-默认方法\" class=\"headerlink\" title=\"1.5 默认方法\"></a>1.5 默认方法</h3><p>Java8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Apple&#123;</span><br><span class=\"line\">\tdefault void show()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;interface&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MyApple implements Apple&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void show() &#123;</span><br><span class=\"line\">\t\tApple.super.show();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。</p>\n<h3 id=\"1-6-方法引用\"><a href=\"#1-6-方法引用\" class=\"headerlink\" title=\"1.6 方法引用\"></a>1.6 方法引用</h3><p>如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。<br>在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。</p>\n<blockquote>\n<p>//1,建立一个字符串<br>String::new<br>//2.建立一个字符串数组<br>String[]::new<br>注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。</p>\n</blockquote>\n<h2 id=\"2-流stream\"><a href=\"#2-流stream\" class=\"headerlink\" title=\"2.流stream\"></a>2.流stream</h2><p>任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; person &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">----init----</span><br><span class=\"line\">&#x2F;&#x2F;1.由集合获得流对象</span><br><span class=\"line\">Stream&lt;String&gt; steam &#x3D; person.stream();</span><br><span class=\"line\">&#x2F;&#x2F;2.对流对象进行过滤和统计</span><br><span class=\"line\">steam.filter((s)-&gt;s.startsWith(&quot;a&quot;)) &#x2F;&#x2F;1.流过滤</span><br><span class=\"line\">.count(); &#x2F;&#x2F;2.计算流对象中元素数目</span><br></pre></td></tr></table></figure>\n<p>使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T—&gt;boolean 的方法。<br>上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:<br>获得流对象Stream<br>对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。<br>对流对象Stream进行及早求值，返回值不在是一个Stream对象。</p>\n<h3 id=\"2-1常见高阶函数\"><a href=\"#2-1常见高阶函数\" class=\"headerlink\" title=\"2.1常见高阶函数\"></a>2.1常见高阶函数</h3><h4 id=\"1-collect方法\"><a href=\"#1-collect方法\" class=\"headerlink\" title=\"1.collect方法\"></a>1.collect方法</h4><p>collect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。<br>这项工作由收集器Collector完成。java8为此提供了Collectors工具类。</p>\n<h4 id=\"1-1-转换成集合\"><a href=\"#1-1-转换成集合\" class=\"headerlink\" title=\"1.1 转换成集合\"></a>1.1 转换成集合</h4><blockquote>\n<p>List<Person> list = stream.collect(Collectors.toList());<br>List<Person> arraylist = stream.collect(Collectors.toCollection(ArrayList::new));<br>Set<Person> set = stream.collect(Collectors.toSet());<br>Set<Person> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));</p>\n</blockquote>\n<p>使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型；</p>\n<h4 id=\"1-2-转换成值\"><a href=\"#1-2-转换成值\" class=\"headerlink\" title=\"1.2 转换成值\"></a>1.2 转换成值</h4><blockquote>\n<p>//1.获得最大最小值<br>Function&lt;Person, Integer&gt; getLevel = p-&gt;p.age;<br>Comparator<Person> comparator = Comparator.comparing(getLevel);<br>stream.collect(Collectors.maxBy(comparator));<br>stream.collect(Collectors.minBy(comparator));<br>//2.获得平均值<br>ToIntFunction<Person> getAverage = p-&gt;p.age;<br>stream.collect(Collectors.averagingInt(getAverage));</p>\n</blockquote>\n<h4 id=\"1-3-数据分块\"><a href=\"#1-3-数据分块\" class=\"headerlink\" title=\"1.3 数据分块\"></a>1.3 数据分块</h4><p>将流对象按某种条件分成两部分</p>\n<blockquote>\n<p>Predicate<Person> isTang = p-&gt;p.country.equals(Country.Tang);<br>stream.collect(Collectors.partitioningBy(isTang));</p>\n</blockquote>\n<h4 id=\"1-4-数据分组\"><a href=\"#1-4-数据分组\" class=\"headerlink\" title=\"1.4 数据分组\"></a>1.4 数据分组</h4><blockquote>\n<p>Function&lt;Person, Integer&gt; country= p -&gt; p.country.ordinal();<br>stream.collect(Collectors.groupingBy(country));</p>\n</blockquote>\n<p>分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。</p>\n<h4 id=\"1-5-字符串\"><a href=\"#1-5-字符串\" class=\"headerlink\" title=\"1.5 字符串\"></a>1.5 字符串</h4><blockquote>\n<p>stream.map(Person::getName).collect(Collectors.joining(“/“, “[“, “]”));</p>\n</blockquote>\n<h4 id=\"1-6-合并收集器\"><a href=\"#1-6-合并收集器\" class=\"headerlink\" title=\"1.6 合并收集器\"></a>1.6 合并收集器</h4><blockquote>\n<p>stream.collect(Collectors.groupingBy(country,Collectors.counting()));</p>\n</blockquote>\n<h3 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2.map\"></a>2.map</h3><p>map是一个惰性求值方法。函数接口为Function&lt;T, R&gt;函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。</p>\n<h3 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3.filter\"></a>3.filter</h3><p>filter 是一个惰性求值方法。函数接口为Pridicate<T>,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。</p>\n<h3 id=\"4-flatMap系列\"><a href=\"#4-flatMap系列\" class=\"headerlink\" title=\"4.flatMap系列\"></a>4.flatMap系列</h3><p>flatMap 是一个惰性求值方法。其参数亦为Function&lt;T, R&gt;,将多个流组合为一个流。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;1.a1,a2是两个列表，map处理后仍是两个列表</span><br><span class=\"line\">Stream.of(a1,a2).map(s-&gt;s)</span><br><span class=\"line\"></span><br><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;2.flatMap将二者合并为一个流</span><br><span class=\"line\">Stream.of(a1,a2).map(s-&gt;s)</span><br><span class=\"line\">.flatMap(s-&gt;s.stream())</span><br></pre></td></tr></table></figure>\n<p>1234<br>看源码可知，flatMap中函数接口Function的输出类型为Stream<R>。</p>\n<h3 id=\"5-max-min\"><a href=\"#5-max-min\" class=\"headerlink\" title=\"5.max/min\"></a>5.max/min</h3><p>属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。<br>min(Comparator.comparing(s-&gt;s.toString()));<br>max/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。</p>\n<h3 id=\"6-reduce\"><a href=\"#6-reduce\" class=\"headerlink\" title=\"6.reduce\"></a>6.reduce</h3><p>属于一个及早求值方法。意为流数据的累加，有两个版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;1.无初始值累加</span><br><span class=\"line\">T t &#x3D; person.stream().reduce((a,b)-&gt;a+b);</span><br><span class=\"line\">&#x2F;&#x2F;2.带初始值累加</span><br><span class=\"line\">Optional&lt;T&gt; t &#x3D; person.stream().reduce(&quot;1&quot;,(a,b)-&gt;a+b);</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-foreach\"><a href=\"#7-foreach\" class=\"headerlink\" title=\"7.foreach\"></a>7.foreach</h3><p>属于一个及早求值方法，用来遍历流对象。<br>总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。</p>\n","site":{"data":{}},"excerpt":"<p>Java8主要的改变是为集合框架增加了流的概念，提高了集合的抽象层次。相比于旧有框架直接操作数据的内部处理方式，流+高阶函数的外部处理方式对数据封装更好。同时流的概念使得对并发编程支持更强。<br>在语法上Java8提供了Lambda表达式来传递方法体,简化了之前方法必须藏身在不必要的类中的繁琐。Lambda表达式体现了函数式编程的思想，即一个函数亦可以作为另一个函数参数和返回值，使用了函数作参数/返回值的函数被称为高阶函数。</p>\n<h2 id=\"1-Lambda表达式\"><a href=\"#1-Lambda表达式\" class=\"headerlink\" title=\"1.Lambda表达式\"></a>1.Lambda表达式</h2><p>Java 被诟病为繁琐的地方就在于不支持传递方法，Java中的方法必须依赖类存在，也不能将方法作为参数或返回值，这是与python等语言相比的弱势。<br>Java 8中使用新特性Lambda表达式来改善这一点。</p>","more":"<h3 id=\"1-1-使用示例\"><a href=\"#1-1-使用示例\" class=\"headerlink\" title=\"1.1 使用示例\"></a>1.1 使用示例</h3><p>以Runnable接口为例，如果需要执行一个线程，实际只需要run()方法中的代码块，但形式上必须要先制造一个Runnable接口实现类(通常是匿名内部类)。<br>使用Lambda表达式仅仅需要一行代码，达到传递run方法的效果,而不必定义匿名内部类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(()-&gt;System.out.println(&quot;Lambda&quot;)).start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-类型参数推断机制-Type-Argument-Inference\"><a href=\"#1-2-类型参数推断机制-Type-Argument-Inference\" class=\"headerlink\" title=\"1.2 类型参数推断机制(Type Argument Inference)\"></a>1.2 类型参数推断机制(Type Argument Inference)</h3><p>Lambda表达式之所以能够做如此简化得益于Java的类型参数推断机制。所有省略的内容都可以由编译器通过上下文推断出来。类型推断机制在Java中的应用广泛，例如数组类型确定，Java7引入的菱形操作符等。类型参数推断机制要推断的是Lambda表达式的目标类型，往往需要与Java的重载解析机制配合。其解析规则是只有一个可能目标类型时，由响应函数接口里的参数类型推导得出有多个可能目标类型，选择最具体的类型有多个可能目标类型但无法明确最具体类型，则编译报错。</p>\n<h3 id=\"1-3-函数接口-Functional-Interface\"><a href=\"#1-3-函数接口-Functional-Interface\" class=\"headerlink\" title=\"1.3 函数接口(Functional Interface)\"></a>1.3 函数接口(Functional Interface)</h3><p>一个方法可以抽象成函数接口。函数接口类似于一个黑箱，只需要关注其参数和返回值类型，函数接口中只有单方法。<br>Runnable的函数接口如下:<br><img src=\"/img/articleImg/jk82.png\" alt=\"\"><br>可以看到这是一个空接口。可以用它代表所有参数和返回值都为空的方法。<br>Java8中定义若干函数接口(位于包java.util.function)。<br><img src=\"/img/articleImg/jk8.png\" alt=\"\"><br>以Pridicate函数接口为例，这是一个泛型接口，参数可以是任意类型，返回值是boolean类型，代表根据数值作判断的一类方法。</p>\n<h3 id=\"1-4-并非语法糖\"><a href=\"#1-4-并非语法糖\" class=\"headerlink\" title=\"1.4 并非语法糖\"></a>1.4 并非语法糖</h3><p>从类型推断的角度看很容易觉得Lambda表达式是和泛型，装箱等机制一样的语法糖，编译器在背后补全了省略信息，但实际上并非如此。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Apple&#123;</span><br><span class=\"line\">\tpublic String toString() &#123;return &quot;apple&quot;;&#125;;</span><br><span class=\"line\">\tRunnable r1 &#x3D; ()-&gt;&#123;System.out.println(this);&#125;;</span><br><span class=\"line\">\tRunnable r2 &#x3D; new Runnable() &#123;</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(this);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;执行两个线程得到的结果是</span><br><span class=\"line\">apple</span><br><span class=\"line\">Day0917.Apple$1@22e90474</span><br></pre></td></tr></table></figure>\n\n<pre><code>正常的匿名内部类中 this关键字 指向内部类对象自身，同时将生成Apple$1.class文件。\nLambda表达式中this所指向的则是外部类对象，并不会生成内部类class文件，这说明Lambda表达式并不是语法糖，它没有产生一个内部类，也没有引入一个新的作用域。\nLambda与内部类相同之处在于其内部所定义的变量均为final或既成事实上的final.</code></pre><h3 id=\"1-5-默认方法\"><a href=\"#1-5-默认方法\" class=\"headerlink\" title=\"1.5 默认方法\"></a>1.5 默认方法</h3><p>Java8最重要的改变就是对类库的改造，使得接口中方法可以拥有代码体。这种定义在接口中的包含方法体的方法，需要用default修饰，称之为默认方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Apple&#123;</span><br><span class=\"line\">\tdefault void show()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;interface&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MyApple implements Apple&#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void show() &#123;</span><br><span class=\"line\">\t\tApple.super.show();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果实现类中重写了默认方法，则接口中默认方法就被覆盖了。如果两个接口定义了相同的默认方法，则实现类中可以通过指定全称来确定使用哪个父类的方法。</p>\n<h3 id=\"1-6-方法引用\"><a href=\"#1-6-方法引用\" class=\"headerlink\" title=\"1.6 方法引用\"></a>1.6 方法引用</h3><p>如果将匿名内部类改造为Lambda表达式是偷懒的话，那方法引用则是懒到连Lambda表达式都不想写了。<br>在之前，我们知道Lambda表达式可以作为函数参数和返回值，表示传递一个方法。方法引用就是使用 ClassName::MethodName 的形式来指定方法。故而方法引用与Lambda表达式完全同源同种，可以相互替代。</p>\n<blockquote>\n<p>//1,建立一个字符串<br>String::new<br>//2.建立一个字符串数组<br>String[]::new<br>注意 lambda表达式与方法引用表示的是方法本身，将要被用过高阶函数的参数/返回值，并不能单独使用。</p>\n</blockquote>\n<h2 id=\"2-流stream\"><a href=\"#2-流stream\" class=\"headerlink\" title=\"2.流stream\"></a>2.流stream</h2><p>任务:创建一个姓名集合，要求出所有初始字母为a的人的总数目。使用流处理的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; person &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">----init----</span><br><span class=\"line\">&#x2F;&#x2F;1.由集合获得流对象</span><br><span class=\"line\">Stream&lt;String&gt; steam &#x3D; person.stream();</span><br><span class=\"line\">&#x2F;&#x2F;2.对流对象进行过滤和统计</span><br><span class=\"line\">steam.filter((s)-&gt;s.startsWith(&quot;a&quot;)) &#x2F;&#x2F;1.流过滤</span><br><span class=\"line\">.count(); &#x2F;&#x2F;2.计算流对象中元素数目</span><br></pre></td></tr></table></figure>\n<p>使用函数接口(形式上表现为Lambda表达式)作为参数和返回值的函数就是所谓的高阶函数，如此处的filter，其参数为函数接口Predicate，亦可以理解为一个接口为 T—&gt;boolean 的方法。<br>上述示例中为流对象的高阶函数传入一个函数接口Predicate，避免了直接处理集合中的数据对象。示例展示了流使用的通用格式:<br>获得流对象Stream<br>对流对象Stream进行惰性求值，返回值仍然是一个Stream对象。<br>对流对象Stream进行及早求值，返回值不在是一个Stream对象。</p>\n<h3 id=\"2-1常见高阶函数\"><a href=\"#2-1常见高阶函数\" class=\"headerlink\" title=\"2.1常见高阶函数\"></a>2.1常见高阶函数</h3><h4 id=\"1-collect方法\"><a href=\"#1-collect方法\" class=\"headerlink\" title=\"1.collect方法\"></a>1.collect方法</h4><p>collect方法属于一个及早求值方法，负责将流对象转换成其他数据结构，如列表，集合，值等。<br>这项工作由收集器Collector完成。java8为此提供了Collectors工具类。</p>\n<h4 id=\"1-1-转换成集合\"><a href=\"#1-1-转换成集合\" class=\"headerlink\" title=\"1.1 转换成集合\"></a>1.1 转换成集合</h4><blockquote>\n<p>List<Person> list = stream.collect(Collectors.toList());<br>List<Person> arraylist = stream.collect(Collectors.toCollection(ArrayList::new));<br>Set<Person> set = stream.collect(Collectors.toSet());<br>Set<Person> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));</p>\n</blockquote>\n<p>使用Collectors.toList()将流对象转换成集合时并不需要指定具体类型，Java默认选择了实现类型，如果要自己指定，可以使用Collectors.toCollection(ArrayList::new)，其参数ArrayList::new就是上文中的方法引用，表示一个建立ArrayList对象的方法，ArrayList就是想要转换成的数据类型；</p>\n<h4 id=\"1-2-转换成值\"><a href=\"#1-2-转换成值\" class=\"headerlink\" title=\"1.2 转换成值\"></a>1.2 转换成值</h4><blockquote>\n<p>//1.获得最大最小值<br>Function&lt;Person, Integer&gt; getLevel = p-&gt;p.age;<br>Comparator<Person> comparator = Comparator.comparing(getLevel);<br>stream.collect(Collectors.maxBy(comparator));<br>stream.collect(Collectors.minBy(comparator));<br>//2.获得平均值<br>ToIntFunction<Person> getAverage = p-&gt;p.age;<br>stream.collect(Collectors.averagingInt(getAverage));</p>\n</blockquote>\n<h4 id=\"1-3-数据分块\"><a href=\"#1-3-数据分块\" class=\"headerlink\" title=\"1.3 数据分块\"></a>1.3 数据分块</h4><p>将流对象按某种条件分成两部分</p>\n<blockquote>\n<p>Predicate<Person> isTang = p-&gt;p.country.equals(Country.Tang);<br>stream.collect(Collectors.partitioningBy(isTang));</p>\n</blockquote>\n<h4 id=\"1-4-数据分组\"><a href=\"#1-4-数据分组\" class=\"headerlink\" title=\"1.4 数据分组\"></a>1.4 数据分组</h4><blockquote>\n<p>Function&lt;Person, Integer&gt; country= p -&gt; p.country.ordinal();<br>stream.collect(Collectors.groupingBy(country));</p>\n</blockquote>\n<p>分块和分组看似相同，但意义不同，分块使用判断作为方法，只能将流分成两块；分组则灵活的多。</p>\n<h4 id=\"1-5-字符串\"><a href=\"#1-5-字符串\" class=\"headerlink\" title=\"1.5 字符串\"></a>1.5 字符串</h4><blockquote>\n<p>stream.map(Person::getName).collect(Collectors.joining(“/“, “[“, “]”));</p>\n</blockquote>\n<h4 id=\"1-6-合并收集器\"><a href=\"#1-6-合并收集器\" class=\"headerlink\" title=\"1.6 合并收集器\"></a>1.6 合并收集器</h4><blockquote>\n<p>stream.collect(Collectors.groupingBy(country,Collectors.counting()));</p>\n</blockquote>\n<h3 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2.map\"></a>2.map</h3><p>map是一个惰性求值方法。函数接口为Function&lt;T, R&gt;函数接口,负责将数据从一个类型转换为另一个类型；高阶函数map的作用就是将数据从一个流转换为另一个流。</p>\n<h3 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3.filter\"></a>3.filter</h3><p>filter 是一个惰性求值方法。函数接口为Pridicate<T>,此方法负责对数据进行判断，filter高阶函数负责根据判断结果对流进行过滤。</p>\n<h3 id=\"4-flatMap系列\"><a href=\"#4-flatMap系列\" class=\"headerlink\" title=\"4.flatMap系列\"></a>4.flatMap系列</h3><p>flatMap 是一个惰性求值方法。其参数亦为Function&lt;T, R&gt;,将多个流组合为一个流。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;1.a1,a2是两个列表，map处理后仍是两个列表</span><br><span class=\"line\">Stream.of(a1,a2).map(s-&gt;s)</span><br><span class=\"line\"></span><br><span class=\"line\">[1, 2, 3, 4]</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;2.flatMap将二者合并为一个流</span><br><span class=\"line\">Stream.of(a1,a2).map(s-&gt;s)</span><br><span class=\"line\">.flatMap(s-&gt;s.stream())</span><br></pre></td></tr></table></figure>\n<p>1234<br>看源码可知，flatMap中函数接口Function的输出类型为Stream<R>。</p>\n<h3 id=\"5-max-min\"><a href=\"#5-max-min\" class=\"headerlink\" title=\"5.max/min\"></a>5.max/min</h3><p>属于一个及早求值方法。需要传入一个Comparator函数接口，Java8提供了Comparator.comparing方法获得该函数接口的实现，该静态方法是接口的静态方法，获得一个函数返回一个Comparator对象。<br>min(Comparator.comparing(s-&gt;s.toString()));<br>max/min的返回值是 Optional，代表一个或有或无的值，主要是用来取代万恶的null值；使用get方法可以获取其值。</p>\n<h3 id=\"6-reduce\"><a href=\"#6-reduce\" class=\"headerlink\" title=\"6.reduce\"></a>6.reduce</h3><p>属于一个及早求值方法。意为流数据的累加，有两个版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;1.无初始值累加</span><br><span class=\"line\">T t &#x3D; person.stream().reduce((a,b)-&gt;a+b);</span><br><span class=\"line\">&#x2F;&#x2F;2.带初始值累加</span><br><span class=\"line\">Optional&lt;T&gt; t &#x3D; person.stream().reduce(&quot;1&quot;,(a,b)-&gt;a+b);</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-foreach\"><a href=\"#7-foreach\" class=\"headerlink\" title=\"7.foreach\"></a>7.foreach</h3><p>属于一个及早求值方法，用来遍历流对象。<br>总而言之，Java8中流对象的引入使得可以在更高的层次上对集合进行处理，使得抽象的方法和具体的行为逻辑分离开来，也加强了数据的封装性，另一个好处是对并发的支持更强，以后再补充。</p>"},{"title":"java8中如何处理时间","date":"2017-04-01T05:12:06.000Z","_content":"\nJava8之前，Date类都是可变类\n当我们在多线程环境下使用它\n编程人员应该确认Date对象的线程安全\nJava8的Date和Time API提供了线程安全的不可变类\n编程人员不用考虑并发的问题\n![](/img/articleImg/time2.jpg)\n<!--more-->\n\n### LocalDate用法\nLocalDate只提供日期不提供时间信息。它是不可变类且线程安全的\n{% codeblock %}\n// 取当前日期：\nLocalDate today = LocalDate.now(); // -> 2017-04-01\n// 根据年月日取日期，04月就是04：\nLocalDate crischristmas = LocalDate.of(2017, 04, 01); // -> 2017-04-01\n// 根据字符串取：\nLocalDate endOfFeb = LocalDate.parse(\"2017-04-01\"); \n// 严格按照ISO yyyy-MM-dd验证，04写成4都不行，当然也有一个重载方法允许自己定义格式\nLocalDate.parse(\"2017-02-29\"); // 无效日期无法通过：DateTimeParseException: Invalid date...\n{% endcodeblock %}\n日期转换经常遇到，比如：\n{% codeblock %}\n// 取本月第1天：\nLocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); // 2017-04-01\n// 取本月第2天：\nLocalDate secondDayOfThisMonth = today.withDayOfMonth(2); // 2017-04-02\n// 取本月最后一天，再也不用计算是28，29，30还是31：\nLocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); // 2017-04-30\n// 取下一天：\nLocalDate nextDayOf = lastDayOfThisMonth.plusDays(1); // 变成了2017-05-01\n// 取2017年1月第一个周一，这个计算用Calendar要死掉很多脑细胞：\nLocalDate firstMondayOf2017 = LocalDate.parse(\"2017-01-01\").with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); // 2017-01-02\n{% endcodeblock %}\n### LocalTime\nLocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的\n{% codeblock %}\nLocalTime now = LocalTime.now(); // 11:09:09.240\n清除毫秒数：\nLocalTime now = LocalTime.now().withNano(0)); // 11:09:09\n构造时间：\nLocalTime zero = LocalTime.of(0, 0, 0); // 00:00:00\nLocalTime mid = LocalTime.parse(\"12:00:00\"); // 12:00:00\n{% endcodeblock %}\n### JDBC\n\n最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：\n>date -> LocalDate\ntime -> LocalTime\ntimestamp -> LocalDateTime\n\n再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了.","source":"_posts/LocalDate.md","raw":"---\ntitle: java8中如何处理时间\ndate: 2017-04-01 13:12:06\ntags: \n\t- Java基础\ncategories:\n\t- 编程\n\t- Java\n---\n\nJava8之前，Date类都是可变类\n当我们在多线程环境下使用它\n编程人员应该确认Date对象的线程安全\nJava8的Date和Time API提供了线程安全的不可变类\n编程人员不用考虑并发的问题\n![](/img/articleImg/time2.jpg)\n<!--more-->\n\n### LocalDate用法\nLocalDate只提供日期不提供时间信息。它是不可变类且线程安全的\n{% codeblock %}\n// 取当前日期：\nLocalDate today = LocalDate.now(); // -> 2017-04-01\n// 根据年月日取日期，04月就是04：\nLocalDate crischristmas = LocalDate.of(2017, 04, 01); // -> 2017-04-01\n// 根据字符串取：\nLocalDate endOfFeb = LocalDate.parse(\"2017-04-01\"); \n// 严格按照ISO yyyy-MM-dd验证，04写成4都不行，当然也有一个重载方法允许自己定义格式\nLocalDate.parse(\"2017-02-29\"); // 无效日期无法通过：DateTimeParseException: Invalid date...\n{% endcodeblock %}\n日期转换经常遇到，比如：\n{% codeblock %}\n// 取本月第1天：\nLocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); // 2017-04-01\n// 取本月第2天：\nLocalDate secondDayOfThisMonth = today.withDayOfMonth(2); // 2017-04-02\n// 取本月最后一天，再也不用计算是28，29，30还是31：\nLocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); // 2017-04-30\n// 取下一天：\nLocalDate nextDayOf = lastDayOfThisMonth.plusDays(1); // 变成了2017-05-01\n// 取2017年1月第一个周一，这个计算用Calendar要死掉很多脑细胞：\nLocalDate firstMondayOf2017 = LocalDate.parse(\"2017-01-01\").with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); // 2017-01-02\n{% endcodeblock %}\n### LocalTime\nLocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的\n{% codeblock %}\nLocalTime now = LocalTime.now(); // 11:09:09.240\n清除毫秒数：\nLocalTime now = LocalTime.now().withNano(0)); // 11:09:09\n构造时间：\nLocalTime zero = LocalTime.of(0, 0, 0); // 00:00:00\nLocalTime mid = LocalTime.parse(\"12:00:00\"); // 12:00:00\n{% endcodeblock %}\n### JDBC\n\n最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：\n>date -> LocalDate\ntime -> LocalTime\ntimestamp -> LocalDateTime\n\n再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了.","slug":"LocalDate","published":1,"updated":"2020-07-02T03:34:03.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtsw000bycto53a01r8h","content":"<p>Java8之前，Date类都是可变类<br>当我们在多线程环境下使用它<br>编程人员应该确认Date对象的线程安全<br>Java8的Date和Time API提供了线程安全的不可变类<br>编程人员不用考虑并发的问题<br><img src=\"/img/articleImg/time2.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h3 id=\"LocalDate用法\"><a href=\"#LocalDate用法\" class=\"headerlink\" title=\"LocalDate用法\"></a>LocalDate用法</h3><p>LocalDate只提供日期不提供时间信息。它是不可变类且线程安全的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 取当前日期：</span><br><span class=\"line\">LocalDate today &#x3D; LocalDate.now(); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class=\"line\">&#x2F;&#x2F; 根据年月日取日期，04月就是04：</span><br><span class=\"line\">LocalDate crischristmas &#x3D; LocalDate.of(2017, 04, 01); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class=\"line\">&#x2F;&#x2F; 根据字符串取：</span><br><span class=\"line\">LocalDate endOfFeb &#x3D; LocalDate.parse(&quot;2017-04-01&quot;); </span><br><span class=\"line\">&#x2F;&#x2F; 严格按照ISO yyyy-MM-dd验证，04写成4都不行，当然也有一个重载方法允许自己定义格式</span><br><span class=\"line\">LocalDate.parse(&quot;2017-02-29&quot;); &#x2F;&#x2F; 无效日期无法通过：DateTimeParseException: Invalid date...</span><br></pre></td></tr></table></figure>\n<p>日期转换经常遇到，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 取本月第1天：</span><br><span class=\"line\">LocalDate firstDayOfThisMonth &#x3D; today.with(TemporalAdjusters.firstDayOfMonth()); &#x2F;&#x2F; 2017-04-01</span><br><span class=\"line\">&#x2F;&#x2F; 取本月第2天：</span><br><span class=\"line\">LocalDate secondDayOfThisMonth &#x3D; today.withDayOfMonth(2); &#x2F;&#x2F; 2017-04-02</span><br><span class=\"line\">&#x2F;&#x2F; 取本月最后一天，再也不用计算是28，29，30还是31：</span><br><span class=\"line\">LocalDate lastDayOfThisMonth &#x3D; today.with(TemporalAdjusters.lastDayOfMonth()); &#x2F;&#x2F; 2017-04-30</span><br><span class=\"line\">&#x2F;&#x2F; 取下一天：</span><br><span class=\"line\">LocalDate nextDayOf &#x3D; lastDayOfThisMonth.plusDays(1); &#x2F;&#x2F; 变成了2017-05-01</span><br><span class=\"line\">&#x2F;&#x2F; 取2017年1月第一个周一，这个计算用Calendar要死掉很多脑细胞：</span><br><span class=\"line\">LocalDate firstMondayOf2017 &#x3D; LocalDate.parse(&quot;2017-01-01&quot;).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); &#x2F;&#x2F; 2017-01-02</span><br></pre></td></tr></table></figure>\n<h3 id=\"LocalTime\"><a href=\"#LocalTime\" class=\"headerlink\" title=\"LocalTime\"></a>LocalTime</h3><p>LocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalTime now &#x3D; LocalTime.now(); &#x2F;&#x2F; 11:09:09.240</span><br><span class=\"line\">清除毫秒数：</span><br><span class=\"line\">LocalTime now &#x3D; LocalTime.now().withNano(0)); &#x2F;&#x2F; 11:09:09</span><br><span class=\"line\">构造时间：</span><br><span class=\"line\">LocalTime zero &#x3D; LocalTime.of(0, 0, 0); &#x2F;&#x2F; 00:00:00</span><br><span class=\"line\">LocalTime mid &#x3D; LocalTime.parse(&quot;12:00:00&quot;); &#x2F;&#x2F; 12:00:00</span><br></pre></td></tr></table></figure>\n<h3 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h3><p>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：</p>\n<blockquote>\n<p>date -&gt; LocalDate<br>time -&gt; LocalTime<br>timestamp -&gt; LocalDateTime</p>\n</blockquote>\n<p>再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了.</p>\n","site":{"data":{}},"excerpt":"<p>Java8之前，Date类都是可变类<br>当我们在多线程环境下使用它<br>编程人员应该确认Date对象的线程安全<br>Java8的Date和Time API提供了线程安全的不可变类<br>编程人员不用考虑并发的问题<br><img src=\"/img/articleImg/time2.jpg\" alt=\"\"></p>","more":"<h3 id=\"LocalDate用法\"><a href=\"#LocalDate用法\" class=\"headerlink\" title=\"LocalDate用法\"></a>LocalDate用法</h3><p>LocalDate只提供日期不提供时间信息。它是不可变类且线程安全的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 取当前日期：</span><br><span class=\"line\">LocalDate today &#x3D; LocalDate.now(); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class=\"line\">&#x2F;&#x2F; 根据年月日取日期，04月就是04：</span><br><span class=\"line\">LocalDate crischristmas &#x3D; LocalDate.of(2017, 04, 01); &#x2F;&#x2F; -&gt; 2017-04-01</span><br><span class=\"line\">&#x2F;&#x2F; 根据字符串取：</span><br><span class=\"line\">LocalDate endOfFeb &#x3D; LocalDate.parse(&quot;2017-04-01&quot;); </span><br><span class=\"line\">&#x2F;&#x2F; 严格按照ISO yyyy-MM-dd验证，04写成4都不行，当然也有一个重载方法允许自己定义格式</span><br><span class=\"line\">LocalDate.parse(&quot;2017-02-29&quot;); &#x2F;&#x2F; 无效日期无法通过：DateTimeParseException: Invalid date...</span><br></pre></td></tr></table></figure>\n<p>日期转换经常遇到，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 取本月第1天：</span><br><span class=\"line\">LocalDate firstDayOfThisMonth &#x3D; today.with(TemporalAdjusters.firstDayOfMonth()); &#x2F;&#x2F; 2017-04-01</span><br><span class=\"line\">&#x2F;&#x2F; 取本月第2天：</span><br><span class=\"line\">LocalDate secondDayOfThisMonth &#x3D; today.withDayOfMonth(2); &#x2F;&#x2F; 2017-04-02</span><br><span class=\"line\">&#x2F;&#x2F; 取本月最后一天，再也不用计算是28，29，30还是31：</span><br><span class=\"line\">LocalDate lastDayOfThisMonth &#x3D; today.with(TemporalAdjusters.lastDayOfMonth()); &#x2F;&#x2F; 2017-04-30</span><br><span class=\"line\">&#x2F;&#x2F; 取下一天：</span><br><span class=\"line\">LocalDate nextDayOf &#x3D; lastDayOfThisMonth.plusDays(1); &#x2F;&#x2F; 变成了2017-05-01</span><br><span class=\"line\">&#x2F;&#x2F; 取2017年1月第一个周一，这个计算用Calendar要死掉很多脑细胞：</span><br><span class=\"line\">LocalDate firstMondayOf2017 &#x3D; LocalDate.parse(&quot;2017-01-01&quot;).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); &#x2F;&#x2F; 2017-01-02</span><br></pre></td></tr></table></figure>\n<h3 id=\"LocalTime\"><a href=\"#LocalTime\" class=\"headerlink\" title=\"LocalTime\"></a>LocalTime</h3><p>LocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalTime now &#x3D; LocalTime.now(); &#x2F;&#x2F; 11:09:09.240</span><br><span class=\"line\">清除毫秒数：</span><br><span class=\"line\">LocalTime now &#x3D; LocalTime.now().withNano(0)); &#x2F;&#x2F; 11:09:09</span><br><span class=\"line\">构造时间：</span><br><span class=\"line\">LocalTime zero &#x3D; LocalTime.of(0, 0, 0); &#x2F;&#x2F; 00:00:00</span><br><span class=\"line\">LocalTime mid &#x3D; LocalTime.parse(&quot;12:00:00&quot;); &#x2F;&#x2F; 12:00:00</span><br></pre></td></tr></table></figure>\n<h3 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h3><p>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：</p>\n<blockquote>\n<p>date -&gt; LocalDate<br>time -&gt; LocalTime<br>timestamp -&gt; LocalDateTime</p>\n</blockquote>\n<p>再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了.</p>"},{"title":"TCP三次握手","date":"2020-07-03T05:53:37.000Z","_content":"\n### 传输控制协议TCP简介\n\n- 面向连接的、可靠的、基于字节流的传输层通信协议\n- 将应用层的数据流分割成报文段并发送给目标节点的TCP层\n- 数据包都有序号，对方收到则发送ACK确认，未收到则重传\n- 使用校验和来检验数据在传输过程中是否有误\n\n![TCP报文](/articleImage/2020-07-03/3.jpg)\n\n<!--more-->\n\n**序列号seq**：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。\n**确认号ack**：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。\n**确认ACK**：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效\n**同步SYN**：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。\n**终止FIN**：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。\n\n![TCP Flags](/articleImage/2020-07-03/2.png)\n\n第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n![TCP Flags](/articleImage/2020-07-03/3.png)\n\n**常见面试题：**\n**1.为什么需要三次握手才能建立起连接**\n\t\t为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。\n\n**2.首次握手的隐患---SYN超时**\n\t\tServer收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。\n对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。\n针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。\n\n**3.建议连接后，client出现故障怎么办？**\n\t\tTCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。","source":"_posts/TCP三次握手.md","raw":"---\ntitle: TCP三次握手\ndate: 2020-07-03 13:53:37\ncategories:\n\t- Java面试\n\t- 计算机网络\n---\n\n### 传输控制协议TCP简介\n\n- 面向连接的、可靠的、基于字节流的传输层通信协议\n- 将应用层的数据流分割成报文段并发送给目标节点的TCP层\n- 数据包都有序号，对方收到则发送ACK确认，未收到则重传\n- 使用校验和来检验数据在传输过程中是否有误\n\n![TCP报文](/articleImage/2020-07-03/3.jpg)\n\n<!--more-->\n\n**序列号seq**：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。\n**确认号ack**：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。\n**确认ACK**：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效\n**同步SYN**：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。\n**终止FIN**：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。\n\n![TCP Flags](/articleImage/2020-07-03/2.png)\n\n第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n![TCP Flags](/articleImage/2020-07-03/3.png)\n\n**常见面试题：**\n**1.为什么需要三次握手才能建立起连接**\n\t\t为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。\n\n**2.首次握手的隐患---SYN超时**\n\t\tServer收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。\n对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。\n针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。\n\n**3.建议连接后，client出现故障怎么办？**\n\t\tTCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。","slug":"TCP三次握手","published":1,"updated":"2020-07-03T08:00:40.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtsy000cycto3ogl5g8d","content":"<h3 id=\"传输控制协议TCP简介\"><a href=\"#传输控制协议TCP简介\" class=\"headerlink\" title=\"传输控制协议TCP简介\"></a>传输控制协议TCP简介</h3><ul>\n<li>面向连接的、可靠的、基于字节流的传输层通信协议</li>\n<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li>\n<li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li>\n<li>使用校验和来检验数据在传输过程中是否有误</li>\n</ul>\n<p><img src=\"/articleImage/2020-07-03/3.jpg\" alt=\"TCP报文\"></p>\n<a id=\"more\"></a>\n\n<p><strong>序列号seq</strong>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。<br><strong>确认号ack</strong>：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。<br><strong>确认ACK</strong>：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效<br><strong>同步SYN</strong>：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。<br><strong>终止FIN</strong>：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</p>\n<p><img src=\"/articleImage/2020-07-03/2.png\" alt=\"TCP Flags\"></p>\n<p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>\n<p><img src=\"/articleImage/2020-07-03/3.png\" alt=\"TCP Flags\"></p>\n<p><strong>常见面试题：</strong><br><strong>1.为什么需要三次握手才能建立起连接</strong><br>        为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。</p>\n<p><strong>2.首次握手的隐患—SYN超时</strong><br>        Server收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。<br>对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。<br>针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。</p>\n<p><strong>3.建议连接后，client出现故障怎么办？</strong><br>        TCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"传输控制协议TCP简介\"><a href=\"#传输控制协议TCP简介\" class=\"headerlink\" title=\"传输控制协议TCP简介\"></a>传输控制协议TCP简介</h3><ul>\n<li>面向连接的、可靠的、基于字节流的传输层通信协议</li>\n<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li>\n<li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li>\n<li>使用校验和来检验数据在传输过程中是否有误</li>\n</ul>\n<p><img src=\"/articleImage/2020-07-03/3.jpg\" alt=\"TCP报文\"></p>","more":"<p><strong>序列号seq</strong>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。<br><strong>确认号ack</strong>：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。<br><strong>确认ACK</strong>：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效<br><strong>同步SYN</strong>：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。<br><strong>终止FIN</strong>：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</p>\n<p><img src=\"/articleImage/2020-07-03/2.png\" alt=\"TCP Flags\"></p>\n<p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>\n<p><img src=\"/articleImage/2020-07-03/3.png\" alt=\"TCP Flags\"></p>\n<p><strong>常见面试题：</strong><br><strong>1.为什么需要三次握手才能建立起连接</strong><br>        为了初始化通信双方sequence number的初始值。也就是x和y这个号要作为以后通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，tcp会利用这个序号来拼接数据。</p>\n<p><strong>2.首次握手的隐患—SYN超时</strong><br>        Server收到client的syn，并且回复syn-ack后，未收到client发送的ack确认，会有什么问题？此时连接并未完成，处于“半连接”状态，server端接下来会不断重发syn-ack报文到客户端，重试5次后才关闭该半连接。<br>对于以上情况，可能会使服务器受到syn flood攻击：恶意程序发送syn请求然后下线了，此时服务端会维持一个半连接直到重试5次后才关闭（linux上重试的频率是1s后，2s后，4s后，…,32s后，一共会维持此连接63s才关闭），会占用服务端连接资源。<br>针对SYN Flood的防护措施:SYN队列满后，通过tcp_syncookies参数会发SYN Cookie若为正常连接则Client会回发SYN Cookie，直接建立连接 。</p>\n<p><strong>3.建议连接后，client出现故障怎么办？</strong><br>        TCP设有保活机制，在保活时间内，连接处于非活动状态，开启保活功能的一方将向对方发送保活探测报文，如果发送方未收到响应则继续发送。若在重发次数达到保活探测数后若仍未收到响应，则认为对方主机不可达，中断连接。</p>"},{"title":"无代码侵入调试dubbo服务","date":"2020-06-28T10:58:48.000Z","_content":"\n### 1.提供者（Provider-service）\n\n​\tdubbo.xml中添加**register=\"false\"** \n\n```xml\n<dubbo:registry protocol=\"zookeeper\" address=\"${zookeeper.cluster}\" register=\"false\"/>\n```\n\n### 2.消费者（Consumer-service）\n\n​        在本地任意位置新建配置文件:dubbo-local-consumer.properties：\n\n```properties\n# 以下是你们DubboServer.xml中配置的需要Export Service，\n# 建议你有几个要Export Service都配置在这里，后面是请求本地的地址\n# 地址格式：dubbo://ip:port，这里需要注意的是，需要修改为自己dubbo服务的端口\ncom.xxxService=dubbo://localhost:20880\n\n```\n\n​\t\t设置启动参数指向该配置文件：\n\n```properties\n# 启动参数：\n-Ddubbo.resolve.file=/C:\\workspace\\dubbo-local-consumer.properties\n```\n\n","source":"_posts/Local-Debug-Dubbo.md","raw":"---\ntitle: 无代码侵入调试dubbo服务\ndate: 2020-06-28 18:58:48\ntags: dubbo\ncategories: \n\t- 编程\n\t- 效率\n\n---\n\n### 1.提供者（Provider-service）\n\n​\tdubbo.xml中添加**register=\"false\"** \n\n```xml\n<dubbo:registry protocol=\"zookeeper\" address=\"${zookeeper.cluster}\" register=\"false\"/>\n```\n\n### 2.消费者（Consumer-service）\n\n​        在本地任意位置新建配置文件:dubbo-local-consumer.properties：\n\n```properties\n# 以下是你们DubboServer.xml中配置的需要Export Service，\n# 建议你有几个要Export Service都配置在这里，后面是请求本地的地址\n# 地址格式：dubbo://ip:port，这里需要注意的是，需要修改为自己dubbo服务的端口\ncom.xxxService=dubbo://localhost:20880\n\n```\n\n​\t\t设置启动参数指向该配置文件：\n\n```properties\n# 启动参数：\n-Ddubbo.resolve.file=/C:\\workspace\\dubbo-local-consumer.properties\n```\n\n","slug":"Local-Debug-Dubbo","published":1,"updated":"2020-07-02T03:33:48.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtt1000fycto0il1c61k","content":"<h3 id=\"1-提供者（Provider-service）\"><a href=\"#1-提供者（Provider-service）\" class=\"headerlink\" title=\"1.提供者（Provider-service）\"></a>1.提供者（Provider-service）</h3><p>​    dubbo.xml中添加<strong>register=”false”</strong> </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"zookeeper\"</span> <span class=\"attr\">address</span>=<span class=\"string\">\"$&#123;zookeeper.cluster&#125;\"</span> <span class=\"attr\">register</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-消费者（Consumer-service）\"><a href=\"#2-消费者（Consumer-service）\" class=\"headerlink\" title=\"2.消费者（Consumer-service）\"></a>2.消费者（Consumer-service）</h3><p>​        在本地任意位置新建配置文件:dubbo-local-consumer.properties：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下是你们DubboServer.xml中配置的需要Export Service，</span></span><br><span class=\"line\"><span class=\"comment\"># 建议你有几个要Export Service都配置在这里，后面是请求本地的地址</span></span><br><span class=\"line\"><span class=\"comment\"># 地址格式：dubbo://ip:port，这里需要注意的是，需要修改为自己dubbo服务的端口</span></span><br><span class=\"line\"><span class=\"meta\">com.xxxService</span>=<span class=\"string\">dubbo://localhost:20880</span></span><br></pre></td></tr></table></figure>\n\n<p>​        设置启动参数指向该配置文件：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动参数：</span></span><br><span class=\"line\"><span class=\"meta\">-Ddubbo.resolve.file</span>=<span class=\"string\">/C:\\workspace\\dubbo-local-consumer.properties</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-提供者（Provider-service）\"><a href=\"#1-提供者（Provider-service）\" class=\"headerlink\" title=\"1.提供者（Provider-service）\"></a>1.提供者（Provider-service）</h3><p>​    dubbo.xml中添加<strong>register=”false”</strong> </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"zookeeper\"</span> <span class=\"attr\">address</span>=<span class=\"string\">\"$&#123;zookeeper.cluster&#125;\"</span> <span class=\"attr\">register</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-消费者（Consumer-service）\"><a href=\"#2-消费者（Consumer-service）\" class=\"headerlink\" title=\"2.消费者（Consumer-service）\"></a>2.消费者（Consumer-service）</h3><p>​        在本地任意位置新建配置文件:dubbo-local-consumer.properties：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下是你们DubboServer.xml中配置的需要Export Service，</span></span><br><span class=\"line\"><span class=\"comment\"># 建议你有几个要Export Service都配置在这里，后面是请求本地的地址</span></span><br><span class=\"line\"><span class=\"comment\"># 地址格式：dubbo://ip:port，这里需要注意的是，需要修改为自己dubbo服务的端口</span></span><br><span class=\"line\"><span class=\"meta\">com.xxxService</span>=<span class=\"string\">dubbo://localhost:20880</span></span><br></pre></td></tr></table></figure>\n\n<p>​        设置启动参数指向该配置文件：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动参数：</span></span><br><span class=\"line\"><span class=\"meta\">-Ddubbo.resolve.file</span>=<span class=\"string\">/C:\\workspace\\dubbo-local-consumer.properties</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"TCP和UDP的区别","date":"2020-07-07T02:17:43.000Z","_content":"\n### UDP简介\n\n> Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。\n\n![UDP报文](/articleImage/2020-07-07/udp.png)\n\nUDP首部由8个字节构成，每个字段都是两个字节。\n\n1、源端口：源端口号，需要对方回信时选用，不需要时置0；\n2、目标端口：目的端口号，在终点交付报文时需要用到；\n3、头部长度：UDP的数据报长度（包含首部和数据），最小值为8字节（只有首部）；\n4、校验和：检测UDP数据在传输中是否出错，有错则丢弃。\n\n<!--more-->\n\n### UDP的特点\n\n- 面向非连接\n\n- 不维护连接状态，支持同时向多个客户端传输相同的消息。\n\n- 数据包报头只有8个字节，额外开销较小。\n\n- 吞吐量只受限于数据生成速率、传输速率以及机器性能。\n\n- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表。\n\n- 面向报文，不对应用程序提交的报文信息进行拆分或者合并。\n\n在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n### UDP与TCP的区别\n\n- TCP是面向连接而UDP是面向非连接。\n\n- 可靠性：TCP是客户端与服务端一对一通过握手实现传输，具有稳定的可靠性，而UDP可能会丢失，不确定有没有被接收。\n\n- 有序性：TCP通过序列号保证了消息的正确性。\n\n- 速度：TCP速度比较慢，因为需要建立连接。\n\n- 量级：TCP是重量级的，而UDP是轻量级的。","source":"_posts/TCP和UDP的区别.md","raw":"---\ntitle: TCP和UDP的区别\ndate: 2020-07-07 10:17:43\ncategories:\n\t- Java面试\n\t- 计算机网络\n\n---\n\n### UDP简介\n\n> Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。\n\n![UDP报文](/articleImage/2020-07-07/udp.png)\n\nUDP首部由8个字节构成，每个字段都是两个字节。\n\n1、源端口：源端口号，需要对方回信时选用，不需要时置0；\n2、目标端口：目的端口号，在终点交付报文时需要用到；\n3、头部长度：UDP的数据报长度（包含首部和数据），最小值为8字节（只有首部）；\n4、校验和：检测UDP数据在传输中是否出错，有错则丢弃。\n\n<!--more-->\n\n### UDP的特点\n\n- 面向非连接\n\n- 不维护连接状态，支持同时向多个客户端传输相同的消息。\n\n- 数据包报头只有8个字节，额外开销较小。\n\n- 吞吐量只受限于数据生成速率、传输速率以及机器性能。\n\n- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表。\n\n- 面向报文，不对应用程序提交的报文信息进行拆分或者合并。\n\n在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n### UDP与TCP的区别\n\n- TCP是面向连接而UDP是面向非连接。\n\n- 可靠性：TCP是客户端与服务端一对一通过握手实现传输，具有稳定的可靠性，而UDP可能会丢失，不确定有没有被接收。\n\n- 有序性：TCP通过序列号保证了消息的正确性。\n\n- 速度：TCP速度比较慢，因为需要建立连接。\n\n- 量级：TCP是重量级的，而UDP是轻量级的。","slug":"TCP和UDP的区别","published":1,"updated":"2020-07-07T03:05:04.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtt4000hyctoadkx484v","content":"<h3 id=\"UDP简介\"><a href=\"#UDP简介\" class=\"headerlink\" title=\"UDP简介\"></a>UDP简介</h3><blockquote>\n<p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。</p>\n</blockquote>\n<p><img src=\"/articleImage/2020-07-07/udp.png\" alt=\"UDP报文\"></p>\n<p>UDP首部由8个字节构成，每个字段都是两个字节。</p>\n<p>1、源端口：源端口号，需要对方回信时选用，不需要时置0；<br>2、目标端口：目的端口号，在终点交付报文时需要用到；<br>3、头部长度：UDP的数据报长度（包含首部和数据），最小值为8字节（只有首部）；<br>4、校验和：检测UDP数据在传输中是否出错，有错则丢弃。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"UDP的特点\"><a href=\"#UDP的特点\" class=\"headerlink\" title=\"UDP的特点\"></a>UDP的特点</h3><ul>\n<li><p>面向非连接</p>\n</li>\n<li><p>不维护连接状态，支持同时向多个客户端传输相同的消息。</p>\n</li>\n<li><p>数据包报头只有8个字节，额外开销较小。</p>\n</li>\n<li><p>吞吐量只受限于数据生成速率、传输速率以及机器性能。</p>\n</li>\n<li><p>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表。</p>\n</li>\n<li><p>面向报文，不对应用程序提交的报文信息进行拆分或者合并。</p>\n</li>\n</ul>\n<p>在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<h3 id=\"UDP与TCP的区别\"><a href=\"#UDP与TCP的区别\" class=\"headerlink\" title=\"UDP与TCP的区别\"></a>UDP与TCP的区别</h3><ul>\n<li><p>TCP是面向连接而UDP是面向非连接。</p>\n</li>\n<li><p>可靠性：TCP是客户端与服务端一对一通过握手实现传输，具有稳定的可靠性，而UDP可能会丢失，不确定有没有被接收。</p>\n</li>\n<li><p>有序性：TCP通过序列号保证了消息的正确性。</p>\n</li>\n<li><p>速度：TCP速度比较慢，因为需要建立连接。</p>\n</li>\n<li><p>量级：TCP是重量级的，而UDP是轻量级的。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"UDP简介\"><a href=\"#UDP简介\" class=\"headerlink\" title=\"UDP简介\"></a>UDP简介</h3><blockquote>\n<p>Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。</p>\n</blockquote>\n<p><img src=\"/articleImage/2020-07-07/udp.png\" alt=\"UDP报文\"></p>\n<p>UDP首部由8个字节构成，每个字段都是两个字节。</p>\n<p>1、源端口：源端口号，需要对方回信时选用，不需要时置0；<br>2、目标端口：目的端口号，在终点交付报文时需要用到；<br>3、头部长度：UDP的数据报长度（包含首部和数据），最小值为8字节（只有首部）；<br>4、校验和：检测UDP数据在传输中是否出错，有错则丢弃。</p>","more":"<h3 id=\"UDP的特点\"><a href=\"#UDP的特点\" class=\"headerlink\" title=\"UDP的特点\"></a>UDP的特点</h3><ul>\n<li><p>面向非连接</p>\n</li>\n<li><p>不维护连接状态，支持同时向多个客户端传输相同的消息。</p>\n</li>\n<li><p>数据包报头只有8个字节，额外开销较小。</p>\n</li>\n<li><p>吞吐量只受限于数据生成速率、传输速率以及机器性能。</p>\n</li>\n<li><p>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表。</p>\n</li>\n<li><p>面向报文，不对应用程序提交的报文信息进行拆分或者合并。</p>\n</li>\n</ul>\n<p>在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<h3 id=\"UDP与TCP的区别\"><a href=\"#UDP与TCP的区别\" class=\"headerlink\" title=\"UDP与TCP的区别\"></a>UDP与TCP的区别</h3><ul>\n<li><p>TCP是面向连接而UDP是面向非连接。</p>\n</li>\n<li><p>可靠性：TCP是客户端与服务端一对一通过握手实现传输，具有稳定的可靠性，而UDP可能会丢失，不确定有没有被接收。</p>\n</li>\n<li><p>有序性：TCP通过序列号保证了消息的正确性。</p>\n</li>\n<li><p>速度：TCP速度比较慢，因为需要建立连接。</p>\n</li>\n<li><p>量级：TCP是重量级的，而UDP是轻量级的。</p>\n</li>\n</ul>"},{"title":"Linux下防御/减轻DDOS攻击","date":"2017-03-03T05:30:03.000Z","_content":"好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。\n登录后台就发现可能是被攻击了，导致被官方限制使用。\n![](/img/articleImg/vpsproblem.jpg)\n<!--more-->\n被莫名的攻击后也是张二和尚摸不着头脑。\n还能咋办叻?Goole~&Baidu~\n然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~\n\n## DDoS deflate介绍\n\n>DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过>netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过\n>预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.\n\n### 如何确认是否受到DDOS攻击？\n\n由于我是直接重装了系统，所以这一步仅供参考\n{% codeblock %}\nnetstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n\n{% endcodeblock %}\n\n据说：执行后，将会显示服务器上所有的每个IP多少个连接数。\n\n### 1.安装DDoS deflate\n{% codeblock %}\nwget http://www.inetbase.com/scripts/ddos/install.sh   //下载DDoS  deflate\nchmod 0700 install.sh    //添加权限\n./install.sh             //执行\n{% endcodeblock %}\n\n### 2.配置DDoS deflate\nDDoS deflate的默认配置位于/usr/local/ddos/ddos.conf\n内容如下\n![](/img/articleImg/ddosconf.png)\n\n查看/usr/local/ddos/ddos.sh文件的第117行\n(vim模式下 跳转命令：行号 即可)\n{% codeblock %}\nnetstat -ntu | awk ‘{print $5}’ | cut -d: -f1 | sort | uniq -c | sort -nr > $BAD_IP_LIST\n{% endcodeblock %}\n修改为以下代码即可！\n{% codeblock %}\nnetstat -ntu | awk ‘{print $5}’ | cut -d: -f1 | sed -n ‘/[0-9]/p’ | sort | uniq -c | sort -nr > $BAD_IP_LIST\n{% endcodeblock %}","source":"_posts/ddos.md","raw":"---\ntitle: Linux下防御/减轻DDOS攻击 \ndate: 2017-03-03 13:30:03\ntags:\n\t- ddos\ncategories:\n\t- 运维\n\t- 安全\n---\n好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。\n登录后台就发现可能是被攻击了，导致被官方限制使用。\n![](/img/articleImg/vpsproblem.jpg)\n<!--more-->\n被莫名的攻击后也是张二和尚摸不着头脑。\n还能咋办叻?Goole~&Baidu~\n然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~\n\n## DDoS deflate介绍\n\n>DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过>netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过\n>预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.\n\n### 如何确认是否受到DDOS攻击？\n\n由于我是直接重装了系统，所以这一步仅供参考\n{% codeblock %}\nnetstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n\n{% endcodeblock %}\n\n据说：执行后，将会显示服务器上所有的每个IP多少个连接数。\n\n### 1.安装DDoS deflate\n{% codeblock %}\nwget http://www.inetbase.com/scripts/ddos/install.sh   //下载DDoS  deflate\nchmod 0700 install.sh    //添加权限\n./install.sh             //执行\n{% endcodeblock %}\n\n### 2.配置DDoS deflate\nDDoS deflate的默认配置位于/usr/local/ddos/ddos.conf\n内容如下\n![](/img/articleImg/ddosconf.png)\n\n查看/usr/local/ddos/ddos.sh文件的第117行\n(vim模式下 跳转命令：行号 即可)\n{% codeblock %}\nnetstat -ntu | awk ‘{print $5}’ | cut -d: -f1 | sort | uniq -c | sort -nr > $BAD_IP_LIST\n{% endcodeblock %}\n修改为以下代码即可！\n{% codeblock %}\nnetstat -ntu | awk ‘{print $5}’ | cut -d: -f1 | sed -n ‘/[0-9]/p’ | sort | uniq -c | sort -nr > $BAD_IP_LIST\n{% endcodeblock %}","slug":"ddos","published":1,"updated":"2020-07-02T03:29:13.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtt6000jyctofo1z3sya","content":"<p>好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。<br>登录后台就发现可能是被攻击了，导致被官方限制使用。<br><img src=\"/img/articleImg/vpsproblem.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>被莫名的攻击后也是张二和尚摸不着头脑。<br>还能咋办叻?Goole<del>&amp;Baidu</del><br>然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~</p>\n<h2 id=\"DDoS-deflate介绍\"><a href=\"#DDoS-deflate介绍\" class=\"headerlink\" title=\"DDoS deflate介绍\"></a>DDoS deflate介绍</h2><blockquote>\n<p>DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过&gt;netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过<br>预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.</p>\n</blockquote>\n<h3 id=\"如何确认是否受到DDOS攻击？\"><a href=\"#如何确认是否受到DDOS攻击？\" class=\"headerlink\" title=\"如何确认是否受到DDOS攻击？\"></a>如何确认是否受到DDOS攻击？</h3><p>由于我是直接重装了系统，所以这一步仅供参考</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntu | awk &#39;&#123;print $5&#125;&#39; | cut -d: -f1 | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure>\n\n<p>据说：执行后，将会显示服务器上所有的每个IP多少个连接数。</p>\n<h3 id=\"1-安装DDoS-deflate\"><a href=\"#1-安装DDoS-deflate\" class=\"headerlink\" title=\"1.安装DDoS deflate\"></a>1.安装DDoS deflate</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;www.inetbase.com&#x2F;scripts&#x2F;ddos&#x2F;install.sh   &#x2F;&#x2F;下载DDoS  deflate</span><br><span class=\"line\">chmod 0700 install.sh    &#x2F;&#x2F;添加权限</span><br><span class=\"line\">.&#x2F;install.sh             &#x2F;&#x2F;执行</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置DDoS-deflate\"><a href=\"#2-配置DDoS-deflate\" class=\"headerlink\" title=\"2.配置DDoS deflate\"></a>2.配置DDoS deflate</h3><p>DDoS deflate的默认配置位于/usr/local/ddos/ddos.conf<br>内容如下<br><img src=\"/img/articleImg/ddosconf.png\" alt=\"\"></p>\n<p>查看/usr/local/ddos/ddos.sh文件的第117行<br>(vim模式下 跳转命令：行号 即可)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST</span><br></pre></td></tr></table></figure>\n<p>修改为以下代码即可！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sed -n ‘&#x2F;[0-9]&#x2F;p’ | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>好久没管我的vps了，直到前天发现vpn居然用不了了，一脸懵逼。<br>登录后台就发现可能是被攻击了，导致被官方限制使用。<br><img src=\"/img/articleImg/vpsproblem.jpg\" alt=\"\"></p>","more":"<p>被莫名的攻击后也是张二和尚摸不着头脑。<br>还能咋办叻?Goole<del>&amp;Baidu</del><br>然后就开始了如下操作，也不知有没有用，O(∩_∩)O哈哈~</p>\n<h2 id=\"DDoS-deflate介绍\"><a href=\"#DDoS-deflate介绍\" class=\"headerlink\" title=\"DDoS deflate介绍\"></a>DDoS deflate介绍</h2><blockquote>\n<p>DDoS deflate是一款免费的用来防御和减轻DDoS攻击的脚本。它通过&gt;netstat监测跟踪创建大量网络连接的IP地址，在检测到某个结点超过<br>预设的限 制时，该程序会通过APF或IPTABLES禁止或阻挡这些IP.</p>\n</blockquote>\n<h3 id=\"如何确认是否受到DDOS攻击？\"><a href=\"#如何确认是否受到DDOS攻击？\" class=\"headerlink\" title=\"如何确认是否受到DDOS攻击？\"></a>如何确认是否受到DDOS攻击？</h3><p>由于我是直接重装了系统，所以这一步仅供参考</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntu | awk &#39;&#123;print $5&#125;&#39; | cut -d: -f1 | sort | uniq -c | sort -n</span><br></pre></td></tr></table></figure>\n\n<p>据说：执行后，将会显示服务器上所有的每个IP多少个连接数。</p>\n<h3 id=\"1-安装DDoS-deflate\"><a href=\"#1-安装DDoS-deflate\" class=\"headerlink\" title=\"1.安装DDoS deflate\"></a>1.安装DDoS deflate</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;www.inetbase.com&#x2F;scripts&#x2F;ddos&#x2F;install.sh   &#x2F;&#x2F;下载DDoS  deflate</span><br><span class=\"line\">chmod 0700 install.sh    &#x2F;&#x2F;添加权限</span><br><span class=\"line\">.&#x2F;install.sh             &#x2F;&#x2F;执行</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置DDoS-deflate\"><a href=\"#2-配置DDoS-deflate\" class=\"headerlink\" title=\"2.配置DDoS deflate\"></a>2.配置DDoS deflate</h3><p>DDoS deflate的默认配置位于/usr/local/ddos/ddos.conf<br>内容如下<br><img src=\"/img/articleImg/ddosconf.png\" alt=\"\"></p>\n<p>查看/usr/local/ddos/ddos.sh文件的第117行<br>(vim模式下 跳转命令：行号 即可)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST</span><br></pre></td></tr></table></figure>\n<p>修改为以下代码即可！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntu | awk ‘&#123;print $5&#125;’ | cut -d: -f1 | sed -n ‘&#x2F;[0-9]&#x2F;p’ | sort | uniq -c | sort -nr &gt; $BAD_IP_LIST</span><br></pre></td></tr></table></figure>"},{"title":"TCP四次挥手","date":"2020-07-03T08:02:35.000Z","_content":"\n“挥手”是为了终止连接，TCP四次挥手的流程图如下：\n\n![TCP Flags](/articleImage/2020-07-03/4.png)\n\n<!--more-->\n\n**第一次挥手：**客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n**第二次挥手**：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n**第三次挥手**：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n**第四次挥手：**客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n常见面试题：\n\n**1.Time-Wait到Closed状态为什么需要等待2MSL(最长报文段生命)**\n确保有足够的时间让对方收到ACK包\n避免新旧连接混淆\n\n**2.为什么需要四次握手才能断开连接**\n因为全双工，发送方和接受方都需要FIN报文和ACK报文\n\n**3.服务器出现大量CLOSE_WAIT状态的原因**\n对方关闭socket连接，我方忙于读或写，没有及时关闭连接\n检查代码，特别是释放资源的代码\n检查配置，特别是处理请求对的线程配置","source":"_posts/TCP四次挥手.md","raw":"---\ntitle: TCP四次挥手\ndate: 2020-07-03 16:02:35\ntags:\ncategories:\n\t- Java面试\n\t- 计算机网络\n---\n\n“挥手”是为了终止连接，TCP四次挥手的流程图如下：\n\n![TCP Flags](/articleImage/2020-07-03/4.png)\n\n<!--more-->\n\n**第一次挥手：**客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n**第二次挥手**：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n**第三次挥手**：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n**第四次挥手：**客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n常见面试题：\n\n**1.Time-Wait到Closed状态为什么需要等待2MSL(最长报文段生命)**\n确保有足够的时间让对方收到ACK包\n避免新旧连接混淆\n\n**2.为什么需要四次握手才能断开连接**\n因为全双工，发送方和接受方都需要FIN报文和ACK报文\n\n**3.服务器出现大量CLOSE_WAIT状态的原因**\n对方关闭socket连接，我方忙于读或写，没有及时关闭连接\n检查代码，特别是释放资源的代码\n检查配置，特别是处理请求对的线程配置","slug":"TCP四次挥手","published":1,"updated":"2020-07-03T10:20:23.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtt8000lycto2o6n3niu","content":"<p>“挥手”是为了终止连接，TCP四次挥手的流程图如下：</p>\n<p><img src=\"/articleImage/2020-07-03/4.png\" alt=\"TCP Flags\"></p>\n<a id=\"more\"></a>\n\n<p><strong>第一次挥手：</strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br><strong>第二次挥手</strong>：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br><strong>第三次挥手</strong>：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br><strong>第四次挥手：</strong>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>\n<p>常见面试题：</p>\n<p><strong>1.Time-Wait到Closed状态为什么需要等待2MSL(最长报文段生命)</strong><br>确保有足够的时间让对方收到ACK包<br>避免新旧连接混淆</p>\n<p><strong>2.为什么需要四次握手才能断开连接</strong><br>因为全双工，发送方和接受方都需要FIN报文和ACK报文</p>\n<p><strong>3.服务器出现大量CLOSE_WAIT状态的原因</strong><br>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<br>检查代码，特别是释放资源的代码<br>检查配置，特别是处理请求对的线程配置</p>\n","site":{"data":{}},"excerpt":"<p>“挥手”是为了终止连接，TCP四次挥手的流程图如下：</p>\n<p><img src=\"/articleImage/2020-07-03/4.png\" alt=\"TCP Flags\"></p>","more":"<p><strong>第一次挥手：</strong>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br><strong>第二次挥手</strong>：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br><strong>第三次挥手</strong>：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br><strong>第四次挥手：</strong>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>\n<p>常见面试题：</p>\n<p><strong>1.Time-Wait到Closed状态为什么需要等待2MSL(最长报文段生命)</strong><br>确保有足够的时间让对方收到ACK包<br>避免新旧连接混淆</p>\n<p><strong>2.为什么需要四次握手才能断开连接</strong><br>因为全双工，发送方和接受方都需要FIN报文和ACK报文</p>\n<p><strong>3.服务器出现大量CLOSE_WAIT状态的原因</strong><br>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<br>检查代码，特别是释放资源的代码<br>检查配置，特别是处理请求对的线程配置</p>"},{"title":"TCP滑动窗口","date":"2020-07-07T03:18:29.000Z","_content":"\n#### 概念\n\nRTT：Round-Trip Time, 即往返时延，指发送一个数据包到收到对应的 ACK, 所花费的时间；\nRTO：Retransmission TimeOut, 即重传时间间隔。\n\n#### 滑动窗口\n\n- 保证 TCP 的可靠性。\n- 保证 TCP 的流控特性。\t\t\n\n在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。\n\n![滑动窗口1](/articleImage/2020-07-07/hdck1.png)\n\n<!--more-->\n\n**1.如何保持有序？**\n\n![滑动窗口2](/articleImage/2020-07-07/3.png)\n\n​\t双方按顺序确认对方已接收的包\n\n**2.如何提高吞吐量？**\n\n​\t![滑动窗口3](/articleImage/2020-07-07/4.png)\n\n​\t同时发送多个包\n\n3.Ack一直未确认如何处理？\n\n​\t超时重传","source":"_posts/TCP滑动窗口.md","raw":"---\ntitle: TCP滑动窗口\ndate: 2020-07-07 11:18:29\ncategories:\n\t- Java面试\n\t- 计算机网络\n\n---\n\n#### 概念\n\nRTT：Round-Trip Time, 即往返时延，指发送一个数据包到收到对应的 ACK, 所花费的时间；\nRTO：Retransmission TimeOut, 即重传时间间隔。\n\n#### 滑动窗口\n\n- 保证 TCP 的可靠性。\n- 保证 TCP 的流控特性。\t\t\n\n在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。\n\n![滑动窗口1](/articleImage/2020-07-07/hdck1.png)\n\n<!--more-->\n\n**1.如何保持有序？**\n\n![滑动窗口2](/articleImage/2020-07-07/3.png)\n\n​\t双方按顺序确认对方已接收的包\n\n**2.如何提高吞吐量？**\n\n​\t![滑动窗口3](/articleImage/2020-07-07/4.png)\n\n​\t同时发送多个包\n\n3.Ack一直未确认如何处理？\n\n​\t超时重传","slug":"TCP滑动窗口","published":1,"updated":"2020-07-07T06:19:01.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttb000nyctog792e9cp","content":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>RTT：Round-Trip Time, 即往返时延，指发送一个数据包到收到对应的 ACK, 所花费的时间；<br>RTO：Retransmission TimeOut, 即重传时间间隔。</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><ul>\n<li>保证 TCP 的可靠性。</li>\n<li>保证 TCP 的流控特性。        </li>\n</ul>\n<p>在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。</p>\n<p><img src=\"/articleImage/2020-07-07/hdck1.png\" alt=\"滑动窗口1\"></p>\n<a id=\"more\"></a>\n\n<p><strong>1.如何保持有序？</strong></p>\n<p><img src=\"/articleImage/2020-07-07/3.png\" alt=\"滑动窗口2\"></p>\n<p>​    双方按顺序确认对方已接收的包</p>\n<p><strong>2.如何提高吞吐量？</strong></p>\n<p>​    <img src=\"/articleImage/2020-07-07/4.png\" alt=\"滑动窗口3\"></p>\n<p>​    同时发送多个包</p>\n<p>3.Ack一直未确认如何处理？</p>\n<p>​    超时重传</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>RTT：Round-Trip Time, 即往返时延，指发送一个数据包到收到对应的 ACK, 所花费的时间；<br>RTO：Retransmission TimeOut, 即重传时间间隔。</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><ul>\n<li>保证 TCP 的可靠性。</li>\n<li>保证 TCP 的流控特性。        </li>\n</ul>\n<p>在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。</p>\n<p><img src=\"/articleImage/2020-07-07/hdck1.png\" alt=\"滑动窗口1\"></p>","more":"<p><strong>1.如何保持有序？</strong></p>\n<p><img src=\"/articleImage/2020-07-07/3.png\" alt=\"滑动窗口2\"></p>\n<p>​    双方按顺序确认对方已接收的包</p>\n<p><strong>2.如何提高吞吐量？</strong></p>\n<p>​    <img src=\"/articleImage/2020-07-07/4.png\" alt=\"滑动窗口3\"></p>\n<p>​    同时发送多个包</p>\n<p>3.Ack一直未确认如何处理？</p>\n<p>​    超时重传</p>"},{"title":"connection holder is null","date":"2017-03-14T02:58:24.000Z","_content":">\"Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证>在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？\"。\n>必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。 \n>而抛出“connection holder is null”异常的原因可能在于： \n>removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000\n\n假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：\n{% codeblock %}\nif(holder ==null)\n    {\n        if (disableError != null) {\n            throw new SQLException(\"connection holder is null\", disableError);\n        } else {\n            throw new SQLException(\"connection holder is null\");\n        }\n    }\n{% endcodeblock %}\n这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。","source":"_posts/druidError.md","raw":"---\ntitle: connection holder is null\ndate: 2017-03-14 10:58:24\ntags:\n\t- druid\ncategories:\n\t- 其他\n---\n>\"Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证>在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？\"。\n>必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。 \n>而抛出“connection holder is null”异常的原因可能在于： \n>removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000\n\n假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：\n{% codeblock %}\nif(holder ==null)\n    {\n        if (disableError != null) {\n            throw new SQLException(\"connection holder is null\", disableError);\n        } else {\n            throw new SQLException(\"connection holder is null\");\n        }\n    }\n{% endcodeblock %}\n这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。","slug":"druidError","published":1,"updated":"2020-07-02T03:31:09.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttc000pycto5n4cf7ff","content":"<blockquote>\n<p>“Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证&gt;在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？”。<br>必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。<br>而抛出“connection holder is null”异常的原因可能在于：<br>removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000</p>\n</blockquote>\n<p>假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(holder &#x3D;&#x3D;null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (disableError !&#x3D; null) &#123;</span><br><span class=\"line\">            throw new SQLException(&quot;connection holder is null&quot;, disableError);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            throw new SQLException(&quot;connection holder is null&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“Druid提供的getConnection()或者getConnection(long maxWaitMillis)方法不能保证&gt;在同一个线程中获取的始终是一个连接，直到显式的将连接关闭吗？”。<br>必须在程序在缓存从Druid中取出的连接才能保证现一个事务在使用的是同一个连接。<br>而抛出“connection holder is null”异常的原因可能在于：<br>removeAbandonedTimeout //关闭长时间不使用的连接超时时间,单位秒,默认30*1000</p>\n</blockquote>\n<p>假设这个参数的值为30分钟,当一个连接在获取后30分钟还没释放,也就是Connection的DruidPooledPreparedStatement对象执行完了executXXX()方法但还未执行close、commit、rollback方法,对应于Connection的running参数的值为false,这时Durid的DestroyConnectionThread线程会自动将该连接回收。当程序要commit()连接时会执行checkState()方法,这个方法会执行以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(holder &#x3D;&#x3D;null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (disableError !&#x3D; null) &#123;</span><br><span class=\"line\">            throw new SQLException(&quot;connection holder is null&quot;, disableError);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            throw new SQLException(&quot;connection holder is null&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码就是我们看到的“connection holder is null”异常的来源，因此，我们需要做的就是根据Druid提供的监控信息（主要看“连接持有时间分布”的值）修改这个参数的值，它的值一定要比最长的连接持有时间还要大。</p>\n"},{"title":"List集合按对象的某个字段去重","date":"2017-05-26T07:37:46.000Z","_content":"思路:\n利用Set(集合)的不可重复性：List-->Set-->List\nSet是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：\n●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。 \n●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。\n<!--more-->\n### 示例代码\nset集合的构造方式列出来了三种:new Comparator; lambda表达式; Comparator.comparing(); \n{% codeblock %}\npublic class CompareTest {\n\n\t\tpublic static void main(String[] args) {\n\t\n\t    \tList<CompanyMsgParam> companyList = new ArrayList<>();\n\t    \tCompanyMsgParam c1 = new CompanyMsgParam(\"2\", \"001\", \"A公司\", \"0\");\n\t    \tCompanyMsgParam c2 = new CompanyMsgParam(\"1\", \"001\", \"B公司\", \"1\");\n\t    \tCompanyMsgParam c3 = new CompanyMsgParam(\"2\", \"002\", \"C公司\", \"2\");\n\t    \tCompanyMsgParam c4 = new CompanyMsgParam(\"1\", \"003\", \"D公司\", \"3\");\n\t    \tcompanyList.add(c1);\n\t    \tcompanyList.add(c2);\n\t    \tcompanyList.add(c3);\n\t    \tcompanyList.add(c4);\n\t//第一种\n\t    \tSet<CompanyMsgParam> set = new TreeSet<CompanyMsgParam>(new Comparator<CompanyMsgParam>() {\n\t        @Override\n\t        public int compare(CompanyMsgParam com1, CompanyMsgParam com2) {\n\t            return com1.getCompanyCode().compareTo(com2.getCompanyCode());\n\t       \t\t}\n\t    \t});\n\t//第二种\n\t    \tSet<CompanyMsgParam> set = new TreeSet<CompanyMsgParam>((com1, com2) -> com1.getCompanyCode().compareTo(com2.getCompanyCode()));\n\t//第三种\n\t    \tSet<CompanyMsgParam> set = new TreeSet<CompanyMsgParam>(Comparator.comparing(CompanyMsgParam::getCompanyCode));\n\t    \tset.addAll(companyList);\n\t\n\t    \tcompanyList = new ArrayList<CompanyMsgParam>(set);\n\t\n\t    \tfor (CompanyMsgParam param : companyList) {\n\t        \tSystem.out.println(param.getCompanyCode());\n\t    \t\t}\n\t\t}\n\t}\n\n{% endcodeblock %}\n### IDEA配置LanguageLevel和JavaCompiler版本的问题\n按个人需要修改下面的配置即可：\n{% codeblock %}\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>2.3.2</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n{% endcodeblock %}","source":"_posts/duplicateRemoval.md","raw":"---\ntitle: List集合按对象的某个字段去重\ndate: 2017-05-26 15:37:46\ntags:\n\t- Java基础\ncategories:\n\t- 编程\n\t- Java\n---\n思路:\n利用Set(集合)的不可重复性：List-->Set-->List\nSet是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：\n●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。 \n●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。\n<!--more-->\n### 示例代码\nset集合的构造方式列出来了三种:new Comparator; lambda表达式; Comparator.comparing(); \n{% codeblock %}\npublic class CompareTest {\n\n\t\tpublic static void main(String[] args) {\n\t\n\t    \tList<CompanyMsgParam> companyList = new ArrayList<>();\n\t    \tCompanyMsgParam c1 = new CompanyMsgParam(\"2\", \"001\", \"A公司\", \"0\");\n\t    \tCompanyMsgParam c2 = new CompanyMsgParam(\"1\", \"001\", \"B公司\", \"1\");\n\t    \tCompanyMsgParam c3 = new CompanyMsgParam(\"2\", \"002\", \"C公司\", \"2\");\n\t    \tCompanyMsgParam c4 = new CompanyMsgParam(\"1\", \"003\", \"D公司\", \"3\");\n\t    \tcompanyList.add(c1);\n\t    \tcompanyList.add(c2);\n\t    \tcompanyList.add(c3);\n\t    \tcompanyList.add(c4);\n\t//第一种\n\t    \tSet<CompanyMsgParam> set = new TreeSet<CompanyMsgParam>(new Comparator<CompanyMsgParam>() {\n\t        @Override\n\t        public int compare(CompanyMsgParam com1, CompanyMsgParam com2) {\n\t            return com1.getCompanyCode().compareTo(com2.getCompanyCode());\n\t       \t\t}\n\t    \t});\n\t//第二种\n\t    \tSet<CompanyMsgParam> set = new TreeSet<CompanyMsgParam>((com1, com2) -> com1.getCompanyCode().compareTo(com2.getCompanyCode()));\n\t//第三种\n\t    \tSet<CompanyMsgParam> set = new TreeSet<CompanyMsgParam>(Comparator.comparing(CompanyMsgParam::getCompanyCode));\n\t    \tset.addAll(companyList);\n\t\n\t    \tcompanyList = new ArrayList<CompanyMsgParam>(set);\n\t\n\t    \tfor (CompanyMsgParam param : companyList) {\n\t        \tSystem.out.println(param.getCompanyCode());\n\t    \t\t}\n\t\t}\n\t}\n\n{% endcodeblock %}\n### IDEA配置LanguageLevel和JavaCompiler版本的问题\n按个人需要修改下面的配置即可：\n{% codeblock %}\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>2.3.2</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n{% endcodeblock %}","slug":"duplicateRemoval","published":1,"updated":"2020-07-02T03:33:18.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtte000tycto64mlfyfn","content":"<p>思路:<br>利用Set(集合)的不可重复性：List–&gt;Set–&gt;List<br>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：<br>●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。<br>●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</p>\n<a id=\"more\"></a>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>set集合的构造方式列出来了三种:new Comparator; lambda表达式; Comparator.comparing(); </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CompareTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    \tList&lt;CompanyMsgParam&gt; companyList &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t    \tCompanyMsgParam c1 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;001&quot;, &quot;A公司&quot;, &quot;0&quot;);</span><br><span class=\"line\">\t    \tCompanyMsgParam c2 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;001&quot;, &quot;B公司&quot;, &quot;1&quot;);</span><br><span class=\"line\">\t    \tCompanyMsgParam c3 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;002&quot;, &quot;C公司&quot;, &quot;2&quot;);</span><br><span class=\"line\">\t    \tCompanyMsgParam c4 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;003&quot;, &quot;D公司&quot;, &quot;3&quot;);</span><br><span class=\"line\">\t    \tcompanyList.add(c1);</span><br><span class=\"line\">\t    \tcompanyList.add(c2);</span><br><span class=\"line\">\t    \tcompanyList.add(c3);</span><br><span class=\"line\">\t    \tcompanyList.add(c4);</span><br><span class=\"line\">\t&#x2F;&#x2F;第一种</span><br><span class=\"line\">\t    \tSet&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(new Comparator&lt;CompanyMsgParam&gt;() &#123;</span><br><span class=\"line\">\t        @Override</span><br><span class=\"line\">\t        public int compare(CompanyMsgParam com1, CompanyMsgParam com2) &#123;</span><br><span class=\"line\">\t            return com1.getCompanyCode().compareTo(com2.getCompanyCode());</span><br><span class=\"line\">\t       \t\t&#125;</span><br><span class=\"line\">\t    \t&#125;);</span><br><span class=\"line\">\t&#x2F;&#x2F;第二种</span><br><span class=\"line\">\t    \tSet&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;((com1, com2) -&gt; com1.getCompanyCode().compareTo(com2.getCompanyCode()));</span><br><span class=\"line\">\t&#x2F;&#x2F;第三种</span><br><span class=\"line\">\t    \tSet&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(Comparator.comparing(CompanyMsgParam::getCompanyCode));</span><br><span class=\"line\">\t    \tset.addAll(companyList);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    \tcompanyList &#x3D; new ArrayList&lt;CompanyMsgParam&gt;(set);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    \tfor (CompanyMsgParam param : companyList) &#123;</span><br><span class=\"line\">\t        \tSystem.out.println(param.getCompanyCode());</span><br><span class=\"line\">\t    \t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"IDEA配置LanguageLevel和JavaCompiler版本的问题\"><a href=\"#IDEA配置LanguageLevel和JavaCompiler版本的问题\" class=\"headerlink\" title=\"IDEA配置LanguageLevel和JavaCompiler版本的问题\"></a>IDEA配置LanguageLevel和JavaCompiler版本的问题</h3><p>按个人需要修改下面的配置即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class=\"line\">            &lt;configuration&gt;</span><br><span class=\"line\">                &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class=\"line\">                &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class=\"line\">            &lt;&#x2F;configuration&gt;</span><br><span class=\"line\">        &lt;&#x2F;plugin&gt;</span><br><span class=\"line\">    &lt;&#x2F;plugins&gt;</span><br><span class=\"line\">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>思路:<br>利用Set(集合)的不可重复性：List–&gt;Set–&gt;List<br>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：<br>●HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。<br>●TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</p>","more":"<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>set集合的构造方式列出来了三种:new Comparator; lambda表达式; Comparator.comparing(); </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CompareTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    \tList&lt;CompanyMsgParam&gt; companyList &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t    \tCompanyMsgParam c1 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;001&quot;, &quot;A公司&quot;, &quot;0&quot;);</span><br><span class=\"line\">\t    \tCompanyMsgParam c2 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;001&quot;, &quot;B公司&quot;, &quot;1&quot;);</span><br><span class=\"line\">\t    \tCompanyMsgParam c3 &#x3D; new CompanyMsgParam(&quot;2&quot;, &quot;002&quot;, &quot;C公司&quot;, &quot;2&quot;);</span><br><span class=\"line\">\t    \tCompanyMsgParam c4 &#x3D; new CompanyMsgParam(&quot;1&quot;, &quot;003&quot;, &quot;D公司&quot;, &quot;3&quot;);</span><br><span class=\"line\">\t    \tcompanyList.add(c1);</span><br><span class=\"line\">\t    \tcompanyList.add(c2);</span><br><span class=\"line\">\t    \tcompanyList.add(c3);</span><br><span class=\"line\">\t    \tcompanyList.add(c4);</span><br><span class=\"line\">\t&#x2F;&#x2F;第一种</span><br><span class=\"line\">\t    \tSet&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(new Comparator&lt;CompanyMsgParam&gt;() &#123;</span><br><span class=\"line\">\t        @Override</span><br><span class=\"line\">\t        public int compare(CompanyMsgParam com1, CompanyMsgParam com2) &#123;</span><br><span class=\"line\">\t            return com1.getCompanyCode().compareTo(com2.getCompanyCode());</span><br><span class=\"line\">\t       \t\t&#125;</span><br><span class=\"line\">\t    \t&#125;);</span><br><span class=\"line\">\t&#x2F;&#x2F;第二种</span><br><span class=\"line\">\t    \tSet&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;((com1, com2) -&gt; com1.getCompanyCode().compareTo(com2.getCompanyCode()));</span><br><span class=\"line\">\t&#x2F;&#x2F;第三种</span><br><span class=\"line\">\t    \tSet&lt;CompanyMsgParam&gt; set &#x3D; new TreeSet&lt;CompanyMsgParam&gt;(Comparator.comparing(CompanyMsgParam::getCompanyCode));</span><br><span class=\"line\">\t    \tset.addAll(companyList);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    \tcompanyList &#x3D; new ArrayList&lt;CompanyMsgParam&gt;(set);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    \tfor (CompanyMsgParam param : companyList) &#123;</span><br><span class=\"line\">\t        \tSystem.out.println(param.getCompanyCode());</span><br><span class=\"line\">\t    \t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"IDEA配置LanguageLevel和JavaCompiler版本的问题\"><a href=\"#IDEA配置LanguageLevel和JavaCompiler版本的问题\" class=\"headerlink\" title=\"IDEA配置LanguageLevel和JavaCompiler版本的问题\"></a>IDEA配置LanguageLevel和JavaCompiler版本的问题</h3><p>按个人需要修改下面的配置即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class=\"line\">            &lt;configuration&gt;</span><br><span class=\"line\">                &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class=\"line\">                &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class=\"line\">            &lt;&#x2F;configuration&gt;</span><br><span class=\"line\">        &lt;&#x2F;plugin&gt;</span><br><span class=\"line\">    &lt;&#x2F;plugins&gt;</span><br><span class=\"line\">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>"},{"title":"javaMail发送邮件","date":"2017-05-25T06:39:47.000Z","_content":">使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..\n\n<!--more-->\t\n### 部分代码\n{% codeblock %}\n\t/**\n\t * 发送邮件\n\t * \n\t * @param toAddress\t\t: 收件人邮箱\n\t * @param mailSubject\t: 邮件主题\n\t * @param mailBody\t\t: 邮件正文\n\t * @param mailBodyIsHtml: 邮件正文格式,true:HTML格式;false:文本格式\n\t * //@param inLineFile\t: 内嵌文件\n\t * @param attachments\t: 附件\n\t */\n\tpublic static boolean sendMail (String toAddress, String mailSubject, String mailBody, \n\t\t\tboolean mailBodyIsHtml, File[] attachments){\n        try {\n\t\t\t// 创建邮件发送类 JavaMailSender (用于发送多元化邮件，包括附件，图片，html 等    )\n        \tJavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n        \tmailSender.setHost(host); \t\t\t// 设置邮件服务主机    \n        \tmailSender.setUsername(username); \t// 发送者邮箱的用户名\n        \tmailSender.setPassword(password); \t// 发送者邮箱的密码\n        \t\n\t\t\t//配置文件，用于实例化java.mail.session    \n\t\t\tProperties pro = new Properties();\n\t\t\tpro.put(\"mail.smtp.auth\", \"true\");\t\t\n\t\t\tpro.put(\"mail.smtp.socketFactory.port\", port);\n\t\t\tpro.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\t\t\tpro.put(\"mail.smtp.starttls.enable\", \"true\");\n\t\t\tmailSender.setJavaMailProperties(pro);\n\t\n\t\t\t//创建多元化邮件 (创建 mimeMessage 帮助类，用于封装信息至 mimeMessage)\n\t\t\tMimeMessage mimeMessage = mailSender.createMimeMessage();\n\t\t\tMimeMessageHelper helper = new MimeMessageHelper(mimeMessage, ArrayUtils.isNotEmpty(attachments), \"UTF-8\");\n\t\t\t\n\t\t\thelper.setFrom(sendFrom, sendNick);\n\t\t\thelper.setTo(toAddress);\n\t\n\t\t\thelper.setSubject(mailSubject);\n\t\t\thelper.setText(mailBody, mailBodyIsHtml); \n\t\t\t\n\t\t\t// 添加内嵌文件，第1个参数为cid标识这个文件,第2个参数为资源\n\t\t\t//helper.addInline(MimeUtility.encodeText(inLineFile.getName()), inLineFile);\t\n\t\t\t\n\t\t\t// 添加附件    \n\t\t\tif (ArrayUtils.isNotEmpty(attachments)) {\n\t\t\t\tfor (File file : attachments) {\n\t\t\t\t\thelper.addAttachment(MimeUtility.encodeText(file.getName()), file);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmailSender.send(mimeMessage);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n{% endcodeblock %}\n\n### 运行报错：\n>“Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 550 User has no permission.....”\n\n### 解决\n网易163邮箱 \"设置--POP3/SMTP/IMAP\" 中 \"客户端授权\" 未开启。\n开启授权码后，它将代替邮箱密码在客户端使用。\n![](/img/articleImg/163sqm.png)\n\n\n\n\n","source":"_posts/javaMail.md","raw":"---\ntitle: javaMail发送邮件\ndate: 2017-05-25 14:39:47\ntags:\n\t- JavaMail\ncategories:\n\t- 编程\n\t- Java\n---\n>使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..\n\n<!--more-->\t\n### 部分代码\n{% codeblock %}\n\t/**\n\t * 发送邮件\n\t * \n\t * @param toAddress\t\t: 收件人邮箱\n\t * @param mailSubject\t: 邮件主题\n\t * @param mailBody\t\t: 邮件正文\n\t * @param mailBodyIsHtml: 邮件正文格式,true:HTML格式;false:文本格式\n\t * //@param inLineFile\t: 内嵌文件\n\t * @param attachments\t: 附件\n\t */\n\tpublic static boolean sendMail (String toAddress, String mailSubject, String mailBody, \n\t\t\tboolean mailBodyIsHtml, File[] attachments){\n        try {\n\t\t\t// 创建邮件发送类 JavaMailSender (用于发送多元化邮件，包括附件，图片，html 等    )\n        \tJavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n        \tmailSender.setHost(host); \t\t\t// 设置邮件服务主机    \n        \tmailSender.setUsername(username); \t// 发送者邮箱的用户名\n        \tmailSender.setPassword(password); \t// 发送者邮箱的密码\n        \t\n\t\t\t//配置文件，用于实例化java.mail.session    \n\t\t\tProperties pro = new Properties();\n\t\t\tpro.put(\"mail.smtp.auth\", \"true\");\t\t\n\t\t\tpro.put(\"mail.smtp.socketFactory.port\", port);\n\t\t\tpro.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\t\t\tpro.put(\"mail.smtp.starttls.enable\", \"true\");\n\t\t\tmailSender.setJavaMailProperties(pro);\n\t\n\t\t\t//创建多元化邮件 (创建 mimeMessage 帮助类，用于封装信息至 mimeMessage)\n\t\t\tMimeMessage mimeMessage = mailSender.createMimeMessage();\n\t\t\tMimeMessageHelper helper = new MimeMessageHelper(mimeMessage, ArrayUtils.isNotEmpty(attachments), \"UTF-8\");\n\t\t\t\n\t\t\thelper.setFrom(sendFrom, sendNick);\n\t\t\thelper.setTo(toAddress);\n\t\n\t\t\thelper.setSubject(mailSubject);\n\t\t\thelper.setText(mailBody, mailBodyIsHtml); \n\t\t\t\n\t\t\t// 添加内嵌文件，第1个参数为cid标识这个文件,第2个参数为资源\n\t\t\t//helper.addInline(MimeUtility.encodeText(inLineFile.getName()), inLineFile);\t\n\t\t\t\n\t\t\t// 添加附件    \n\t\t\tif (ArrayUtils.isNotEmpty(attachments)) {\n\t\t\t\tfor (File file : attachments) {\n\t\t\t\t\thelper.addAttachment(MimeUtility.encodeText(file.getName()), file);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmailSender.send(mimeMessage);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n{% endcodeblock %}\n\n### 运行报错：\n>“Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 550 User has no permission.....”\n\n### 解决\n网易163邮箱 \"设置--POP3/SMTP/IMAP\" 中 \"客户端授权\" 未开启。\n开启授权码后，它将代替邮箱密码在客户端使用。\n![](/img/articleImg/163sqm.png)\n\n\n\n\n","slug":"javaMail","published":1,"updated":"2020-07-02T03:39:46.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttg000wycto5xjn0o6v","content":"<blockquote>\n<p>使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..</p>\n</blockquote>\n<a id=\"more\"></a>    \n<h3 id=\"部分代码\"><a href=\"#部分代码\" class=\"headerlink\" title=\"部分代码\"></a>部分代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 发送邮件</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param toAddress\t\t: 收件人邮箱</span><br><span class=\"line\"> * @param mailSubject\t: 邮件主题</span><br><span class=\"line\"> * @param mailBody\t\t: 邮件正文</span><br><span class=\"line\"> * @param mailBodyIsHtml: 邮件正文格式,true:HTML格式;false:文本格式</span><br><span class=\"line\"> * &#x2F;&#x2F;@param inLineFile\t: 内嵌文件</span><br><span class=\"line\"> * @param attachments\t: 附件</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public static boolean sendMail (String toAddress, String mailSubject, String mailBody, </span><br><span class=\"line\">\t\tboolean mailBodyIsHtml, File[] attachments)&#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 创建邮件发送类 JavaMailSender (用于发送多元化邮件，包括附件，图片，html 等    )</span><br><span class=\"line\">       \tJavaMailSenderImpl mailSender &#x3D; new JavaMailSenderImpl();</span><br><span class=\"line\">       \tmailSender.setHost(host); \t\t\t&#x2F;&#x2F; 设置邮件服务主机    </span><br><span class=\"line\">       \tmailSender.setUsername(username); \t&#x2F;&#x2F; 发送者邮箱的用户名</span><br><span class=\"line\">       \tmailSender.setPassword(password); \t&#x2F;&#x2F; 发送者邮箱的密码</span><br><span class=\"line\">       \t</span><br><span class=\"line\">\t\t&#x2F;&#x2F;配置文件，用于实例化java.mail.session    </span><br><span class=\"line\">\t\tProperties pro &#x3D; new Properties();</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);\t\t</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.socketFactory.port&quot;, port);</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;);</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);</span><br><span class=\"line\">\t\tmailSender.setJavaMailProperties(pro);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F;创建多元化邮件 (创建 mimeMessage 帮助类，用于封装信息至 mimeMessage)</span><br><span class=\"line\">\t\tMimeMessage mimeMessage &#x3D; mailSender.createMimeMessage();</span><br><span class=\"line\">\t\tMimeMessageHelper helper &#x3D; new MimeMessageHelper(mimeMessage, ArrayUtils.isNotEmpty(attachments), &quot;UTF-8&quot;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\thelper.setFrom(sendFrom, sendNick);</span><br><span class=\"line\">\t\thelper.setTo(toAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thelper.setSubject(mailSubject);</span><br><span class=\"line\">\t\thelper.setText(mailBody, mailBodyIsHtml); </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 添加内嵌文件，第1个参数为cid标识这个文件,第2个参数为资源</span><br><span class=\"line\">\t\t&#x2F;&#x2F;helper.addInline(MimeUtility.encodeText(inLineFile.getName()), inLineFile);\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 添加附件    </span><br><span class=\"line\">\t\tif (ArrayUtils.isNotEmpty(attachments)) &#123;</span><br><span class=\"line\">\t\t\tfor (File file : attachments) &#123;</span><br><span class=\"line\">\t\t\t\thelper.addAttachment(MimeUtility.encodeText(file.getName()), file);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmailSender.send(mimeMessage);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行报错：\"><a href=\"#运行报错：\" class=\"headerlink\" title=\"运行报错：\"></a>运行报错：</h3><blockquote>\n<p>“Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 550 User has no permission…..”</p>\n</blockquote>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>网易163邮箱 “设置–POP3/SMTP/IMAP” 中 “客户端授权” 未开启。<br>开启授权码后，它将代替邮箱密码在客户端使用。<br><img src=\"/img/articleImg/163sqm.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>使用163邮箱作为邮件测试时遇到身份验证不通过的问题,在此略做记录..</p>\n</blockquote>","more":"<h3 id=\"部分代码\"><a href=\"#部分代码\" class=\"headerlink\" title=\"部分代码\"></a>部分代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 发送邮件</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param toAddress\t\t: 收件人邮箱</span><br><span class=\"line\"> * @param mailSubject\t: 邮件主题</span><br><span class=\"line\"> * @param mailBody\t\t: 邮件正文</span><br><span class=\"line\"> * @param mailBodyIsHtml: 邮件正文格式,true:HTML格式;false:文本格式</span><br><span class=\"line\"> * &#x2F;&#x2F;@param inLineFile\t: 内嵌文件</span><br><span class=\"line\"> * @param attachments\t: 附件</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public static boolean sendMail (String toAddress, String mailSubject, String mailBody, </span><br><span class=\"line\">\t\tboolean mailBodyIsHtml, File[] attachments)&#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 创建邮件发送类 JavaMailSender (用于发送多元化邮件，包括附件，图片，html 等    )</span><br><span class=\"line\">       \tJavaMailSenderImpl mailSender &#x3D; new JavaMailSenderImpl();</span><br><span class=\"line\">       \tmailSender.setHost(host); \t\t\t&#x2F;&#x2F; 设置邮件服务主机    </span><br><span class=\"line\">       \tmailSender.setUsername(username); \t&#x2F;&#x2F; 发送者邮箱的用户名</span><br><span class=\"line\">       \tmailSender.setPassword(password); \t&#x2F;&#x2F; 发送者邮箱的密码</span><br><span class=\"line\">       \t</span><br><span class=\"line\">\t\t&#x2F;&#x2F;配置文件，用于实例化java.mail.session    </span><br><span class=\"line\">\t\tProperties pro &#x3D; new Properties();</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);\t\t</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.socketFactory.port&quot;, port);</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;);</span><br><span class=\"line\">\t\tpro.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);</span><br><span class=\"line\">\t\tmailSender.setJavaMailProperties(pro);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F;创建多元化邮件 (创建 mimeMessage 帮助类，用于封装信息至 mimeMessage)</span><br><span class=\"line\">\t\tMimeMessage mimeMessage &#x3D; mailSender.createMimeMessage();</span><br><span class=\"line\">\t\tMimeMessageHelper helper &#x3D; new MimeMessageHelper(mimeMessage, ArrayUtils.isNotEmpty(attachments), &quot;UTF-8&quot;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\thelper.setFrom(sendFrom, sendNick);</span><br><span class=\"line\">\t\thelper.setTo(toAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\thelper.setSubject(mailSubject);</span><br><span class=\"line\">\t\thelper.setText(mailBody, mailBodyIsHtml); </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 添加内嵌文件，第1个参数为cid标识这个文件,第2个参数为资源</span><br><span class=\"line\">\t\t&#x2F;&#x2F;helper.addInline(MimeUtility.encodeText(inLineFile.getName()), inLineFile);\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 添加附件    </span><br><span class=\"line\">\t\tif (ArrayUtils.isNotEmpty(attachments)) &#123;</span><br><span class=\"line\">\t\t\tfor (File file : attachments) &#123;</span><br><span class=\"line\">\t\t\t\thelper.addAttachment(MimeUtility.encodeText(file.getName()), file);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmailSender.send(mimeMessage);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行报错：\"><a href=\"#运行报错：\" class=\"headerlink\" title=\"运行报错：\"></a>运行报错：</h3><blockquote>\n<p>“Authentication failed; nested exception is javax.mail.AuthenticationFailedException: 550 User has no permission…..”</p>\n</blockquote>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>网易163邮箱 “设置–POP3/SMTP/IMAP” 中 “客户端授权” 未开启。<br>开启授权码后，它将代替邮箱密码在客户端使用。<br><img src=\"/img/articleImg/163sqm.png\" alt=\"\"></p>"},{"title":"Map按值排序","date":"2017-03-15T05:37:37.000Z","_content":"### Map按值排序\n问题描述如下：\n>现有Map<String,String>结构的数据，需要对其中包含的date值按降序排列输出\n>直观了解：\n>{\n>\"zhanshan\" :\"{\"date\":\"2010-03-09 17:52:49:074\",\"age\":\"21\"},\n>\"lisi\" :\"{\"date\":\"2015-01-09 10:52:49:088\",\"age\":\"19\"},\n>\"zhaowu\" :\"{\"date\":\"2016-06-01 17:52:49:574\",\"age\":\"30\"}\n>}\n>注：此Map的值也为String类型\n\n程序代码如下：\n<!--more-->\n{% codeblock %}\npublic Object MapSortTest(Map<String, String> map) {\n\n\tList<Map<String,String>> resList=new ArrayList<>();\n\t  if(!MapUtils.isEmpty(map)){\n\t\n\t//取Map映射集，遍历时可以getKey()，getValue()\n\t    List<Map.Entry<String,String>> entryList=new ArrayList<Map.Entry<String,String>>(map.entrySet());\n\t//自定义比较器\n\t    Collections.sort(entryList, new Comparator<Map.Entry<String, String>>(){\n\t        @Override\n\t        public int compare(Map.Entry<String, String> entry1, Map.Entry<String, String> entry2) {\n\t\n\t             String str1=entry1.getValue();\n\t             String str2=entry2.getValue();\n\t\t//切割截取date的值，subString前闭后开[)\n\t             String date1=str1.substring(str1.indexOf(\":\")+2,str1.indexOf(\",\")-1);\n\t             String date2=str2.substring(str2.indexOf(\":\")+2,str2.indexOf(\",\")-1);\n\t               try {\n\t                  Date d1=DateUtils.parseDate(date1,\"yyyy-MM-dd HH:mm:ss:SSS\");\n\t                  Date d2=DateUtils.parseDate(date2,\"yyyy-MM-dd HH:mm:ss:SSS\");\n\t\t\t//日期降序\n\t                  return d2.compareTo(d1);\n\t                } catch (ParseException e) {\n\t                    e.printStackTrace();\n\t                    return 0;\n\t                }\n\t            }\n\t        });\n\t     //遍历排序后的映射集，封装返回\n\t        Iterator<Map.Entry<String,String>> iter=entryList.iterator();\n\t        Map.Entry<String,String> temEntry =null;\n\t        while (iter.hasNext()){\n\t            Map<String,String> sortedMap = new LinkedHashMap<String,String>();\n\t            temEntry=iter.next();\n\t            sortedMap.put(\"type\",temEntry.getKey());\n\t            sortedMap.put(\"message\",temEntry.getValue());\n\t            resList.add(sortedMap);\n\t        }\n\t    }\n\t    return resList;\n\t}\n\n{% endcodeblock %}\n说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。","source":"_posts/mapSort.md","raw":"---\ntitle: Map按值排序\ndate: 2017-03-15 13:37:37\ntags: \n\t- Java基础\ncategories:\n\t- 编程\n\t- Java\n---\n### Map按值排序\n问题描述如下：\n>现有Map<String,String>结构的数据，需要对其中包含的date值按降序排列输出\n>直观了解：\n>{\n>\"zhanshan\" :\"{\"date\":\"2010-03-09 17:52:49:074\",\"age\":\"21\"},\n>\"lisi\" :\"{\"date\":\"2015-01-09 10:52:49:088\",\"age\":\"19\"},\n>\"zhaowu\" :\"{\"date\":\"2016-06-01 17:52:49:574\",\"age\":\"30\"}\n>}\n>注：此Map的值也为String类型\n\n程序代码如下：\n<!--more-->\n{% codeblock %}\npublic Object MapSortTest(Map<String, String> map) {\n\n\tList<Map<String,String>> resList=new ArrayList<>();\n\t  if(!MapUtils.isEmpty(map)){\n\t\n\t//取Map映射集，遍历时可以getKey()，getValue()\n\t    List<Map.Entry<String,String>> entryList=new ArrayList<Map.Entry<String,String>>(map.entrySet());\n\t//自定义比较器\n\t    Collections.sort(entryList, new Comparator<Map.Entry<String, String>>(){\n\t        @Override\n\t        public int compare(Map.Entry<String, String> entry1, Map.Entry<String, String> entry2) {\n\t\n\t             String str1=entry1.getValue();\n\t             String str2=entry2.getValue();\n\t\t//切割截取date的值，subString前闭后开[)\n\t             String date1=str1.substring(str1.indexOf(\":\")+2,str1.indexOf(\",\")-1);\n\t             String date2=str2.substring(str2.indexOf(\":\")+2,str2.indexOf(\",\")-1);\n\t               try {\n\t                  Date d1=DateUtils.parseDate(date1,\"yyyy-MM-dd HH:mm:ss:SSS\");\n\t                  Date d2=DateUtils.parseDate(date2,\"yyyy-MM-dd HH:mm:ss:SSS\");\n\t\t\t//日期降序\n\t                  return d2.compareTo(d1);\n\t                } catch (ParseException e) {\n\t                    e.printStackTrace();\n\t                    return 0;\n\t                }\n\t            }\n\t        });\n\t     //遍历排序后的映射集，封装返回\n\t        Iterator<Map.Entry<String,String>> iter=entryList.iterator();\n\t        Map.Entry<String,String> temEntry =null;\n\t        while (iter.hasNext()){\n\t            Map<String,String> sortedMap = new LinkedHashMap<String,String>();\n\t            temEntry=iter.next();\n\t            sortedMap.put(\"type\",temEntry.getKey());\n\t            sortedMap.put(\"message\",temEntry.getValue());\n\t            resList.add(sortedMap);\n\t        }\n\t    }\n\t    return resList;\n\t}\n\n{% endcodeblock %}\n说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。","slug":"mapSort","published":1,"updated":"2020-07-02T03:34:11.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttj0010yctoahem0yiy","content":"<h3 id=\"Map按值排序\"><a href=\"#Map按值排序\" class=\"headerlink\" title=\"Map按值排序\"></a>Map按值排序</h3><p>问题描述如下：</p>\n<blockquote>\n<p>现有Map&lt;String,String&gt;结构的数据，需要对其中包含的date值按降序排列输出<br>直观了解：<br>{<br>“zhanshan” :”{“date”:”2010-03-09 17:52:49:074”,”age”:”21”},<br>“lisi” :”{“date”:”2015-01-09 10:52:49:088”,”age”:”19”},<br>“zhaowu” :”{“date”:”2016-06-01 17:52:49:574”,”age”:”30”}<br>}<br>注：此Map的值也为String类型</p>\n</blockquote>\n<p>程序代码如下：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object MapSortTest(Map&lt;String, String&gt; map) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tList&lt;Map&lt;String,String&gt;&gt; resList&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t  if(!MapUtils.isEmpty(map))&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;取Map映射集，遍历时可以getKey()，getValue()</span><br><span class=\"line\">\t    List&lt;Map.Entry&lt;String,String&gt;&gt; entryList&#x3D;new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());</span><br><span class=\"line\">\t&#x2F;&#x2F;自定义比较器</span><br><span class=\"line\">\t    Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;()&#123;</span><br><span class=\"line\">\t        @Override</span><br><span class=\"line\">\t        public int compare(Map.Entry&lt;String, String&gt; entry1, Map.Entry&lt;String, String&gt; entry2) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t             String str1&#x3D;entry1.getValue();</span><br><span class=\"line\">\t             String str2&#x3D;entry2.getValue();</span><br><span class=\"line\">\t\t&#x2F;&#x2F;切割截取date的值，subString前闭后开[)</span><br><span class=\"line\">\t             String date1&#x3D;str1.substring(str1.indexOf(&quot;:&quot;)+2,str1.indexOf(&quot;,&quot;)-1);</span><br><span class=\"line\">\t             String date2&#x3D;str2.substring(str2.indexOf(&quot;:&quot;)+2,str2.indexOf(&quot;,&quot;)-1);</span><br><span class=\"line\">\t               try &#123;</span><br><span class=\"line\">\t                  Date d1&#x3D;DateUtils.parseDate(date1,&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);</span><br><span class=\"line\">\t                  Date d2&#x3D;DateUtils.parseDate(date2,&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;日期降序</span><br><span class=\"line\">\t                  return d2.compareTo(d1);</span><br><span class=\"line\">\t                &#125; catch (ParseException e) &#123;</span><br><span class=\"line\">\t                    e.printStackTrace();</span><br><span class=\"line\">\t                    return 0;</span><br><span class=\"line\">\t                &#125;</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;);</span><br><span class=\"line\">\t     &#x2F;&#x2F;遍历排序后的映射集，封装返回</span><br><span class=\"line\">\t        Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter&#x3D;entryList.iterator();</span><br><span class=\"line\">\t        Map.Entry&lt;String,String&gt; temEntry &#x3D;null;</span><br><span class=\"line\">\t        while (iter.hasNext())&#123;</span><br><span class=\"line\">\t            Map&lt;String,String&gt; sortedMap &#x3D; new LinkedHashMap&lt;String,String&gt;();</span><br><span class=\"line\">\t            temEntry&#x3D;iter.next();</span><br><span class=\"line\">\t            sortedMap.put(&quot;type&quot;,temEntry.getKey());</span><br><span class=\"line\">\t            sortedMap.put(&quot;message&quot;,temEntry.getValue());</span><br><span class=\"line\">\t            resList.add(sortedMap);</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    return resList;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Map按值排序\"><a href=\"#Map按值排序\" class=\"headerlink\" title=\"Map按值排序\"></a>Map按值排序</h3><p>问题描述如下：</p>\n<blockquote>\n<p>现有Map&lt;String,String&gt;结构的数据，需要对其中包含的date值按降序排列输出<br>直观了解：<br>{<br>“zhanshan” :”{“date”:”2010-03-09 17:52:49:074”,”age”:”21”},<br>“lisi” :”{“date”:”2015-01-09 10:52:49:088”,”age”:”19”},<br>“zhaowu” :”{“date”:”2016-06-01 17:52:49:574”,”age”:”30”}<br>}<br>注：此Map的值也为String类型</p>\n</blockquote>\n<p>程序代码如下：</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Object MapSortTest(Map&lt;String, String&gt; map) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tList&lt;Map&lt;String,String&gt;&gt; resList&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t  if(!MapUtils.isEmpty(map))&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;取Map映射集，遍历时可以getKey()，getValue()</span><br><span class=\"line\">\t    List&lt;Map.Entry&lt;String,String&gt;&gt; entryList&#x3D;new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());</span><br><span class=\"line\">\t&#x2F;&#x2F;自定义比较器</span><br><span class=\"line\">\t    Collections.sort(entryList, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;()&#123;</span><br><span class=\"line\">\t        @Override</span><br><span class=\"line\">\t        public int compare(Map.Entry&lt;String, String&gt; entry1, Map.Entry&lt;String, String&gt; entry2) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t             String str1&#x3D;entry1.getValue();</span><br><span class=\"line\">\t             String str2&#x3D;entry2.getValue();</span><br><span class=\"line\">\t\t&#x2F;&#x2F;切割截取date的值，subString前闭后开[)</span><br><span class=\"line\">\t             String date1&#x3D;str1.substring(str1.indexOf(&quot;:&quot;)+2,str1.indexOf(&quot;,&quot;)-1);</span><br><span class=\"line\">\t             String date2&#x3D;str2.substring(str2.indexOf(&quot;:&quot;)+2,str2.indexOf(&quot;,&quot;)-1);</span><br><span class=\"line\">\t               try &#123;</span><br><span class=\"line\">\t                  Date d1&#x3D;DateUtils.parseDate(date1,&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);</span><br><span class=\"line\">\t                  Date d2&#x3D;DateUtils.parseDate(date2,&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);</span><br><span class=\"line\">\t\t\t&#x2F;&#x2F;日期降序</span><br><span class=\"line\">\t                  return d2.compareTo(d1);</span><br><span class=\"line\">\t                &#125; catch (ParseException e) &#123;</span><br><span class=\"line\">\t                    e.printStackTrace();</span><br><span class=\"line\">\t                    return 0;</span><br><span class=\"line\">\t                &#125;</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;);</span><br><span class=\"line\">\t     &#x2F;&#x2F;遍历排序后的映射集，封装返回</span><br><span class=\"line\">\t        Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter&#x3D;entryList.iterator();</span><br><span class=\"line\">\t        Map.Entry&lt;String,String&gt; temEntry &#x3D;null;</span><br><span class=\"line\">\t        while (iter.hasNext())&#123;</span><br><span class=\"line\">\t            Map&lt;String,String&gt; sortedMap &#x3D; new LinkedHashMap&lt;String,String&gt;();</span><br><span class=\"line\">\t            temEntry&#x3D;iter.next();</span><br><span class=\"line\">\t            sortedMap.put(&quot;type&quot;,temEntry.getKey());</span><br><span class=\"line\">\t            sortedMap.put(&quot;message&quot;,temEntry.getValue());</span><br><span class=\"line\">\t            resList.add(sortedMap);</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    return resList;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>说明:上述程序不直接返回sortedMap，而是将其放入List中，是为了便于解析及防止架构上可能的重新排序（若返回map，可能会按map的key排序）。</p>"},{"title":"java值传递还是引用传递","date":"2017-05-24T07:48:36.000Z","_content":"\n 由一道面试题引发的问题：java是值传递还是引用传递？\n{% codeblock %}\npublic class Test {\n\n    String str=\"abc\";\n    int a[]={1,2,3};\n    int i=1;\n    void change(String str,int a[],int i){\n        \n        str=\"cbd\";\n        a[0]=4;\n        i=2;\n    }\n    public static void main(String[] args) {\n    \n        Test t=new Test();\n        t.change(t.str,t.a,t.i);\n        System.out.println(t.str);\n        System.out.println(t.a[0]);\n        System.out.println(t.i++);\n    }\n}\n{% endcodeblock %}\n\n<!--more-->\n>运行结果\n>abc\n>4\n>1\n\n### 1.按值传递是什么\n指的是在方法调用时，传递的参数是按值的拷贝传递。\n按值传递重要特点:传递的是值的拷贝，也就是说传递后就互不相关了。\n\n### 2.按引用传递是什么\n指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。\n按引用传递的重要特点:\n传递的是值的引用，也就是说传递前和传递后都指向同一个引用(也就是同一个内存空间)。\n\n详细博文见[>>>](http://blog.csdn.net/zzp_403184692/article/details/8184751)\n","source":"_posts/paramPass.md","raw":"---\ntitle: java值传递还是引用传递\ndate: 2017-05-24 15:48:36\ntags: \n\t- Java基础\ncategories:\n\t- 编程\n\t- Java\t\n---\n\n 由一道面试题引发的问题：java是值传递还是引用传递？\n{% codeblock %}\npublic class Test {\n\n    String str=\"abc\";\n    int a[]={1,2,3};\n    int i=1;\n    void change(String str,int a[],int i){\n        \n        str=\"cbd\";\n        a[0]=4;\n        i=2;\n    }\n    public static void main(String[] args) {\n    \n        Test t=new Test();\n        t.change(t.str,t.a,t.i);\n        System.out.println(t.str);\n        System.out.println(t.a[0]);\n        System.out.println(t.i++);\n    }\n}\n{% endcodeblock %}\n\n<!--more-->\n>运行结果\n>abc\n>4\n>1\n\n### 1.按值传递是什么\n指的是在方法调用时，传递的参数是按值的拷贝传递。\n按值传递重要特点:传递的是值的拷贝，也就是说传递后就互不相关了。\n\n### 2.按引用传递是什么\n指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。\n按引用传递的重要特点:\n传递的是值的引用，也就是说传递前和传递后都指向同一个引用(也就是同一个内存空间)。\n\n详细博文见[>>>](http://blog.csdn.net/zzp_403184692/article/details/8184751)\n","slug":"paramPass","published":1,"updated":"2020-07-02T03:34:27.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttl0013yctoda3u7r2k","content":"<p> 由一道面试题引发的问题：java是值传递还是引用传递？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String str&#x3D;&quot;abc&quot;;</span><br><span class=\"line\">    int a[]&#x3D;&#123;1,2,3&#125;;</span><br><span class=\"line\">    int i&#x3D;1;</span><br><span class=\"line\">    void change(String str,int a[],int i)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        str&#x3D;&quot;cbd&quot;;</span><br><span class=\"line\">        a[0]&#x3D;4;</span><br><span class=\"line\">        i&#x3D;2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Test t&#x3D;new Test();</span><br><span class=\"line\">        t.change(t.str,t.a,t.i);</span><br><span class=\"line\">        System.out.println(t.str);</span><br><span class=\"line\">        System.out.println(t.a[0]);</span><br><span class=\"line\">        System.out.println(t.i++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<blockquote>\n<p>运行结果<br>abc<br>4<br>1</p>\n</blockquote>\n<h3 id=\"1-按值传递是什么\"><a href=\"#1-按值传递是什么\" class=\"headerlink\" title=\"1.按值传递是什么\"></a>1.按值传递是什么</h3><p>指的是在方法调用时，传递的参数是按值的拷贝传递。<br>按值传递重要特点:传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<h3 id=\"2-按引用传递是什么\"><a href=\"#2-按引用传递是什么\" class=\"headerlink\" title=\"2.按引用传递是什么\"></a>2.按引用传递是什么</h3><p>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。<br>按引用传递的重要特点:<br>传递的是值的引用，也就是说传递前和传递后都指向同一个引用(也就是同一个内存空间)。</p>\n<p>详细博文见<a href=\"http://blog.csdn.net/zzp_403184692/article/details/8184751\" target=\"_blank\" rel=\"noopener\">&gt;&gt;&gt;</a></p>\n","site":{"data":{}},"excerpt":"<p> 由一道面试题引发的问题：java是值传递还是引用传递？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String str&#x3D;&quot;abc&quot;;</span><br><span class=\"line\">    int a[]&#x3D;&#123;1,2,3&#125;;</span><br><span class=\"line\">    int i&#x3D;1;</span><br><span class=\"line\">    void change(String str,int a[],int i)&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        str&#x3D;&quot;cbd&quot;;</span><br><span class=\"line\">        a[0]&#x3D;4;</span><br><span class=\"line\">        i&#x3D;2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Test t&#x3D;new Test();</span><br><span class=\"line\">        t.change(t.str,t.a,t.i);</span><br><span class=\"line\">        System.out.println(t.str);</span><br><span class=\"line\">        System.out.println(t.a[0]);</span><br><span class=\"line\">        System.out.println(t.i++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<blockquote>\n<p>运行结果<br>abc<br>4<br>1</p>\n</blockquote>\n<h3 id=\"1-按值传递是什么\"><a href=\"#1-按值传递是什么\" class=\"headerlink\" title=\"1.按值传递是什么\"></a>1.按值传递是什么</h3><p>指的是在方法调用时，传递的参数是按值的拷贝传递。<br>按值传递重要特点:传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<h3 id=\"2-按引用传递是什么\"><a href=\"#2-按引用传递是什么\" class=\"headerlink\" title=\"2.按引用传递是什么\"></a>2.按引用传递是什么</h3><p>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。<br>按引用传递的重要特点:<br>传递的是值的引用，也就是说传递前和传递后都指向同一个引用(也就是同一个内存空间)。</p>\n<p>详细博文见<a href=\"http://blog.csdn.net/zzp_403184692/article/details/8184751\" target=\"_blank\" rel=\"noopener\">&gt;&gt;&gt;</a></p>"},{"title":"IDEA+Maven+SpringMVC+Hibernate环境搭建","date":"2017-03-20T06:09:10.000Z","_content":"\n>一篇十分详细的博文[地址](http://blog.lunhui.ren/archives/235)\n>[源码地址](https://git.coding.net/letra/MvcDemo.git)","source":"_posts/mvcdemo.md","raw":"---\ntitle: IDEA+Maven+SpringMVC+Hibernate环境搭建\ndate: 2017-03-20 14:09:10\ntags: \n\t- Java基础\ncategories:\n\t- 编程\n\t- Spring\n---\n\n>一篇十分详细的博文[地址](http://blog.lunhui.ren/archives/235)\n>[源码地址](https://git.coding.net/letra/MvcDemo.git)","slug":"mvcdemo","published":1,"updated":"2020-07-02T03:34:19.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtto0018ycto28yfhmxk","content":"<blockquote>\n<p>一篇十分详细的博文<a href=\"http://blog.lunhui.ren/archives/235\" target=\"_blank\" rel=\"noopener\">地址</a><br><a href=\"https://git.coding.net/letra/MvcDemo.git\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一篇十分详细的博文<a href=\"http://blog.lunhui.ren/archives/235\" target=\"_blank\" rel=\"noopener\">地址</a><br><a href=\"https://git.coding.net/letra/MvcDemo.git\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n</blockquote>\n"},{"title":"Centos6下redis安装配置","date":"2017-07-21T05:34:00.000Z","_content":">Remote Dictionary Server(Redis)\n>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n>\n>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n\n<!--more-->\n\n### 1、安装需要的支持环境\n\n在安装Redis之前首要先做的是安装Unix的Tcl工具，如果不安装的话后期将无法对Redis进行测试。在后期执行make test的时候返回如下错误信息：You need tcl 8.xuyao de5 or newer in order to run the Redis test，具体的流程为：\n{% codeblock %}\ncd /usr/local/src\nwget http://downloads.sourceforge.net/tcl/tcl8.6.3-src.tar.gz\ntar -zxvf tcl8.6.3-src.tar.gz\ncd ​tcl8.6.3/unix/\n./configure\nmake\nmake install\n{% endcodeblock %}\n### 2、安装redis\n安装redis的过程非常的简单，具体教程官网也有。具体如下：http://redis.io/download\n{% codeblock %}\ncd /usr/local/src\nwget http://download.redis.io/releases/redis-4.0.0.tar.gz\ntar zxvf redis-2.8.19.tar.gz\ncd redis-2.8.19\nmake\nmake PREFIX=/usr/local/redis install\n{% endcodeblock %}\n其中PREFIX=/usr/local/redis可以省略，省略情况下redis会默认安装到/usr/local/bin目录下。\n### 3、测试Redis\n\tcd src\n\tmake test\n\t通过以上命令就可以对redis进行加大的测试。\n### 4、配置redis\n{% codeblock %}\n#拷贝并修改配置文档\ncp ./redis.conf /usr/local/redis/\nvim /usr/local/redis/redis.conf\n{% endcodeblock %}\n{% codeblock %}\n#我只修改了如下几项：\ndaemonize yes #redis将以守护进程的方式运行，默认为no会暂用你的终端\ntimeout 300​ #当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\nrequirepass yourpassword #设置密码\n#bind 127.0.0.1 #限制了只能本地连接\n另外，设置密码后，使用redis-cli登录要带密码登录\n否则操作redis会出现身份认证的错误\n命令如下:\nredis-cli -a youPassword\n{% endcodeblock %}\n{% codeblock %}\n#B、启动或关闭服务\nservice redis start\nservice redis stop\n{% endcodeblock %}\n### 5、使用redis\n{% codeblock %}\n[root@localhost redis]# cd /usr/local/redis/bin\n[root@localhost bin]# ./redis-cli\n127.0.0.1:6379> set name cjs\nOK\n127.0.0.1:6379> get name\n\"cjs\"\n127.0.0.1:6379>\n{% endcodeblock %}\n### 6、java使用redis\n\n{% codeblock %}\n<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>2.9.0</version>\n</dependency>\n{% endcodeblock %}\n\tpublic final class RedisUtil {\n\n    //Redis服务器IP\n    private static String ADDR = \"***.***.***.***\";\n    \n    //Redis的端口号\n    private static int PORT = 6379;\n    \n    //访问密码\n    private static String AUTH = \"****\";\n    \n    //可用连接实例的最大数目，默认值为8；\n    //如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。\n    private static int MAX_ACTIVE = 1024;\n    \n    //控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。\n    private static int MAX_IDLE = 200;\n    \n    //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；\n    private static int MAX_WAIT = 10000;\n    \n    private static int TIMEOUT = 10000;\n    \n    //在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；\n    private static boolean TEST_ON_BORROW = true;\n    \n    private static JedisPool jedisPool = null;\n    \n    /**\n     * 初始化Redis连接池\n     */\n    static {\n        try {\n            JedisPoolConfig config = new JedisPoolConfig();\n    \t\tconfig.setMaxIdle(MAX_IDLE);\n    \t\t//jedis高版本JedisPoolConfig没有maxActive改名为：\n            config.setMaxTotal(MAX_ACTIVE);\n            config.setMaxWaitMillis(MAX_WAIT);\n            config.setTestOnBorrow(TEST_ON_BORROW);\n            jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    /**\n     * 获取Jedis实例\n     * @return\n     */\n    public synchronized static Jedis getJedis() {\n        try {\n            if (jedisPool != null) {\n                Jedis resource = jedisPool.getResource();\n                return resource;\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    /**\n     * 释放jedis资源\n     * @param jedis\n     */\n    public static void returnResource(final Jedis jedis) {\n        if (jedis != null) {\n            jedisPool.returnResource(jedis);\n        }\n    }\n    }\n","source":"_posts/redis_install.md","raw":"---\ntitle: Centos6下redis安装配置\ndate: 2017-07-21 13:34:00\ntags:\n\t- Redis\ncategories:\n\t- 运维\n---\n>Remote Dictionary Server(Redis)\n>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n>\n>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n\n<!--more-->\n\n### 1、安装需要的支持环境\n\n在安装Redis之前首要先做的是安装Unix的Tcl工具，如果不安装的话后期将无法对Redis进行测试。在后期执行make test的时候返回如下错误信息：You need tcl 8.xuyao de5 or newer in order to run the Redis test，具体的流程为：\n{% codeblock %}\ncd /usr/local/src\nwget http://downloads.sourceforge.net/tcl/tcl8.6.3-src.tar.gz\ntar -zxvf tcl8.6.3-src.tar.gz\ncd ​tcl8.6.3/unix/\n./configure\nmake\nmake install\n{% endcodeblock %}\n### 2、安装redis\n安装redis的过程非常的简单，具体教程官网也有。具体如下：http://redis.io/download\n{% codeblock %}\ncd /usr/local/src\nwget http://download.redis.io/releases/redis-4.0.0.tar.gz\ntar zxvf redis-2.8.19.tar.gz\ncd redis-2.8.19\nmake\nmake PREFIX=/usr/local/redis install\n{% endcodeblock %}\n其中PREFIX=/usr/local/redis可以省略，省略情况下redis会默认安装到/usr/local/bin目录下。\n### 3、测试Redis\n\tcd src\n\tmake test\n\t通过以上命令就可以对redis进行加大的测试。\n### 4、配置redis\n{% codeblock %}\n#拷贝并修改配置文档\ncp ./redis.conf /usr/local/redis/\nvim /usr/local/redis/redis.conf\n{% endcodeblock %}\n{% codeblock %}\n#我只修改了如下几项：\ndaemonize yes #redis将以守护进程的方式运行，默认为no会暂用你的终端\ntimeout 300​ #当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\nrequirepass yourpassword #设置密码\n#bind 127.0.0.1 #限制了只能本地连接\n另外，设置密码后，使用redis-cli登录要带密码登录\n否则操作redis会出现身份认证的错误\n命令如下:\nredis-cli -a youPassword\n{% endcodeblock %}\n{% codeblock %}\n#B、启动或关闭服务\nservice redis start\nservice redis stop\n{% endcodeblock %}\n### 5、使用redis\n{% codeblock %}\n[root@localhost redis]# cd /usr/local/redis/bin\n[root@localhost bin]# ./redis-cli\n127.0.0.1:6379> set name cjs\nOK\n127.0.0.1:6379> get name\n\"cjs\"\n127.0.0.1:6379>\n{% endcodeblock %}\n### 6、java使用redis\n\n{% codeblock %}\n<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>2.9.0</version>\n</dependency>\n{% endcodeblock %}\n\tpublic final class RedisUtil {\n\n    //Redis服务器IP\n    private static String ADDR = \"***.***.***.***\";\n    \n    //Redis的端口号\n    private static int PORT = 6379;\n    \n    //访问密码\n    private static String AUTH = \"****\";\n    \n    //可用连接实例的最大数目，默认值为8；\n    //如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。\n    private static int MAX_ACTIVE = 1024;\n    \n    //控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。\n    private static int MAX_IDLE = 200;\n    \n    //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；\n    private static int MAX_WAIT = 10000;\n    \n    private static int TIMEOUT = 10000;\n    \n    //在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；\n    private static boolean TEST_ON_BORROW = true;\n    \n    private static JedisPool jedisPool = null;\n    \n    /**\n     * 初始化Redis连接池\n     */\n    static {\n        try {\n            JedisPoolConfig config = new JedisPoolConfig();\n    \t\tconfig.setMaxIdle(MAX_IDLE);\n    \t\t//jedis高版本JedisPoolConfig没有maxActive改名为：\n            config.setMaxTotal(MAX_ACTIVE);\n            config.setMaxWaitMillis(MAX_WAIT);\n            config.setTestOnBorrow(TEST_ON_BORROW);\n            jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    /**\n     * 获取Jedis实例\n     * @return\n     */\n    public synchronized static Jedis getJedis() {\n        try {\n            if (jedisPool != null) {\n                Jedis resource = jedisPool.getResource();\n                return resource;\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    /**\n     * 释放jedis资源\n     * @param jedis\n     */\n    public static void returnResource(final Jedis jedis) {\n        if (jedis != null) {\n            jedisPool.returnResource(jedis);\n        }\n    }\n    }\n","slug":"redis_install","published":1,"updated":"2020-07-02T03:26:01.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttt001bycto3l2n9dpa","content":"<blockquote>\n<p>Remote Dictionary Server(Redis)<br>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>\n<p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"1、安装需要的支持环境\"><a href=\"#1、安装需要的支持环境\" class=\"headerlink\" title=\"1、安装需要的支持环境\"></a>1、安装需要的支持环境</h3><p>在安装Redis之前首要先做的是安装Unix的Tcl工具，如果不安装的话后期将无法对Redis进行测试。在后期执行make test的时候返回如下错误信息：You need tcl 8.xuyao de5 or newer in order to run the Redis test，具体的流程为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;tcl&#x2F;tcl8.6.3-src.tar.gz</span><br><span class=\"line\">tar -zxvf tcl8.6.3-src.tar.gz</span><br><span class=\"line\">cd ​tcl8.6.3&#x2F;unix&#x2F;</span><br><span class=\"line\">.&#x2F;configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、安装redis\"><a href=\"#2、安装redis\" class=\"headerlink\" title=\"2、安装redis\"></a>2、安装redis</h3><p>安装redis的过程非常的简单，具体教程官网也有。具体如下：<a href=\"http://redis.io/download\" target=\"_blank\" rel=\"noopener\">http://redis.io/download</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class=\"line\">tar zxvf redis-2.8.19.tar.gz</span><br><span class=\"line\">cd redis-2.8.19</span><br><span class=\"line\">make</span><br><span class=\"line\">make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install</span><br></pre></td></tr></table></figure>\n<p>其中PREFIX=/usr/local/redis可以省略，省略情况下redis会默认安装到/usr/local/bin目录下。</p>\n<h3 id=\"3、测试Redis\"><a href=\"#3、测试Redis\" class=\"headerlink\" title=\"3、测试Redis\"></a>3、测试Redis</h3><pre><code>cd src\nmake test\n通过以上命令就可以对redis进行加大的测试。</code></pre><h3 id=\"4、配置redis\"><a href=\"#4、配置redis\" class=\"headerlink\" title=\"4、配置redis\"></a>4、配置redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#拷贝并修改配置文档</span><br><span class=\"line\">cp .&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;</span><br><span class=\"line\">vim &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#我只修改了如下几项：</span><br><span class=\"line\">daemonize yes #redis将以守护进程的方式运行，默认为no会暂用你的终端</span><br><span class=\"line\">timeout 300​ #当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class=\"line\">requirepass yourpassword #设置密码</span><br><span class=\"line\">#bind 127.0.0.1 #限制了只能本地连接</span><br><span class=\"line\">另外，设置密码后，使用redis-cli登录要带密码登录</span><br><span class=\"line\">否则操作redis会出现身份认证的错误</span><br><span class=\"line\">命令如下:</span><br><span class=\"line\">redis-cli -a youPassword</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#B、启动或关闭服务</span><br><span class=\"line\">service redis start</span><br><span class=\"line\">service redis stop</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、使用redis\"><a href=\"#5、使用redis\" class=\"headerlink\" title=\"5、使用redis\"></a>5、使用redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost redis]# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class=\"line\">[root@localhost bin]# .&#x2F;redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set name cjs</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;cjs&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、java使用redis\"><a href=\"#6、java使用redis\" class=\"headerlink\" title=\"6、java使用redis\"></a>6、java使用redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>public final class RedisUtil {\n\n//Redis服务器IP\nprivate static String ADDR = &quot;***.***.***.***&quot;;\n\n//Redis的端口号\nprivate static int PORT = 6379;\n\n//访问密码\nprivate static String AUTH = &quot;****&quot;;\n\n//可用连接实例的最大数目，默认值为8；\n//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。\nprivate static int MAX_ACTIVE = 1024;\n\n//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。\nprivate static int MAX_IDLE = 200;\n\n//等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；\nprivate static int MAX_WAIT = 10000;\n\nprivate static int TIMEOUT = 10000;\n\n//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；\nprivate static boolean TEST_ON_BORROW = true;\n\nprivate static JedisPool jedisPool = null;\n\n/**\n * 初始化Redis连接池\n */\nstatic {\n    try {\n        JedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxIdle(MAX_IDLE);\n        //jedis高版本JedisPoolConfig没有maxActive改名为：\n        config.setMaxTotal(MAX_ACTIVE);\n        config.setMaxWaitMillis(MAX_WAIT);\n        config.setTestOnBorrow(TEST_ON_BORROW);\n        jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n/**\n * 获取Jedis实例\n * @return\n */\npublic synchronized static Jedis getJedis() {\n    try {\n        if (jedisPool != null) {\n            Jedis resource = jedisPool.getResource();\n            return resource;\n        } else {\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\n/**\n * 释放jedis资源\n * @param jedis\n */\npublic static void returnResource(final Jedis jedis) {\n    if (jedis != null) {\n        jedisPool.returnResource(jedis);\n    }\n}\n}</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>Remote Dictionary Server(Redis)<br>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>\n<p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map),列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>\n</blockquote>","more":"<h3 id=\"1、安装需要的支持环境\"><a href=\"#1、安装需要的支持环境\" class=\"headerlink\" title=\"1、安装需要的支持环境\"></a>1、安装需要的支持环境</h3><p>在安装Redis之前首要先做的是安装Unix的Tcl工具，如果不安装的话后期将无法对Redis进行测试。在后期执行make test的时候返回如下错误信息：You need tcl 8.xuyao de5 or newer in order to run the Redis test，具体的流程为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;tcl&#x2F;tcl8.6.3-src.tar.gz</span><br><span class=\"line\">tar -zxvf tcl8.6.3-src.tar.gz</span><br><span class=\"line\">cd ​tcl8.6.3&#x2F;unix&#x2F;</span><br><span class=\"line\">.&#x2F;configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、安装redis\"><a href=\"#2、安装redis\" class=\"headerlink\" title=\"2、安装redis\"></a>2、安装redis</h3><p>安装redis的过程非常的简单，具体教程官网也有。具体如下：<a href=\"http://redis.io/download\" target=\"_blank\" rel=\"noopener\">http://redis.io/download</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.0.tar.gz</span><br><span class=\"line\">tar zxvf redis-2.8.19.tar.gz</span><br><span class=\"line\">cd redis-2.8.19</span><br><span class=\"line\">make</span><br><span class=\"line\">make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install</span><br></pre></td></tr></table></figure>\n<p>其中PREFIX=/usr/local/redis可以省略，省略情况下redis会默认安装到/usr/local/bin目录下。</p>\n<h3 id=\"3、测试Redis\"><a href=\"#3、测试Redis\" class=\"headerlink\" title=\"3、测试Redis\"></a>3、测试Redis</h3><pre><code>cd src\nmake test\n通过以上命令就可以对redis进行加大的测试。</code></pre><h3 id=\"4、配置redis\"><a href=\"#4、配置redis\" class=\"headerlink\" title=\"4、配置redis\"></a>4、配置redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#拷贝并修改配置文档</span><br><span class=\"line\">cp .&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;</span><br><span class=\"line\">vim &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#我只修改了如下几项：</span><br><span class=\"line\">daemonize yes #redis将以守护进程的方式运行，默认为no会暂用你的终端</span><br><span class=\"line\">timeout 300​ #当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class=\"line\">requirepass yourpassword #设置密码</span><br><span class=\"line\">#bind 127.0.0.1 #限制了只能本地连接</span><br><span class=\"line\">另外，设置密码后，使用redis-cli登录要带密码登录</span><br><span class=\"line\">否则操作redis会出现身份认证的错误</span><br><span class=\"line\">命令如下:</span><br><span class=\"line\">redis-cli -a youPassword</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#B、启动或关闭服务</span><br><span class=\"line\">service redis start</span><br><span class=\"line\">service redis stop</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、使用redis\"><a href=\"#5、使用redis\" class=\"headerlink\" title=\"5、使用redis\"></a>5、使用redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost redis]# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class=\"line\">[root@localhost bin]# .&#x2F;redis-cli</span><br><span class=\"line\">127.0.0.1:6379&gt; set name cjs</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;cjs&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、java使用redis\"><a href=\"#6、java使用redis\" class=\"headerlink\" title=\"6、java使用redis\"></a>6、java使用redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<pre><code>public final class RedisUtil {\n\n//Redis服务器IP\nprivate static String ADDR = &quot;***.***.***.***&quot;;\n\n//Redis的端口号\nprivate static int PORT = 6379;\n\n//访问密码\nprivate static String AUTH = &quot;****&quot;;\n\n//可用连接实例的最大数目，默认值为8；\n//如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。\nprivate static int MAX_ACTIVE = 1024;\n\n//控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。\nprivate static int MAX_IDLE = 200;\n\n//等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException；\nprivate static int MAX_WAIT = 10000;\n\nprivate static int TIMEOUT = 10000;\n\n//在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；\nprivate static boolean TEST_ON_BORROW = true;\n\nprivate static JedisPool jedisPool = null;\n\n/**\n * 初始化Redis连接池\n */\nstatic {\n    try {\n        JedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxIdle(MAX_IDLE);\n        //jedis高版本JedisPoolConfig没有maxActive改名为：\n        config.setMaxTotal(MAX_ACTIVE);\n        config.setMaxWaitMillis(MAX_WAIT);\n        config.setTestOnBorrow(TEST_ON_BORROW);\n        jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n/**\n * 获取Jedis实例\n * @return\n */\npublic synchronized static Jedis getJedis() {\n    try {\n        if (jedisPool != null) {\n            Jedis resource = jedisPool.getResource();\n            return resource;\n        } else {\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\n/**\n * 释放jedis资源\n * @param jedis\n */\npublic static void returnResource(final Jedis jedis) {\n    if (jedis != null) {\n        jedisPool.returnResource(jedis);\n    }\n}\n}</code></pre>"},{"title":"Socket","date":"2020-07-09T03:50:49.000Z","_content":"\n#### Socket\n\n> Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。\n> 所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。\n>\n> 也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识\n\n<!--more-->\n\n![UDP报文](/articleImage/2020-07-09/1.png)\n\n### Socket通信过程\n\n![UDP报文](/articleImage/2020-07-09/socket1.jpg)\n\n服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束\n\n#### Socket面试题\n\n编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。\n\n[参考链接](https://www.cnblogs.com/zhzhlong/p/9296850.html)","source":"_posts/socket.md","raw":"---\ntitle: Socket\ndate: 2020-07-09 11:50:49\ncategories:\n\t- Java面试\n\t- 计算机网络\n\n---\n\n#### Socket\n\n> Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。\n> 所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。\n>\n> 也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识\n\n<!--more-->\n\n![UDP报文](/articleImage/2020-07-09/1.png)\n\n### Socket通信过程\n\n![UDP报文](/articleImage/2020-07-09/socket1.jpg)\n\n服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束\n\n#### Socket面试题\n\n编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。\n\n[参考链接](https://www.cnblogs.com/zhzhlong/p/9296850.html)","slug":"socket","published":1,"updated":"2020-07-09T06:08:13.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttv001fyctogtaddezk","content":"<h4 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h4><blockquote>\n<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>\n<p>也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p><img src=\"/articleImage/2020-07-09/1.png\" alt=\"UDP报文\"></p>\n<h3 id=\"Socket通信过程\"><a href=\"#Socket通信过程\" class=\"headerlink\" title=\"Socket通信过程\"></a>Socket通信过程</h3><p><img src=\"/articleImage/2020-07-09/socket1.jpg\" alt=\"UDP报文\"></p>\n<p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p>\n<h4 id=\"Socket面试题\"><a href=\"#Socket面试题\" class=\"headerlink\" title=\"Socket面试题\"></a>Socket面试题</h4><p>编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。</p>\n<p><a href=\"https://www.cnblogs.com/zhzhlong/p/9296850.html\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h4><blockquote>\n<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>\n<p>也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识</p>\n</blockquote>","more":"<p><img src=\"/articleImage/2020-07-09/1.png\" alt=\"UDP报文\"></p>\n<h3 id=\"Socket通信过程\"><a href=\"#Socket通信过程\" class=\"headerlink\" title=\"Socket通信过程\"></a>Socket通信过程</h3><p><img src=\"/articleImage/2020-07-09/socket1.jpg\" alt=\"UDP报文\"></p>\n<p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束</p>\n<h4 id=\"Socket面试题\"><a href=\"#Socket面试题\" class=\"headerlink\" title=\"Socket面试题\"></a>Socket面试题</h4><p>编写一个网络应用程序，有客户端与服务器端，客户端向服务器发送一个字符串，服务器收到该字符串后将其打印到命行上，然后向客户端返回该字符串的长度，最后，客户端输出服务器端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。</p>\n<p><a href=\"https://www.cnblogs.com/zhzhlong/p/9296850.html\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>"},{"title":"springmvc导出Excel问题记录","date":"2017-03-31T08:18:15.000Z","_content":">SpringMVC中获取不到POST形式的参数\n>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何\n>对表单数据进行编码。默认地，表单数据会编码为\"application/x-www-form-urlencoded\"。\n>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 \"+\" 加号，特殊符号转换为\n>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded\"方式。\n>但代码里强制使用了multipart/form-data方式。\n\n<!--more-->\n所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：\n{% codeblock %}\n<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">       \n</bean>\n{% endcodeblock %}\n并将commons-fileupload-1.3.2jar包引入到项目中\n{% codeblock %}\n<!-- POI导出Exl -->\n<dependency>\n   <groupId>org.apache.poi</groupId>\n   <artifactId>poi-ooxml</artifactId>\n   <version>3.9</version>\n</dependency>\n<dependency>\n   <groupId>commons-fileupload</groupId>\n   <artifactId>commons-fileupload</artifactId>\n   <version>1.3.2</version>\n</dependency>\n{% endcodeblock %}\n这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。\n\n注：此问题是在上一个项目[git地址](https://coding.net/u/letra/p/mvcdemo/git)的基础上新增了导出Ecxel功能是发现，在此记录一二。","source":"_posts/springmvcPost.md","raw":"---\ntitle: springmvc导出Excel问题记录\ndate: 2017-03-31 16:18:15\ntags: \n\t- Java基础\ncategories:\n\t- 编程\n\t- Java\t\n---\n>SpringMVC中获取不到POST形式的参数\n>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何\n>对表单数据进行编码。默认地，表单数据会编码为\"application/x-www-form-urlencoded\"。\n>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 \"+\" 加号，特殊符号转换为\n>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded\"方式。\n>但代码里强制使用了multipart/form-data方式。\n\n<!--more-->\n所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：\n{% codeblock %}\n<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">       \n</bean>\n{% endcodeblock %}\n并将commons-fileupload-1.3.2jar包引入到项目中\n{% codeblock %}\n<!-- POI导出Exl -->\n<dependency>\n   <groupId>org.apache.poi</groupId>\n   <artifactId>poi-ooxml</artifactId>\n   <version>3.9</version>\n</dependency>\n<dependency>\n   <groupId>commons-fileupload</groupId>\n   <artifactId>commons-fileupload</artifactId>\n   <version>1.3.2</version>\n</dependency>\n{% endcodeblock %}\n这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。\n\n注：此问题是在上一个项目[git地址](https://coding.net/u/letra/p/mvcdemo/git)的基础上新增了导出Ecxel功能是发现，在此记录一二。","slug":"springmvcPost","published":1,"updated":"2020-07-02T03:34:52.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugttx001jycto4a5zckpv","content":"<blockquote>\n<p>SpringMVC中获取不到POST形式的参数<br>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何<br>对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。<br>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为<br>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。<br>但代码里强制使用了multipart/form-data方式。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;       </span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<p>并将commons-fileupload-1.3.2jar包引入到项目中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- POI导出Exl --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;3.9&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。</p>\n<p>注：此问题是在上一个项目<a href=\"https://coding.net/u/letra/p/mvcdemo/git\" target=\"_blank\" rel=\"noopener\">git地址</a>的基础上新增了导出Ecxel功能是发现，在此记录一二。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>SpringMVC中获取不到POST形式的参数<br>这是form表单的enctype编码方式不同导致的enctype属性规定在发送到服务器之前,应该如何<br>对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。<br>就是说，在发送到服务器之前,所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为<br>ASCII HEX 值）。如果使用GET，则强制使用application/x-www-form-urlencoded”方式。<br>但代码里强制使用了multipart/form-data方式。</p>\n</blockquote>","more":"<p>所以spring mvc如果要接收 multipart/form-data 传输的数据，应该在spring上下文配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;       </span><br><span class=\"line\">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>\n<p>并将commons-fileupload-1.3.2jar包引入到项目中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- POI导出Exl --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;3.9&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>这样服务端就既可以接收multipart/form-data 传输的数据，也可以接收application/x-www-form-urlencoded传输的文本数据了。</p>\n<p>注：此问题是在上一个项目<a href=\"https://coding.net/u/letra/p/mvcdemo/git\" target=\"_blank\" rel=\"noopener\">git地址</a>的基础上新增了导出Ecxel功能是发现，在此记录一二。</p>"},{"title":"ThreadLocal","date":"2020-07-28T07:56:16.000Z","_content":"\n### ThreadLocal的用途\n\n◆典型场景1:每个线程需要—个独享的对象（通常是工具类（线程不安全），典型需要使用的类有 SimpleDateFormat和 Random）\n\n◆典型场景2:每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。\n\n实例1：SimpleDateFormat的格式化日期\n\n（1）2个线程分别用自己的 SimpleDateFormat，这没问题。\n（2）后来延伸出10个，那就有10个线程和10个SimpleDate Format，这虽然写法不优雅（应该复用对象）但勉强可以接受。\n（3）但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）。\n（4）所有的线程都共用同一个 simple Date Format对象（加锁）。\n\n<!--more-->\n\n\n实例2:当前用户信息需要被线程内所有方法共享\n\n◆一个比较繁琐的解决方案是把user作为参数层层传递，从 service-1传到 service-2，再从 service-2传到 Service-3，以此类推，但是这样做会导致代码冗余且不易维护。\n\n◆每个线程内需要保存全局变量，可以让不同方法直接使用，避免参数传递的麻烦。\n\n◆在此基础上可以演进，使用 UserMap。\n\n◆当多线程同时工作时，我们需要保证线程安全，可以用 synchronized也可以用 ConcurrentHash Map，但无论用什么，都会对性能有所影响。\n\n更好的办法是使用ThreadLocal，这样无需synchronized， 可以在不影响性能的情况下，也无需层传递参数，就可达到保存当前线程对应的用户信息的目的\n\n◆用 ThreadLocal中保存一些业务内容（用户权限信息、从用户系统获取到的用户名、ID等）。\n\n◆这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。\n\n◆在线程生命周期内，都通过这个静态 Threadlocal实例的get()方法取得自己set()过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦。\n\n◆强调的是同一个请求内（同一个线程内）不同方法间的共享。\n\n◆不需重写 initialValue0方法，但是必须手动调用set0方法。\n\n### Threadloca的两个作用\n\n1.让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）\n\n2.在任何方法中都可以轻松获取到该对象\n\n### ThreadLocal的好处\n\n- 达到线程安全\n- 不需要加锁，提高执行效率\n- 更高效的利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat,显然用ThreadLocal可以节省内存和开销。\n- 免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度更低，更优雅\n\n### 原理、源码分析\n\n![原理图](/articleImage/2020-07-28/1.png)\n\n搞清楚Thread,ThreadLocal以及ThreadLocalMap三者之间的关系\n\n每个Thread对象中都持有一个ThreadLocalMap成员变量\n\n#### 主要方法介绍\n\n**initialValue()**\n1.该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发。\n2.当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法\n3.通常，每个线程最多调用一次此方法，但如果已经调用了remove()后，再调用get()，则可以再次调用此方法\n4.如果不重写本方法，这个方法默认返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象\n\n**set()**\n\n为这个线程设置一个新值\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n       map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n```\n\n**get()**\n\n得到这个线程对应的value。\n如果是首次调用get()，则会调用initialize来得到这个值；get方法是先取出当前线程的ThreadLocalMap，然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的Value\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n         }\n    }\n    return setInitialValue();\n}\n\n```\n\n**remove**()\n\n删除对应这个线程的值\n\n```java\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\nThreadLocalMap类，也就是Thread.threadLocals\nThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[]table,可以任务是一个map，键值对：\n    键：当前ThreadLocal\n\t值：实际需要的成员变量    \n\n**ThreadLocalMap解决冲突的方式**\n\nHashMap 处理冲突：拉链法-->红黑树\n\nThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置。\n\n#### 内存泄漏问题\n\n什么是内存泄漏：某个对象不再使用了，但是占用的内存却不能被回收\n\n弱引用的特点是，如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收\n\n弱引用不会阻止GC，因此这个弱引用的机制\n\n```java\n static class Entry extends WeakReference<ThreadLocal<?>> {\n       /** The value associated with this ThreadLocal. */\n       Object value;\n\t   Entry(ThreadLocal<?> k, Object v) {\n       super(k);\n       value = v;\n   }\n}\n\n```\n\nValue的泄漏\n\n（1）ThreadLocalMap的每个Entry都是一个对 Key的弱引用，同时每个Entry都包含了一个队value的强引用。\n\n正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收。因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM。\n\n（2）JDK已经考虑到了这个问题，所以在set，remove,rehash方法中会扫描 key 为null的 Entry，并把对应的value设置为null，这样value对象就可以被回收\n\n```java\nprivate void resize() {\n    Entry[] oldTab = table;\n    int oldLen = oldTab.length;\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n     for (int j = 0; j < oldLen; ++j) {\n          Entry e = oldTab[j];\n          if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n             } else {\n                int h = k.threadLocalHashCode & (newLen - 1);\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                  newTab[h] = e;\n                 count++;\n              }\n          }\n      }\n     setThreshold(newLen);\n     size = count;\n     table = newTab;\n}\n```\n\n（3）但是如果一个ThreadLocal不被使用，那么实际上set，remove，rehash方法也不会被调用，如果同时线程又不停止，呢么调用链就一直存在，那么就导致了value的内存泄漏。\n\n（4）调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏。所以使用完ThreadLocal后，应该主动调用remove()方法。\n\n#### ThreadLocal注意的点\n\n##### 空指针异常\n\n若ThreadLocal 没有提前赋值，则返回null，此时应注意包装类的装箱拆箱会导致NPE （若用基本类型接收null即会NPE）\n\n##### 共享对象\n\n如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取得得还是这个共享对象本身，还是有并发访问问题。\n\n**灵活运用**\n\n如果可以不适用ThreadLocal就可以解决问题，那么不要强行使用：\n例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal。\n\n优先使用框架的支持，而不是自己创造：\n例如在Spring中，如果可以使用RequestContextHolder,那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法等，造成内存泄漏。\n\n#### 实际应用场景--在Spring中的实例\n\nDateTimeContextHolder\n\nRequestContextHolder\n\n*每次Http请求都对应一个线程，线程之间相互隔离，这就是ThreadLocal的典型应用场景*","source":"_posts/threadLocal.md","raw":"---\ntitle: ThreadLocal\ndate: 2020-07-28 15:56:16\ncategories:\n\t- 编程\n\t- Java\n---\n\n### ThreadLocal的用途\n\n◆典型场景1:每个线程需要—个独享的对象（通常是工具类（线程不安全），典型需要使用的类有 SimpleDateFormat和 Random）\n\n◆典型场景2:每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。\n\n实例1：SimpleDateFormat的格式化日期\n\n（1）2个线程分别用自己的 SimpleDateFormat，这没问题。\n（2）后来延伸出10个，那就有10个线程和10个SimpleDate Format，这虽然写法不优雅（应该复用对象）但勉强可以接受。\n（3）但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）。\n（4）所有的线程都共用同一个 simple Date Format对象（加锁）。\n\n<!--more-->\n\n\n实例2:当前用户信息需要被线程内所有方法共享\n\n◆一个比较繁琐的解决方案是把user作为参数层层传递，从 service-1传到 service-2，再从 service-2传到 Service-3，以此类推，但是这样做会导致代码冗余且不易维护。\n\n◆每个线程内需要保存全局变量，可以让不同方法直接使用，避免参数传递的麻烦。\n\n◆在此基础上可以演进，使用 UserMap。\n\n◆当多线程同时工作时，我们需要保证线程安全，可以用 synchronized也可以用 ConcurrentHash Map，但无论用什么，都会对性能有所影响。\n\n更好的办法是使用ThreadLocal，这样无需synchronized， 可以在不影响性能的情况下，也无需层传递参数，就可达到保存当前线程对应的用户信息的目的\n\n◆用 ThreadLocal中保存一些业务内容（用户权限信息、从用户系统获取到的用户名、ID等）。\n\n◆这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。\n\n◆在线程生命周期内，都通过这个静态 Threadlocal实例的get()方法取得自己set()过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦。\n\n◆强调的是同一个请求内（同一个线程内）不同方法间的共享。\n\n◆不需重写 initialValue0方法，但是必须手动调用set0方法。\n\n### Threadloca的两个作用\n\n1.让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）\n\n2.在任何方法中都可以轻松获取到该对象\n\n### ThreadLocal的好处\n\n- 达到线程安全\n- 不需要加锁，提高执行效率\n- 更高效的利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat,显然用ThreadLocal可以节省内存和开销。\n- 免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度更低，更优雅\n\n### 原理、源码分析\n\n![原理图](/articleImage/2020-07-28/1.png)\n\n搞清楚Thread,ThreadLocal以及ThreadLocalMap三者之间的关系\n\n每个Thread对象中都持有一个ThreadLocalMap成员变量\n\n#### 主要方法介绍\n\n**initialValue()**\n1.该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发。\n2.当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法\n3.通常，每个线程最多调用一次此方法，但如果已经调用了remove()后，再调用get()，则可以再次调用此方法\n4.如果不重写本方法，这个方法默认返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象\n\n**set()**\n\n为这个线程设置一个新值\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n       map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n```\n\n**get()**\n\n得到这个线程对应的value。\n如果是首次调用get()，则会调用initialize来得到这个值；get方法是先取出当前线程的ThreadLocalMap，然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的Value\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n         }\n    }\n    return setInitialValue();\n}\n\n```\n\n**remove**()\n\n删除对应这个线程的值\n\n```java\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\nThreadLocalMap类，也就是Thread.threadLocals\nThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[]table,可以任务是一个map，键值对：\n    键：当前ThreadLocal\n\t值：实际需要的成员变量    \n\n**ThreadLocalMap解决冲突的方式**\n\nHashMap 处理冲突：拉链法-->红黑树\n\nThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置。\n\n#### 内存泄漏问题\n\n什么是内存泄漏：某个对象不再使用了，但是占用的内存却不能被回收\n\n弱引用的特点是，如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收\n\n弱引用不会阻止GC，因此这个弱引用的机制\n\n```java\n static class Entry extends WeakReference<ThreadLocal<?>> {\n       /** The value associated with this ThreadLocal. */\n       Object value;\n\t   Entry(ThreadLocal<?> k, Object v) {\n       super(k);\n       value = v;\n   }\n}\n\n```\n\nValue的泄漏\n\n（1）ThreadLocalMap的每个Entry都是一个对 Key的弱引用，同时每个Entry都包含了一个队value的强引用。\n\n正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收。因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM。\n\n（2）JDK已经考虑到了这个问题，所以在set，remove,rehash方法中会扫描 key 为null的 Entry，并把对应的value设置为null，这样value对象就可以被回收\n\n```java\nprivate void resize() {\n    Entry[] oldTab = table;\n    int oldLen = oldTab.length;\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n     for (int j = 0; j < oldLen; ++j) {\n          Entry e = oldTab[j];\n          if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n             } else {\n                int h = k.threadLocalHashCode & (newLen - 1);\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                  newTab[h] = e;\n                 count++;\n              }\n          }\n      }\n     setThreshold(newLen);\n     size = count;\n     table = newTab;\n}\n```\n\n（3）但是如果一个ThreadLocal不被使用，那么实际上set，remove，rehash方法也不会被调用，如果同时线程又不停止，呢么调用链就一直存在，那么就导致了value的内存泄漏。\n\n（4）调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏。所以使用完ThreadLocal后，应该主动调用remove()方法。\n\n#### ThreadLocal注意的点\n\n##### 空指针异常\n\n若ThreadLocal 没有提前赋值，则返回null，此时应注意包装类的装箱拆箱会导致NPE （若用基本类型接收null即会NPE）\n\n##### 共享对象\n\n如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取得得还是这个共享对象本身，还是有并发访问问题。\n\n**灵活运用**\n\n如果可以不适用ThreadLocal就可以解决问题，那么不要强行使用：\n例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal。\n\n优先使用框架的支持，而不是自己创造：\n例如在Spring中，如果可以使用RequestContextHolder,那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法等，造成内存泄漏。\n\n#### 实际应用场景--在Spring中的实例\n\nDateTimeContextHolder\n\nRequestContextHolder\n\n*每次Http请求都对应一个线程，线程之间相互隔离，这就是ThreadLocal的典型应用场景*","slug":"threadLocal","published":1,"updated":"2020-07-28T11:15:41.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtu0001nycto1b8oh9rw","content":"<h3 id=\"ThreadLocal的用途\"><a href=\"#ThreadLocal的用途\" class=\"headerlink\" title=\"ThreadLocal的用途\"></a>ThreadLocal的用途</h3><p>◆典型场景1:每个线程需要—个独享的对象（通常是工具类（线程不安全），典型需要使用的类有 SimpleDateFormat和 Random）</p>\n<p>◆典型场景2:每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。</p>\n<p>实例1：SimpleDateFormat的格式化日期</p>\n<p>（1）2个线程分别用自己的 SimpleDateFormat，这没问题。<br>（2）后来延伸出10个，那就有10个线程和10个SimpleDate Format，这虽然写法不优雅（应该复用对象）但勉强可以接受。<br>（3）但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）。<br>（4）所有的线程都共用同一个 simple Date Format对象（加锁）。</p>\n<a id=\"more\"></a>\n\n\n<p>实例2:当前用户信息需要被线程内所有方法共享</p>\n<p>◆一个比较繁琐的解决方案是把user作为参数层层传递，从 service-1传到 service-2，再从 service-2传到 Service-3，以此类推，但是这样做会导致代码冗余且不易维护。</p>\n<p>◆每个线程内需要保存全局变量，可以让不同方法直接使用，避免参数传递的麻烦。</p>\n<p>◆在此基础上可以演进，使用 UserMap。</p>\n<p>◆当多线程同时工作时，我们需要保证线程安全，可以用 synchronized也可以用 ConcurrentHash Map，但无论用什么，都会对性能有所影响。</p>\n<p>更好的办法是使用ThreadLocal，这样无需synchronized， 可以在不影响性能的情况下，也无需层传递参数，就可达到保存当前线程对应的用户信息的目的</p>\n<p>◆用 ThreadLocal中保存一些业务内容（用户权限信息、从用户系统获取到的用户名、ID等）。</p>\n<p>◆这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。</p>\n<p>◆在线程生命周期内，都通过这个静态 Threadlocal实例的get()方法取得自己set()过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦。</p>\n<p>◆强调的是同一个请求内（同一个线程内）不同方法间的共享。</p>\n<p>◆不需重写 initialValue0方法，但是必须手动调用set0方法。</p>\n<h3 id=\"Threadloca的两个作用\"><a href=\"#Threadloca的两个作用\" class=\"headerlink\" title=\"Threadloca的两个作用\"></a>Threadloca的两个作用</h3><p>1.让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</p>\n<p>2.在任何方法中都可以轻松获取到该对象</p>\n<h3 id=\"ThreadLocal的好处\"><a href=\"#ThreadLocal的好处\" class=\"headerlink\" title=\"ThreadLocal的好处\"></a>ThreadLocal的好处</h3><ul>\n<li>达到线程安全</li>\n<li>不需要加锁，提高执行效率</li>\n<li>更高效的利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat,显然用ThreadLocal可以节省内存和开销。</li>\n<li>免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度更低，更优雅</li>\n</ul>\n<h3 id=\"原理、源码分析\"><a href=\"#原理、源码分析\" class=\"headerlink\" title=\"原理、源码分析\"></a>原理、源码分析</h3><p><img src=\"/articleImage/2020-07-28/1.png\" alt=\"原理图\"></p>\n<p>搞清楚Thread,ThreadLocal以及ThreadLocalMap三者之间的关系</p>\n<p>每个Thread对象中都持有一个ThreadLocalMap成员变量</p>\n<h4 id=\"主要方法介绍\"><a href=\"#主要方法介绍\" class=\"headerlink\" title=\"主要方法介绍\"></a>主要方法介绍</h4><p><strong>initialValue()</strong><br>1.该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发。<br>2.当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法<br>3.通常，每个线程最多调用一次此方法，但如果已经调用了remove()后，再调用get()，则可以再次调用此方法<br>4.如果不重写本方法，这个方法默认返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象</p>\n<p><strong>set()</strong></p>\n<p>为这个线程设置一个新值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">       map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>get()</strong></p>\n<p>得到这个线程对应的value。<br>如果是首次调用get()，则会调用initialize来得到这个值；get方法是先取出当前线程的ThreadLocalMap，然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的Value</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>remove</strong>()</p>\n<p>删除对应这个线程的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ThreadLocalMap类，也就是Thread.threadLocals<br>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[]table,可以任务是一个map，键值对：<br>    键：当前ThreadLocal<br>    值：实际需要的成员变量    </p>\n<p><strong>ThreadLocalMap解决冲突的方式</strong></p>\n<p>HashMap 处理冲突：拉链法–&gt;红黑树</p>\n<p>ThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置。</p>\n<h4 id=\"内存泄漏问题\"><a href=\"#内存泄漏问题\" class=\"headerlink\" title=\"内存泄漏问题\"></a>内存泄漏问题</h4><p>什么是内存泄漏：某个对象不再使用了，但是占用的内存却不能被回收</p>\n<p>弱引用的特点是，如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收</p>\n<p>弱引用不会阻止GC，因此这个弱引用的机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">       Object value;</span><br><span class=\"line\">\t   Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">       value = v;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Value的泄漏</p>\n<p>（1）ThreadLocalMap的每个Entry都是一个对 Key的弱引用，同时每个Entry都包含了一个队value的强引用。</p>\n<p>正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收。因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM。</p>\n<p>（2）JDK已经考虑到了这个问题，所以在set，remove,rehash方法中会扫描 key 为null的 Entry，并把对应的value设置为null，这样value对象就可以被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Entry[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldLen = oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLen = oldLen * <span class=\"number\">2</span>;</span><br><span class=\"line\">    Entry[] newTab = <span class=\"keyword\">new</span> Entry[newLen];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class=\"line\">          Entry e = oldTab[j];</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help the GC</span></span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (newTab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, newLen);</span><br><span class=\"line\">                  newTab[h] = e;</span><br><span class=\"line\">                 count++;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     setThreshold(newLen);</span><br><span class=\"line\">     size = count;</span><br><span class=\"line\">     table = newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）但是如果一个ThreadLocal不被使用，那么实际上set，remove，rehash方法也不会被调用，如果同时线程又不停止，呢么调用链就一直存在，那么就导致了value的内存泄漏。</p>\n<p>（4）调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏。所以使用完ThreadLocal后，应该主动调用remove()方法。</p>\n<h4 id=\"ThreadLocal注意的点\"><a href=\"#ThreadLocal注意的点\" class=\"headerlink\" title=\"ThreadLocal注意的点\"></a>ThreadLocal注意的点</h4><h5 id=\"空指针异常\"><a href=\"#空指针异常\" class=\"headerlink\" title=\"空指针异常\"></a>空指针异常</h5><p>若ThreadLocal 没有提前赋值，则返回null，此时应注意包装类的装箱拆箱会导致NPE （若用基本类型接收null即会NPE）</p>\n<h5 id=\"共享对象\"><a href=\"#共享对象\" class=\"headerlink\" title=\"共享对象\"></a>共享对象</h5><p>如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取得得还是这个共享对象本身，还是有并发访问问题。</p>\n<p><strong>灵活运用</strong></p>\n<p>如果可以不适用ThreadLocal就可以解决问题，那么不要强行使用：<br>例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal。</p>\n<p>优先使用框架的支持，而不是自己创造：<br>例如在Spring中，如果可以使用RequestContextHolder,那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法等，造成内存泄漏。</p>\n<h4 id=\"实际应用场景–在Spring中的实例\"><a href=\"#实际应用场景–在Spring中的实例\" class=\"headerlink\" title=\"实际应用场景–在Spring中的实例\"></a>实际应用场景–在Spring中的实例</h4><p>DateTimeContextHolder</p>\n<p>RequestContextHolder</p>\n<p><em>每次Http请求都对应一个线程，线程之间相互隔离，这就是ThreadLocal的典型应用场景</em></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"ThreadLocal的用途\"><a href=\"#ThreadLocal的用途\" class=\"headerlink\" title=\"ThreadLocal的用途\"></a>ThreadLocal的用途</h3><p>◆典型场景1:每个线程需要—个独享的对象（通常是工具类（线程不安全），典型需要使用的类有 SimpleDateFormat和 Random）</p>\n<p>◆典型场景2:每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。</p>\n<p>实例1：SimpleDateFormat的格式化日期</p>\n<p>（1）2个线程分别用自己的 SimpleDateFormat，这没问题。<br>（2）后来延伸出10个，那就有10个线程和10个SimpleDate Format，这虽然写法不优雅（应该复用对象）但勉强可以接受。<br>（3）但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）。<br>（4）所有的线程都共用同一个 simple Date Format对象（加锁）。</p>","more":"<p>实例2:当前用户信息需要被线程内所有方法共享</p>\n<p>◆一个比较繁琐的解决方案是把user作为参数层层传递，从 service-1传到 service-2，再从 service-2传到 Service-3，以此类推，但是这样做会导致代码冗余且不易维护。</p>\n<p>◆每个线程内需要保存全局变量，可以让不同方法直接使用，避免参数传递的麻烦。</p>\n<p>◆在此基础上可以演进，使用 UserMap。</p>\n<p>◆当多线程同时工作时，我们需要保证线程安全，可以用 synchronized也可以用 ConcurrentHash Map，但无论用什么，都会对性能有所影响。</p>\n<p>更好的办法是使用ThreadLocal，这样无需synchronized， 可以在不影响性能的情况下，也无需层传递参数，就可达到保存当前线程对应的用户信息的目的</p>\n<p>◆用 ThreadLocal中保存一些业务内容（用户权限信息、从用户系统获取到的用户名、ID等）。</p>\n<p>◆这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。</p>\n<p>◆在线程生命周期内，都通过这个静态 Threadlocal实例的get()方法取得自己set()过的那个对象，避免了将这个对象（例如user对象）作为参数传递的麻烦。</p>\n<p>◆强调的是同一个请求内（同一个线程内）不同方法间的共享。</p>\n<p>◆不需重写 initialValue0方法，但是必须手动调用set0方法。</p>\n<h3 id=\"Threadloca的两个作用\"><a href=\"#Threadloca的两个作用\" class=\"headerlink\" title=\"Threadloca的两个作用\"></a>Threadloca的两个作用</h3><p>1.让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</p>\n<p>2.在任何方法中都可以轻松获取到该对象</p>\n<h3 id=\"ThreadLocal的好处\"><a href=\"#ThreadLocal的好处\" class=\"headerlink\" title=\"ThreadLocal的好处\"></a>ThreadLocal的好处</h3><ul>\n<li>达到线程安全</li>\n<li>不需要加锁，提高执行效率</li>\n<li>更高效的利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat,显然用ThreadLocal可以节省内存和开销。</li>\n<li>免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度更低，更优雅</li>\n</ul>\n<h3 id=\"原理、源码分析\"><a href=\"#原理、源码分析\" class=\"headerlink\" title=\"原理、源码分析\"></a>原理、源码分析</h3><p><img src=\"/articleImage/2020-07-28/1.png\" alt=\"原理图\"></p>\n<p>搞清楚Thread,ThreadLocal以及ThreadLocalMap三者之间的关系</p>\n<p>每个Thread对象中都持有一个ThreadLocalMap成员变量</p>\n<h4 id=\"主要方法介绍\"><a href=\"#主要方法介绍\" class=\"headerlink\" title=\"主要方法介绍\"></a>主要方法介绍</h4><p><strong>initialValue()</strong><br>1.该方法会返回当前线程对应的“初始值”，这是一个延迟加载的方法，只有在调用get的时候，才会触发。<br>2.当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法<br>3.通常，每个线程最多调用一次此方法，但如果已经调用了remove()后，再调用get()，则可以再次调用此方法<br>4.如果不重写本方法，这个方法默认返回null。一般使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象</p>\n<p><strong>set()</strong></p>\n<p>为这个线程设置一个新值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">       map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>get()</strong></p>\n<p>得到这个线程对应的value。<br>如果是首次调用get()，则会调用initialize来得到这个值；get方法是先取出当前线程的ThreadLocalMap，然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的Value</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>remove</strong>()</p>\n<p>删除对应这个线程的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ThreadLocalMap类，也就是Thread.threadLocals<br>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[]table,可以任务是一个map，键值对：<br>    键：当前ThreadLocal<br>    值：实际需要的成员变量    </p>\n<p><strong>ThreadLocalMap解决冲突的方式</strong></p>\n<p>HashMap 处理冲突：拉链法–&gt;红黑树</p>\n<p>ThreadLocalMap这里采用的是线性探测法，也就是如果发生冲突，就继续找下一个空位置。</p>\n<h4 id=\"内存泄漏问题\"><a href=\"#内存泄漏问题\" class=\"headerlink\" title=\"内存泄漏问题\"></a>内存泄漏问题</h4><p>什么是内存泄漏：某个对象不再使用了，但是占用的内存却不能被回收</p>\n<p>弱引用的特点是，如果这个对象只被弱引用关联（没有任何强引用关联），那么这个对象就可以被回收</p>\n<p>弱引用不会阻止GC，因此这个弱引用的机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">       Object value;</span><br><span class=\"line\">\t   Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">       value = v;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Value的泄漏</p>\n<p>（1）ThreadLocalMap的每个Entry都是一个对 Key的弱引用，同时每个Entry都包含了一个队value的强引用。</p>\n<p>正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。但是，如果线程不终止（比如线程需要保持很久），那么key对应的value就不能被回收。因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM。</p>\n<p>（2）JDK已经考虑到了这个问题，所以在set，remove,rehash方法中会扫描 key 为null的 Entry，并把对应的value设置为null，这样value对象就可以被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Entry[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldLen = oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLen = oldLen * <span class=\"number\">2</span>;</span><br><span class=\"line\">    Entry[] newTab = <span class=\"keyword\">new</span> Entry[newLen];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class=\"line\">          Entry e = oldTab[j];</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help the GC</span></span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (newTab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, newLen);</span><br><span class=\"line\">                  newTab[h] = e;</span><br><span class=\"line\">                 count++;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">     setThreshold(newLen);</span><br><span class=\"line\">     size = count;</span><br><span class=\"line\">     table = newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）但是如果一个ThreadLocal不被使用，那么实际上set，remove，rehash方法也不会被调用，如果同时线程又不停止，呢么调用链就一直存在，那么就导致了value的内存泄漏。</p>\n<p>（4）调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏。所以使用完ThreadLocal后，应该主动调用remove()方法。</p>\n<h4 id=\"ThreadLocal注意的点\"><a href=\"#ThreadLocal注意的点\" class=\"headerlink\" title=\"ThreadLocal注意的点\"></a>ThreadLocal注意的点</h4><h5 id=\"空指针异常\"><a href=\"#空指针异常\" class=\"headerlink\" title=\"空指针异常\"></a>空指针异常</h5><p>若ThreadLocal 没有提前赋值，则返回null，此时应注意包装类的装箱拆箱会导致NPE （若用基本类型接收null即会NPE）</p>\n<h5 id=\"共享对象\"><a href=\"#共享对象\" class=\"headerlink\" title=\"共享对象\"></a>共享对象</h5><p>如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的ThreadLocal.get()取得得还是这个共享对象本身，还是有并发访问问题。</p>\n<p><strong>灵活运用</strong></p>\n<p>如果可以不适用ThreadLocal就可以解决问题，那么不要强行使用：<br>例如在任务数很少的时候，在局部变量中可以新建对象就可以解决问题，那么就不需要使用到ThreadLocal。</p>\n<p>优先使用框架的支持，而不是自己创造：<br>例如在Spring中，如果可以使用RequestContextHolder,那么就不需要自己维护ThreadLocal，因为自己可能会忘记调用remove()方法等，造成内存泄漏。</p>\n<h4 id=\"实际应用场景–在Spring中的实例\"><a href=\"#实际应用场景–在Spring中的实例\" class=\"headerlink\" title=\"实际应用场景–在Spring中的实例\"></a>实际应用场景–在Spring中的实例</h4><p>DateTimeContextHolder</p>\n<p>RequestContextHolder</p>\n<p><em>每次Http请求都对应一个线程，线程之间相互隔离，这就是ThreadLocal的典型应用场景</em></p>"},{"title":"VPS安装及配置nginx","date":"2017-01-04T05:43:14.000Z","_content":"\n反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。\n![](/img/articleImg/nginx.jpg)\n<!--more-->\n## 环境确认\n系统环境：Centos 6\n安装方式：源码编译安装 [几种Linux软件的安装方法](http://www.285868.com/a/xtjc/5635.html)\n安装位置：/usr/local/nginx\n## 安装前提\n在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。\n## 开始安装\n进入安装目录\n{% codeblock %}\n cd /usr/local/src\n{% endcodeblock %}\n### 安装pcre(用于Nginx的HTTP Rewrite 模块)\n>注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。\n>另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。\n\n{% codeblock %}\ncd /usr/local/src \nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz  \t   \ntar -zxvf pcre-8.38.tar.gz #解压文件\nmv pcre-8.38   pcre #修改解压后文件夹名称\ncd pcre\n./configure \t\t#准备编译\nmake & make install\t#编译及安装\n{% endcodeblock %}\n\n### 安装zilb(一个压缩和解压模块)\n{% codeblock %}\ncd /usr/local/src\nwget http://zlib.net/zlib-1.2.8.tar.gz\ntar -zxvf zlib-1.2.8.tar.gz\nmv zlib-1.2.8 zlib\ncd zlib\n./configure\nmake & make install\n{% endcodeblock %}\n### 安装SSl模块\n>openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。\n\n{% codeblock %}\ncd /usr/local/src\nwget http://www.openssl.org/source/openssl-1.0.1c.tar.gz\ntar -zxvf openssl-1.0.1c.tar.gz\nmv openssl-1.0.1c  openssl\n./config\nmake & make install\n{% endcodeblock %}\n\n### 安装Nginx\n{% codeblock %}\ncd /usr/local/src\nwget http://nginx.org/download/nginx-1.9.9.tar.gz\ntar -zxvf nginx-1.9.9.tar.gz\ncd nginx-1.9.9\n\n./configure --sbin-path=/usr/local/nginx \\\n--conf-path=/usr/local/nginx/nginx.conf \\\n--pid-path=/usr/local/nginx/nginx.pid \\\n--with-http_ssl_module \\\n--with-http_v2_module \\\n--with-pcre=/usr/local/src/pcre \\\n--with-zlib=/usr/local/src/zlib \\\n--with-openssl=/usr/local/src/openssl\n\nmake & make install\n\ncd /usr/local/nginx #进入nginx目录\nnginx\t\t\t\t#启动nginx\n{% endcodeblock %}\n启动后浏览器导航到http://IP 就可以看到默认的欢迎界面了\n\n### Nginx常用命令\n{% codeblock %}\n nginx -s stop停止nginx\n nginx 运行nginx\n nginx -s reload 重启nginx\n nginx -t 测试nginx\n{% endcodeblock %}\n### nginx加入到环境变量\n{% codeblock %}\n vim /etc/profile\n{% endcodeblock %}\n尾行添加\n{% codeblock %}\nPATH=$PATH:/usr/local/nginx #nginx安装目录\nexport PATH \n{% endcodeblock %}\n保存关闭后运行\n{% codeblock %}\n source /etc/profile\n{% endcodeblock %}\n### 修改网站默认根目录路径\n>网站默认根目录放在/usr/local/nginx/html\n\n{% codeblock %}\nvim /usr/local/nginx/conf/nginx.conf\n{% endcodeblock %}\n\n{% codeblock %}\nserver {\n\tlisten       80;\n\tserver_name  你的IP;\n\t#charset koi8-r;\n\n\t#access_log  logs/host.access.log  main;\n\tlocation / {\n\troot  /www/blog/public;\n\tindex index.html index.htm;\n\t}\n\t.\n\t.\n\t.\n}\n{% endcodeblock %}\nroot添加自己想要的根目录，重启nginx生效。","source":"_posts/vps-install-nginx.md","raw":"---\ntitle: VPS安装及配置nginx\ndate: 2017-01-04 13:43:14\ntags: \n\t- Nginx\ncategories:\n\t- 运维\n\t- Linux\t\n---\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。\n![](/img/articleImg/nginx.jpg)\n<!--more-->\n## 环境确认\n系统环境：Centos 6\n安装方式：源码编译安装 [几种Linux软件的安装方法](http://www.285868.com/a/xtjc/5635.html)\n安装位置：/usr/local/nginx\n## 安装前提\n在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。\n## 开始安装\n进入安装目录\n{% codeblock %}\n cd /usr/local/src\n{% endcodeblock %}\n### 安装pcre(用于Nginx的HTTP Rewrite 模块)\n>注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。\n>另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。\n\n{% codeblock %}\ncd /usr/local/src \nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz  \t   \ntar -zxvf pcre-8.38.tar.gz #解压文件\nmv pcre-8.38   pcre #修改解压后文件夹名称\ncd pcre\n./configure \t\t#准备编译\nmake & make install\t#编译及安装\n{% endcodeblock %}\n\n### 安装zilb(一个压缩和解压模块)\n{% codeblock %}\ncd /usr/local/src\nwget http://zlib.net/zlib-1.2.8.tar.gz\ntar -zxvf zlib-1.2.8.tar.gz\nmv zlib-1.2.8 zlib\ncd zlib\n./configure\nmake & make install\n{% endcodeblock %}\n### 安装SSl模块\n>openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。\n\n{% codeblock %}\ncd /usr/local/src\nwget http://www.openssl.org/source/openssl-1.0.1c.tar.gz\ntar -zxvf openssl-1.0.1c.tar.gz\nmv openssl-1.0.1c  openssl\n./config\nmake & make install\n{% endcodeblock %}\n\n### 安装Nginx\n{% codeblock %}\ncd /usr/local/src\nwget http://nginx.org/download/nginx-1.9.9.tar.gz\ntar -zxvf nginx-1.9.9.tar.gz\ncd nginx-1.9.9\n\n./configure --sbin-path=/usr/local/nginx \\\n--conf-path=/usr/local/nginx/nginx.conf \\\n--pid-path=/usr/local/nginx/nginx.pid \\\n--with-http_ssl_module \\\n--with-http_v2_module \\\n--with-pcre=/usr/local/src/pcre \\\n--with-zlib=/usr/local/src/zlib \\\n--with-openssl=/usr/local/src/openssl\n\nmake & make install\n\ncd /usr/local/nginx #进入nginx目录\nnginx\t\t\t\t#启动nginx\n{% endcodeblock %}\n启动后浏览器导航到http://IP 就可以看到默认的欢迎界面了\n\n### Nginx常用命令\n{% codeblock %}\n nginx -s stop停止nginx\n nginx 运行nginx\n nginx -s reload 重启nginx\n nginx -t 测试nginx\n{% endcodeblock %}\n### nginx加入到环境变量\n{% codeblock %}\n vim /etc/profile\n{% endcodeblock %}\n尾行添加\n{% codeblock %}\nPATH=$PATH:/usr/local/nginx #nginx安装目录\nexport PATH \n{% endcodeblock %}\n保存关闭后运行\n{% codeblock %}\n source /etc/profile\n{% endcodeblock %}\n### 修改网站默认根目录路径\n>网站默认根目录放在/usr/local/nginx/html\n\n{% codeblock %}\nvim /usr/local/nginx/conf/nginx.conf\n{% endcodeblock %}\n\n{% codeblock %}\nserver {\n\tlisten       80;\n\tserver_name  你的IP;\n\t#charset koi8-r;\n\n\t#access_log  logs/host.access.log  main;\n\tlocation / {\n\troot  /www/blog/public;\n\tindex index.html index.htm;\n\t}\n\t.\n\t.\n\t.\n}\n{% endcodeblock %}\nroot添加自己想要的根目录，重启nginx生效。","slug":"vps-install-nginx","published":1,"updated":"2020-07-02T03:35:07.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtu3001rycto33be78wc","content":"<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br><img src=\"/img/articleImg/nginx.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"环境确认\"><a href=\"#环境确认\" class=\"headerlink\" title=\"环境确认\"></a>环境确认</h2><p>系统环境：Centos 6<br>安装方式：源码编译安装 <a href=\"http://www.285868.com/a/xtjc/5635.html\" target=\"_blank\" rel=\"noopener\">几种Linux软件的安装方法</a><br>安装位置：/usr/local/nginx</p>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。</p>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p>进入安装目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装pcre-用于Nginx的HTTP-Rewrite-模块\"><a href=\"#安装pcre-用于Nginx的HTTP-Rewrite-模块\" class=\"headerlink\" title=\"安装pcre(用于Nginx的HTTP Rewrite 模块)\"></a>安装pcre(用于Nginx的HTTP Rewrite 模块)</h3><blockquote>\n<p>注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。<br>另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src </span><br><span class=\"line\">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.38.tar.gz  \t   </span><br><span class=\"line\">tar -zxvf pcre-8.38.tar.gz #解压文件</span><br><span class=\"line\">mv pcre-8.38   pcre #修改解压后文件夹名称</span><br><span class=\"line\">cd pcre</span><br><span class=\"line\">.&#x2F;configure \t\t#准备编译</span><br><span class=\"line\">make &amp; make install\t#编译及安装</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装zilb-一个压缩和解压模块\"><a href=\"#安装zilb-一个压缩和解压模块\" class=\"headerlink\" title=\"安装zilb(一个压缩和解压模块)\"></a>安装zilb(一个压缩和解压模块)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.8.tar.gz</span><br><span class=\"line\">tar -zxvf zlib-1.2.8.tar.gz</span><br><span class=\"line\">mv zlib-1.2.8 zlib</span><br><span class=\"line\">cd zlib</span><br><span class=\"line\">.&#x2F;configure</span><br><span class=\"line\">make &amp; make install</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装SSl模块\"><a href=\"#安装SSl模块\" class=\"headerlink\" title=\"安装SSl模块\"></a>安装SSl模块</h3><blockquote>\n<p>openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.1c.tar.gz</span><br><span class=\"line\">tar -zxvf openssl-1.0.1c.tar.gz</span><br><span class=\"line\">mv openssl-1.0.1c  openssl</span><br><span class=\"line\">.&#x2F;config</span><br><span class=\"line\">make &amp; make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装Nginx\"><a href=\"#安装Nginx\" class=\"headerlink\" title=\"安装Nginx\"></a>安装Nginx</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.9.9.tar.gz</span><br><span class=\"line\">tar -zxvf nginx-1.9.9.tar.gz</span><br><span class=\"line\">cd nginx-1.9.9</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;configure --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \\</span><br><span class=\"line\">--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf \\</span><br><span class=\"line\">--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid \\</span><br><span class=\"line\">--with-http_ssl_module \\</span><br><span class=\"line\">--with-http_v2_module \\</span><br><span class=\"line\">--with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre \\</span><br><span class=\"line\">--with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib \\</span><br><span class=\"line\">--with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;openssl</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;nginx #进入nginx目录</span><br><span class=\"line\">nginx\t\t\t\t#启动nginx</span><br></pre></td></tr></table></figure>\n<p>启动后浏览器导航到<a href=\"http://IP\" target=\"_blank\" rel=\"noopener\">http://IP</a> 就可以看到默认的欢迎界面了</p>\n<h3 id=\"Nginx常用命令\"><a href=\"#Nginx常用命令\" class=\"headerlink\" title=\"Nginx常用命令\"></a>Nginx常用命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s stop停止nginx</span><br><span class=\"line\">nginx 运行nginx</span><br><span class=\"line\">nginx -s reload 重启nginx</span><br><span class=\"line\">nginx -t 测试nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"nginx加入到环境变量\"><a href=\"#nginx加入到环境变量\" class=\"headerlink\" title=\"nginx加入到环境变量\"></a>nginx加入到环境变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>\n<p>尾行添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx #nginx安装目录</span><br><span class=\"line\">export PATH </span><br></pre></td></tr></table></figure>\n<p>保存关闭后运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改网站默认根目录路径\"><a href=\"#修改网站默认根目录路径\" class=\"headerlink\" title=\"修改网站默认根目录路径\"></a>修改网站默认根目录路径</h3><blockquote>\n<p>网站默认根目录放在/usr/local/nginx/html</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten       80;</span><br><span class=\"line\">\tserver_name  你的IP;</span><br><span class=\"line\">\t#charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">\t#access_log  logs&#x2F;host.access.log  main;</span><br><span class=\"line\">\tlocation &#x2F; &#123;</span><br><span class=\"line\">\troot  &#x2F;www&#x2F;blog&#x2F;public;</span><br><span class=\"line\">\tindex index.html index.htm;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.</span><br><span class=\"line\">\t.</span><br><span class=\"line\">\t.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>root添加自己想要的根目录，重启nginx生效。</p>\n","site":{"data":{}},"excerpt":"<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br><img src=\"/img/articleImg/nginx.jpg\" alt=\"\"></p>","more":"<h2 id=\"环境确认\"><a href=\"#环境确认\" class=\"headerlink\" title=\"环境确认\"></a>环境确认</h2><p>系统环境：Centos 6<br>安装方式：源码编译安装 <a href=\"http://www.285868.com/a/xtjc/5635.html\" target=\"_blank\" rel=\"noopener\">几种Linux软件的安装方法</a><br>安装位置：/usr/local/nginx</p>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>在安装nginx前，需要确保系统安装了g++、gcc、openssl-devel、pcre-devel和zlib-devel软件。</p>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p>进入安装目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装pcre-用于Nginx的HTTP-Rewrite-模块\"><a href=\"#安装pcre-用于Nginx的HTTP-Rewrite-模块\" class=\"headerlink\" title=\"安装pcre(用于Nginx的HTTP Rewrite 模块)\"></a>安装pcre(用于Nginx的HTTP Rewrite 模块)</h3><blockquote>\n<p>注：若使用wget方式下载安装包可能会出现地址变更导致下载失败。<br>另一种方式：xftp可进行文件传输，本地下载好安装包后，利用xftp传输即可。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src </span><br><span class=\"line\">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.38.tar.gz  \t   </span><br><span class=\"line\">tar -zxvf pcre-8.38.tar.gz #解压文件</span><br><span class=\"line\">mv pcre-8.38   pcre #修改解压后文件夹名称</span><br><span class=\"line\">cd pcre</span><br><span class=\"line\">.&#x2F;configure \t\t#准备编译</span><br><span class=\"line\">make &amp; make install\t#编译及安装</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装zilb-一个压缩和解压模块\"><a href=\"#安装zilb-一个压缩和解压模块\" class=\"headerlink\" title=\"安装zilb(一个压缩和解压模块)\"></a>安装zilb(一个压缩和解压模块)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.8.tar.gz</span><br><span class=\"line\">tar -zxvf zlib-1.2.8.tar.gz</span><br><span class=\"line\">mv zlib-1.2.8 zlib</span><br><span class=\"line\">cd zlib</span><br><span class=\"line\">.&#x2F;configure</span><br><span class=\"line\">make &amp; make install</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装SSl模块\"><a href=\"#安装SSl模块\" class=\"headerlink\" title=\"安装SSl模块\"></a>安装SSl模块</h3><blockquote>\n<p>openssl是为网络通信提供安全及数据完整性的一种安全协议，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.1c.tar.gz</span><br><span class=\"line\">tar -zxvf openssl-1.0.1c.tar.gz</span><br><span class=\"line\">mv openssl-1.0.1c  openssl</span><br><span class=\"line\">.&#x2F;config</span><br><span class=\"line\">make &amp; make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装Nginx\"><a href=\"#安装Nginx\" class=\"headerlink\" title=\"安装Nginx\"></a>安装Nginx</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class=\"line\">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.9.9.tar.gz</span><br><span class=\"line\">tar -zxvf nginx-1.9.9.tar.gz</span><br><span class=\"line\">cd nginx-1.9.9</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;configure --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \\</span><br><span class=\"line\">--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf \\</span><br><span class=\"line\">--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid \\</span><br><span class=\"line\">--with-http_ssl_module \\</span><br><span class=\"line\">--with-http_v2_module \\</span><br><span class=\"line\">--with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre \\</span><br><span class=\"line\">--with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib \\</span><br><span class=\"line\">--with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;openssl</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;nginx #进入nginx目录</span><br><span class=\"line\">nginx\t\t\t\t#启动nginx</span><br></pre></td></tr></table></figure>\n<p>启动后浏览器导航到<a href=\"http://IP\" target=\"_blank\" rel=\"noopener\">http://IP</a> 就可以看到默认的欢迎界面了</p>\n<h3 id=\"Nginx常用命令\"><a href=\"#Nginx常用命令\" class=\"headerlink\" title=\"Nginx常用命令\"></a>Nginx常用命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s stop停止nginx</span><br><span class=\"line\">nginx 运行nginx</span><br><span class=\"line\">nginx -s reload 重启nginx</span><br><span class=\"line\">nginx -t 测试nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"nginx加入到环境变量\"><a href=\"#nginx加入到环境变量\" class=\"headerlink\" title=\"nginx加入到环境变量\"></a>nginx加入到环境变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>\n<p>尾行添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx #nginx安装目录</span><br><span class=\"line\">export PATH </span><br></pre></td></tr></table></figure>\n<p>保存关闭后运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改网站默认根目录路径\"><a href=\"#修改网站默认根目录路径\" class=\"headerlink\" title=\"修改网站默认根目录路径\"></a>修改网站默认根目录路径</h3><blockquote>\n<p>网站默认根目录放在/usr/local/nginx/html</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten       80;</span><br><span class=\"line\">\tserver_name  你的IP;</span><br><span class=\"line\">\t#charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">\t#access_log  logs&#x2F;host.access.log  main;</span><br><span class=\"line\">\tlocation &#x2F; &#123;</span><br><span class=\"line\">\troot  &#x2F;www&#x2F;blog&#x2F;public;</span><br><span class=\"line\">\tindex index.html index.htm;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.</span><br><span class=\"line\">\t.</span><br><span class=\"line\">\t.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>root添加自己想要的根目录，重启nginx生效。</p>"},{"title":"VPS搭建多端口VPN","date":"2016-12-20T08:37:45.000Z","_content":"![](/img/articleImg/naruto.jpg)\n<!--more-->\n## 所需\n1.他乡vps一台\n2.xshell用于远程登录\n3.shadowsocks应用程序。[点这里](https://github.com/shadowsocks/shadowsocks-windows/releases)\n\n## Ready.\n1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。\n2.[购买VPS](http://hostingset.com/)\n3.打开xshell连接\n![](/img/articleImg/xshell.png)\n\n## GO！！\n1.安装所需组件\n{% codeblock %}\n yum install m2crypto python-setuptools\n easy_install pip\n pip install shadowsocks\n{% endcodeblock %}\n\n2.新建配置文件：shadowsocks.json\n{% codeblock %}\n{\n    \"server\":\"23.105.215.43\",   #你服务器的ip\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{           #端口以及对应的密码\n         \"9000\":\"password\",\n         \"9001\":\"password\",\n         \"9002\":\"password\"\n    },\n    \"timeout\":300,\n    \"method\":\"rc4-md5\",         #选择的加密方式\n    \"fast_open\": false\n}\n{% endcodeblock %}\n3添加\n{% codeblock %}\n ssserver -c /etc/shadowsocks.json\n\n ssserver -c /etc/shadowsocks.json -d start  #后台运行\n{% endcodeblock %}\n4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~\n5.Android用户想要连接本文配置的vpn,请搜下图app.\n![](/img/articleImg/shadowsocks.png)","source":"_posts/vps.md","raw":"---\ntitle: VPS搭建多端口VPN\ndate: 2016-12-20 16:37:45\ntags: \n\t- vpn\ncategories:\n\t- 运维\n\t- Linux\n---\n![](/img/articleImg/naruto.jpg)\n<!--more-->\n## 所需\n1.他乡vps一台\n2.xshell用于远程登录\n3.shadowsocks应用程序。[点这里](https://github.com/shadowsocks/shadowsocks-windows/releases)\n\n## Ready.\n1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。\n2.[购买VPS](http://hostingset.com/)\n3.打开xshell连接\n![](/img/articleImg/xshell.png)\n\n## GO！！\n1.安装所需组件\n{% codeblock %}\n yum install m2crypto python-setuptools\n easy_install pip\n pip install shadowsocks\n{% endcodeblock %}\n\n2.新建配置文件：shadowsocks.json\n{% codeblock %}\n{\n    \"server\":\"23.105.215.43\",   #你服务器的ip\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{           #端口以及对应的密码\n         \"9000\":\"password\",\n         \"9001\":\"password\",\n         \"9002\":\"password\"\n    },\n    \"timeout\":300,\n    \"method\":\"rc4-md5\",         #选择的加密方式\n    \"fast_open\": false\n}\n{% endcodeblock %}\n3添加\n{% codeblock %}\n ssserver -c /etc/shadowsocks.json\n\n ssserver -c /etc/shadowsocks.json -d start  #后台运行\n{% endcodeblock %}\n4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~\n5.Android用户想要连接本文配置的vpn,请搜下图app.\n![](/img/articleImg/shadowsocks.png)","slug":"vps","published":1,"updated":"2020-07-02T03:35:25.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtu6001vyctogtzy9c7b","content":"<p><img src=\"/img/articleImg/naruto.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"所需\"><a href=\"#所需\" class=\"headerlink\" title=\"所需\"></a>所需</h2><p>1.他乡vps一台<br>2.xshell用于远程登录<br>3.shadowsocks应用程序。<a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">点这里</a></p>\n<h2 id=\"Ready\"><a href=\"#Ready\" class=\"headerlink\" title=\"Ready.\"></a>Ready.</h2><p>1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。<br>2.<a href=\"http://hostingset.com/\" target=\"_blank\" rel=\"noopener\">购买VPS</a><br>3.打开xshell连接<br><img src=\"/img/articleImg/xshell.png\" alt=\"\"></p>\n<h2 id=\"GO！！\"><a href=\"#GO！！\" class=\"headerlink\" title=\"GO！！\"></a>GO！！</h2><p>1.安装所需组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install m2crypto python-setuptools</span><br><span class=\"line\">easy_install pip</span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n\n<p>2.新建配置文件：shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;23.105.215.43&quot;,   #你服务器的ip</span><br><span class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;port_password&quot;:&#123;           #端口以及对应的密码</span><br><span class=\"line\">         &quot;9000&quot;:&quot;password&quot;,</span><br><span class=\"line\">         &quot;9001&quot;:&quot;password&quot;,</span><br><span class=\"line\">         &quot;9002&quot;:&quot;password&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;rc4-md5&quot;,         #选择的加密方式</span><br><span class=\"line\">    &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class=\"line\"></span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start  #后台运行</span><br></pre></td></tr></table></figure>\n<p>4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~<br>5.Android用户想要连接本文配置的vpn,请搜下图app.<br><img src=\"/img/articleImg/shadowsocks.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/img/articleImg/naruto.jpg\" alt=\"\"></p>","more":"<h2 id=\"所需\"><a href=\"#所需\" class=\"headerlink\" title=\"所需\"></a>所需</h2><p>1.他乡vps一台<br>2.xshell用于远程登录<br>3.shadowsocks应用程序。<a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">点这里</a></p>\n<h2 id=\"Ready\"><a href=\"#Ready\" class=\"headerlink\" title=\"Ready.\"></a>Ready.</h2><p>1.本人装备的是搬瓦工的vps,好处是可以无限制的重装系统。<br>2.<a href=\"http://hostingset.com/\" target=\"_blank\" rel=\"noopener\">购买VPS</a><br>3.打开xshell连接<br><img src=\"/img/articleImg/xshell.png\" alt=\"\"></p>\n<h2 id=\"GO！！\"><a href=\"#GO！！\" class=\"headerlink\" title=\"GO！！\"></a>GO！！</h2><p>1.安装所需组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install m2crypto python-setuptools</span><br><span class=\"line\">easy_install pip</span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n\n<p>2.新建配置文件：shadowsocks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;23.105.215.43&quot;,   #你服务器的ip</span><br><span class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;port_password&quot;:&#123;           #端口以及对应的密码</span><br><span class=\"line\">         &quot;9000&quot;:&quot;password&quot;,</span><br><span class=\"line\">         &quot;9001&quot;:&quot;password&quot;,</span><br><span class=\"line\">         &quot;9002&quot;:&quot;password&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;rc4-md5&quot;,         #选择的加密方式</span><br><span class=\"line\">    &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class=\"line\"></span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start  #后台运行</span><br></pre></td></tr></table></figure>\n<p>4.开启shadowsocks应用程序，输入ip,端口号,密码。就OK啦~<br>5.Android用户想要连接本文配置的vpn,请搜下图app.<br><img src=\"/img/articleImg/shadowsocks.png\" alt=\"\"></p>"},{"title":"线程池","date":"2020-07-24T07:20:19.000Z","_content":"\n### 线程池的自我介绍\n\n* 线程池的重要性\n* 什么是“池”\n    * 软件中的“池”，也可以理解为计划经济\n* 如果不使用线程池，每个任务都新开一个线程处理\n    * 一个线程问题不大\n    * 当任务数量上升到1000，for循环创建线程\n* 这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。\n\n<!--more-->\n\n### 为什么要使用线程池\n问题一：反复创建线程开销大\n问题二：过多的线程会占用太多内存\n解决以上两个问题的思路:\n①用少量的线程--避免内存占用过多\n②让这部分线程都保持工作，且可以反复执行任务\n\n### 线程池的好处\n* 加快响应速度\n* 合理利用CPU和内存\n* 统一管理\n\n### 线程池适合应用的场合\n* 服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率\n* 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理\n\n### 创建和停止线程池\n\n* 线程池构造函数的参数\n* 线程池应该手动创建还是自动创建\n* 线程池里的线程数量设定为多少比较合适？\n* 停止线程池的正确方法\n\n#### 线程池构造函数的参数\n\n![HTTP](/articleImage/2020-07-24/线程池构造函数的参数.png)\n\n**corePoolSize（核心线程数）**\n线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来再创建新线程去执行任务。\n\n**maximumPoolSize（最大线程数）**\n线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maximumPoolSize。\n\n**keepAliveTime（存活时间）**\n如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过KeepAliveTime，它们就会被终止。\n\n**threadFactory（线程工厂）**\n 用来创建线程,新的线程是由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。如果自己指定 ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。\n\n**workQueue(工作队列)**\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务\nArrayBlockingQueue:基于数组的有界阻塞队列，按FIFO排序。\nLinkedBlockingQuene:基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\n\n**handler（拒绝策略）** \nAbortPolicy ：抛出异常\nDiscardPolicy : 直接丢弃，无通知\nDiscardOldestPolicy : 丢弃最早的任务\nCallerRunsPolicy ：由提交任务的线程去执行任务\n\n#### 添加线程规则\n\n1.如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。\n2.如果线程数等于（或大于）corePoolSize但少于maxPoolSize，则将任务放入队列。\n3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来执行任务。\n4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。\n\n是否需要增加线程的判断顺序是：\n\ncorePoolSize>>workQueue>>maxPoolSize\n\n![HTTP](/articleImage/2020-07-24/线程池添加线程规则.png)\n\n\n#### 增减线程的特点\n1.通过设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程池。\n2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。\n3.通过设置maxPoolSize为很高的值，例如 Integer.MAX_VALUE 可以允许线程池容纳任意数量的并发任务。\n4.是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。\n\n#### 线程池应该手动创建还是自动创建\n手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。\n\n◆ newFixedPool\n由于传进去的 LinkedBlockingQueue，是没有容量上限的所以当请求数越来越多，并且无法及时处理完毕的时候，\n也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM\n\n◆newSingleThreadExecutor\n 可以看出，这里和刚才的 newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存。\n\n◆newCachedThreadPool\n可缓存线程池\n特点:无界线程池，具有自动回收多余线程的功能\n这里的弊端在于第二个参数 maximum Poolsize被设置为了 Integer. MAX_ VALUE，这可能会创建数量非常多的线程，甚至导致OOM。\n\n◆ScheduledThreadPool\n支持定时及周期性任务执行的线程池\n\n#### 正确的创建线程池的方法\n\n根据不同的业务场景，自己设置线程池参数，比如我们的\n内存有多大，我们想给线程取什么名字等等\n\n**线程池里的线程数量设定为多少比较合适？**\n\n**CPU集型**（加控计算hash等）:最佳线程数为CPU核心数的1-2倍左右。\n**耗时IO型**（读写数据库、文件、网络读写等）:最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为\n依据，保证线程空闲可以衔接上，参考 Brain Goetz推荐的计算方法:\n\n◆线程数=CPU核心数*（1+平均等待时间/平均工作时间）\n\n#### 停止线程池的正确方法\n\n1.shutdown，只是起到通知的作用,告诉线程池停止运行，此时线程不再接受新的任务，isShutDown=true。\n2..isTerminated：真正的结束状态。\n3.awaitTermination：等待一定时间后判断线程池是否已结束。\n4.shutdownNow：主动中断所有子线程。\n\n正确的调用顺序应该是: shutdown>>awaitTermination？shutdownNow","source":"_posts/线程池.md","raw":"---\ntitle: 线程池\ndate: 2020-07-24 15:20:19\ncategories:\n\t- Java并发\n\t- 线程池\n---\n\n### 线程池的自我介绍\n\n* 线程池的重要性\n* 什么是“池”\n    * 软件中的“池”，也可以理解为计划经济\n* 如果不使用线程池，每个任务都新开一个线程处理\n    * 一个线程问题不大\n    * 当任务数量上升到1000，for循环创建线程\n* 这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。\n\n<!--more-->\n\n### 为什么要使用线程池\n问题一：反复创建线程开销大\n问题二：过多的线程会占用太多内存\n解决以上两个问题的思路:\n①用少量的线程--避免内存占用过多\n②让这部分线程都保持工作，且可以反复执行任务\n\n### 线程池的好处\n* 加快响应速度\n* 合理利用CPU和内存\n* 统一管理\n\n### 线程池适合应用的场合\n* 服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率\n* 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理\n\n### 创建和停止线程池\n\n* 线程池构造函数的参数\n* 线程池应该手动创建还是自动创建\n* 线程池里的线程数量设定为多少比较合适？\n* 停止线程池的正确方法\n\n#### 线程池构造函数的参数\n\n![HTTP](/articleImage/2020-07-24/线程池构造函数的参数.png)\n\n**corePoolSize（核心线程数）**\n线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来再创建新线程去执行任务。\n\n**maximumPoolSize（最大线程数）**\n线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maximumPoolSize。\n\n**keepAliveTime（存活时间）**\n如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过KeepAliveTime，它们就会被终止。\n\n**threadFactory（线程工厂）**\n 用来创建线程,新的线程是由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。如果自己指定 ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。\n\n**workQueue(工作队列)**\n新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务\nArrayBlockingQueue:基于数组的有界阻塞队列，按FIFO排序。\nLinkedBlockingQuene:基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。\n\n**handler（拒绝策略）** \nAbortPolicy ：抛出异常\nDiscardPolicy : 直接丢弃，无通知\nDiscardOldestPolicy : 丢弃最早的任务\nCallerRunsPolicy ：由提交任务的线程去执行任务\n\n#### 添加线程规则\n\n1.如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。\n2.如果线程数等于（或大于）corePoolSize但少于maxPoolSize，则将任务放入队列。\n3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来执行任务。\n4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。\n\n是否需要增加线程的判断顺序是：\n\ncorePoolSize>>workQueue>>maxPoolSize\n\n![HTTP](/articleImage/2020-07-24/线程池添加线程规则.png)\n\n\n#### 增减线程的特点\n1.通过设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程池。\n2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。\n3.通过设置maxPoolSize为很高的值，例如 Integer.MAX_VALUE 可以允许线程池容纳任意数量的并发任务。\n4.是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。\n\n#### 线程池应该手动创建还是自动创建\n手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。\n\n◆ newFixedPool\n由于传进去的 LinkedBlockingQueue，是没有容量上限的所以当请求数越来越多，并且无法及时处理完毕的时候，\n也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM\n\n◆newSingleThreadExecutor\n 可以看出，这里和刚才的 newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存。\n\n◆newCachedThreadPool\n可缓存线程池\n特点:无界线程池，具有自动回收多余线程的功能\n这里的弊端在于第二个参数 maximum Poolsize被设置为了 Integer. MAX_ VALUE，这可能会创建数量非常多的线程，甚至导致OOM。\n\n◆ScheduledThreadPool\n支持定时及周期性任务执行的线程池\n\n#### 正确的创建线程池的方法\n\n根据不同的业务场景，自己设置线程池参数，比如我们的\n内存有多大，我们想给线程取什么名字等等\n\n**线程池里的线程数量设定为多少比较合适？**\n\n**CPU集型**（加控计算hash等）:最佳线程数为CPU核心数的1-2倍左右。\n**耗时IO型**（读写数据库、文件、网络读写等）:最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为\n依据，保证线程空闲可以衔接上，参考 Brain Goetz推荐的计算方法:\n\n◆线程数=CPU核心数*（1+平均等待时间/平均工作时间）\n\n#### 停止线程池的正确方法\n\n1.shutdown，只是起到通知的作用,告诉线程池停止运行，此时线程不再接受新的任务，isShutDown=true。\n2..isTerminated：真正的结束状态。\n3.awaitTermination：等待一定时间后判断线程池是否已结束。\n4.shutdownNow：主动中断所有子线程。\n\n正确的调用顺序应该是: shutdown>>awaitTermination？shutdownNow","slug":"线程池","published":1,"updated":"2020-07-24T08:07:06.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtu9001zyctodttdcmf2","content":"<h3 id=\"线程池的自我介绍\"><a href=\"#线程池的自我介绍\" class=\"headerlink\" title=\"线程池的自我介绍\"></a>线程池的自我介绍</h3><ul>\n<li>线程池的重要性</li>\n<li>什么是“池”<ul>\n<li>软件中的“池”，也可以理解为计划经济</li>\n</ul>\n</li>\n<li>如果不使用线程池，每个任务都新开一个线程处理<ul>\n<li>一个线程问题不大</li>\n<li>当任务数量上升到1000，for循环创建线程</li>\n</ul>\n</li>\n<li>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"为什么要使用线程池\"><a href=\"#为什么要使用线程池\" class=\"headerlink\" title=\"为什么要使用线程池\"></a>为什么要使用线程池</h3><p>问题一：反复创建线程开销大<br>问题二：过多的线程会占用太多内存<br>解决以上两个问题的思路:<br>①用少量的线程–避免内存占用过多<br>②让这部分线程都保持工作，且可以反复执行任务</p>\n<h3 id=\"线程池的好处\"><a href=\"#线程池的好处\" class=\"headerlink\" title=\"线程池的好处\"></a>线程池的好处</h3><ul>\n<li>加快响应速度</li>\n<li>合理利用CPU和内存</li>\n<li>统一管理</li>\n</ul>\n<h3 id=\"线程池适合应用的场合\"><a href=\"#线程池适合应用的场合\" class=\"headerlink\" title=\"线程池适合应用的场合\"></a>线程池适合应用的场合</h3><ul>\n<li>服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li>\n<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>\n</ul>\n<h3 id=\"创建和停止线程池\"><a href=\"#创建和停止线程池\" class=\"headerlink\" title=\"创建和停止线程池\"></a>创建和停止线程池</h3><ul>\n<li>线程池构造函数的参数</li>\n<li>线程池应该手动创建还是自动创建</li>\n<li>线程池里的线程数量设定为多少比较合适？</li>\n<li>停止线程池的正确方法</li>\n</ul>\n<h4 id=\"线程池构造函数的参数\"><a href=\"#线程池构造函数的参数\" class=\"headerlink\" title=\"线程池构造函数的参数\"></a>线程池构造函数的参数</h4><p><img src=\"/articleImage/2020-07-24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0.png\" alt=\"HTTP\"></p>\n<p><strong>corePoolSize（核心线程数）</strong><br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来再创建新线程去执行任务。</p>\n<p><strong>maximumPoolSize（最大线程数）</strong><br>线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maximumPoolSize。</p>\n<p><strong>keepAliveTime（存活时间）</strong><br>如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过KeepAliveTime，它们就会被终止。</p>\n<p><strong>threadFactory（线程工厂）</strong><br> 用来创建线程,新的线程是由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。如果自己指定 ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</p>\n<p><strong>workQueue(工作队列)</strong><br>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务<br>ArrayBlockingQueue:基于数组的有界阻塞队列，按FIFO排序。<br>LinkedBlockingQuene:基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>\n<p><strong>handler（拒绝策略）</strong><br>AbortPolicy ：抛出异常<br>DiscardPolicy : 直接丢弃，无通知<br>DiscardOldestPolicy : 丢弃最早的任务<br>CallerRunsPolicy ：由提交任务的线程去执行任务</p>\n<h4 id=\"添加线程规则\"><a href=\"#添加线程规则\" class=\"headerlink\" title=\"添加线程规则\"></a>添加线程规则</h4><p>1.如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。<br>2.如果线程数等于（或大于）corePoolSize但少于maxPoolSize，则将任务放入队列。<br>3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来执行任务。<br>4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。</p>\n<p>是否需要增加线程的判断顺序是：</p>\n<p>corePoolSize&gt;&gt;workQueue&gt;&gt;maxPoolSize</p>\n<p><img src=\"/articleImage/2020-07-24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png\" alt=\"HTTP\"></p>\n<h4 id=\"增减线程的特点\"><a href=\"#增减线程的特点\" class=\"headerlink\" title=\"增减线程的特点\"></a>增减线程的特点</h4><p>1.通过设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程池。<br>2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。<br>3.通过设置maxPoolSize为很高的值，例如 Integer.MAX_VALUE 可以允许线程池容纳任意数量的并发任务。<br>4.是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。</p>\n<h4 id=\"线程池应该手动创建还是自动创建\"><a href=\"#线程池应该手动创建还是自动创建\" class=\"headerlink\" title=\"线程池应该手动创建还是自动创建\"></a>线程池应该手动创建还是自动创建</h4><p>手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。</p>\n<p>◆ newFixedPool<br>由于传进去的 LinkedBlockingQueue，是没有容量上限的所以当请求数越来越多，并且无法及时处理完毕的时候，<br>也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM</p>\n<p>◆newSingleThreadExecutor<br> 可以看出，这里和刚才的 newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存。</p>\n<p>◆newCachedThreadPool<br>可缓存线程池<br>特点:无界线程池，具有自动回收多余线程的功能<br>这里的弊端在于第二个参数 maximum Poolsize被设置为了 Integer. MAX_ VALUE，这可能会创建数量非常多的线程，甚至导致OOM。</p>\n<p>◆ScheduledThreadPool<br>支持定时及周期性任务执行的线程池</p>\n<h4 id=\"正确的创建线程池的方法\"><a href=\"#正确的创建线程池的方法\" class=\"headerlink\" title=\"正确的创建线程池的方法\"></a>正确的创建线程池的方法</h4><p>根据不同的业务场景，自己设置线程池参数，比如我们的<br>内存有多大，我们想给线程取什么名字等等</p>\n<p><strong>线程池里的线程数量设定为多少比较合适？</strong></p>\n<p><strong>CPU集型</strong>（加控计算hash等）:最佳线程数为CPU核心数的1-2倍左右。<br><strong>耗时IO型</strong>（读写数据库、文件、网络读写等）:最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为<br>依据，保证线程空闲可以衔接上，参考 Brain Goetz推荐的计算方法:</p>\n<p>◆线程数=CPU核心数*（1+平均等待时间/平均工作时间）</p>\n<h4 id=\"停止线程池的正确方法\"><a href=\"#停止线程池的正确方法\" class=\"headerlink\" title=\"停止线程池的正确方法\"></a>停止线程池的正确方法</h4><p>1.shutdown，只是起到通知的作用,告诉线程池停止运行，此时线程不再接受新的任务，isShutDown=true。<br>2..isTerminated：真正的结束状态。<br>3.awaitTermination：等待一定时间后判断线程池是否已结束。<br>4.shutdownNow：主动中断所有子线程。</p>\n<p>正确的调用顺序应该是: shutdown&gt;&gt;awaitTermination？shutdownNow</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"线程池的自我介绍\"><a href=\"#线程池的自我介绍\" class=\"headerlink\" title=\"线程池的自我介绍\"></a>线程池的自我介绍</h3><ul>\n<li>线程池的重要性</li>\n<li>什么是“池”<ul>\n<li>软件中的“池”，也可以理解为计划经济</li>\n</ul>\n</li>\n<li>如果不使用线程池，每个任务都新开一个线程处理<ul>\n<li>一个线程问题不大</li>\n<li>当任务数量上升到1000，for循环创建线程</li>\n</ul>\n</li>\n<li>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题。</li>\n</ul>","more":"<h3 id=\"为什么要使用线程池\"><a href=\"#为什么要使用线程池\" class=\"headerlink\" title=\"为什么要使用线程池\"></a>为什么要使用线程池</h3><p>问题一：反复创建线程开销大<br>问题二：过多的线程会占用太多内存<br>解决以上两个问题的思路:<br>①用少量的线程–避免内存占用过多<br>②让这部分线程都保持工作，且可以反复执行任务</p>\n<h3 id=\"线程池的好处\"><a href=\"#线程池的好处\" class=\"headerlink\" title=\"线程池的好处\"></a>线程池的好处</h3><ul>\n<li>加快响应速度</li>\n<li>合理利用CPU和内存</li>\n<li>统一管理</li>\n</ul>\n<h3 id=\"线程池适合应用的场合\"><a href=\"#线程池适合应用的场合\" class=\"headerlink\" title=\"线程池适合应用的场合\"></a>线程池适合应用的场合</h3><ul>\n<li>服务器接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li>\n<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>\n</ul>\n<h3 id=\"创建和停止线程池\"><a href=\"#创建和停止线程池\" class=\"headerlink\" title=\"创建和停止线程池\"></a>创建和停止线程池</h3><ul>\n<li>线程池构造函数的参数</li>\n<li>线程池应该手动创建还是自动创建</li>\n<li>线程池里的线程数量设定为多少比较合适？</li>\n<li>停止线程池的正确方法</li>\n</ul>\n<h4 id=\"线程池构造函数的参数\"><a href=\"#线程池构造函数的参数\" class=\"headerlink\" title=\"线程池构造函数的参数\"></a>线程池构造函数的参数</h4><p><img src=\"/articleImage/2020-07-24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0.png\" alt=\"HTTP\"></p>\n<p><strong>corePoolSize（核心线程数）</strong><br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来再创建新线程去执行任务。</p>\n<p><strong>maximumPoolSize（最大线程数）</strong><br>线程池有可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maximumPoolSize。</p>\n<p><strong>keepAliveTime（存活时间）</strong><br>如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过KeepAliveTime，它们就会被终止。</p>\n<p><strong>threadFactory（线程工厂）</strong><br> 用来创建线程,新的线程是由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。如果自己指定 ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</p>\n<p><strong>workQueue(工作队列)</strong><br>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务<br>ArrayBlockingQueue:基于数组的有界阻塞队列，按FIFO排序。<br>LinkedBlockingQuene:基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>\n<p><strong>handler（拒绝策略）</strong><br>AbortPolicy ：抛出异常<br>DiscardPolicy : 直接丢弃，无通知<br>DiscardOldestPolicy : 丢弃最早的任务<br>CallerRunsPolicy ：由提交任务的线程去执行任务</p>\n<h4 id=\"添加线程规则\"><a href=\"#添加线程规则\" class=\"headerlink\" title=\"添加线程规则\"></a>添加线程规则</h4><p>1.如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务。<br>2.如果线程数等于（或大于）corePoolSize但少于maxPoolSize，则将任务放入队列。<br>3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来执行任务。<br>4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。</p>\n<p>是否需要增加线程的判断顺序是：</p>\n<p>corePoolSize&gt;&gt;workQueue&gt;&gt;maxPoolSize</p>\n<p><img src=\"/articleImage/2020-07-24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png\" alt=\"HTTP\"></p>\n<h4 id=\"增减线程的特点\"><a href=\"#增减线程的特点\" class=\"headerlink\" title=\"增减线程的特点\"></a>增减线程的特点</h4><p>1.通过设置corePoolSize和maxPoolSize相同，就可以创建固定大小的线程池。<br>2.线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它。<br>3.通过设置maxPoolSize为很高的值，例如 Integer.MAX_VALUE 可以允许线程池容纳任意数量的并发任务。<br>4.是只有在队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。</p>\n<h4 id=\"线程池应该手动创建还是自动创建\"><a href=\"#线程池应该手动创建还是自动创建\" class=\"headerlink\" title=\"线程池应该手动创建还是自动创建\"></a>线程池应该手动创建还是自动创建</h4><p>手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。</p>\n<p>◆ newFixedPool<br>由于传进去的 LinkedBlockingQueue，是没有容量上限的所以当请求数越来越多，并且无法及时处理完毕的时候，<br>也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM</p>\n<p>◆newSingleThreadExecutor<br> 可以看出，这里和刚才的 newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存。</p>\n<p>◆newCachedThreadPool<br>可缓存线程池<br>特点:无界线程池，具有自动回收多余线程的功能<br>这里的弊端在于第二个参数 maximum Poolsize被设置为了 Integer. MAX_ VALUE，这可能会创建数量非常多的线程，甚至导致OOM。</p>\n<p>◆ScheduledThreadPool<br>支持定时及周期性任务执行的线程池</p>\n<h4 id=\"正确的创建线程池的方法\"><a href=\"#正确的创建线程池的方法\" class=\"headerlink\" title=\"正确的创建线程池的方法\"></a>正确的创建线程池的方法</h4><p>根据不同的业务场景，自己设置线程池参数，比如我们的<br>内存有多大，我们想给线程取什么名字等等</p>\n<p><strong>线程池里的线程数量设定为多少比较合适？</strong></p>\n<p><strong>CPU集型</strong>（加控计算hash等）:最佳线程数为CPU核心数的1-2倍左右。<br><strong>耗时IO型</strong>（读写数据库、文件、网络读写等）:最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为<br>依据，保证线程空闲可以衔接上，参考 Brain Goetz推荐的计算方法:</p>\n<p>◆线程数=CPU核心数*（1+平均等待时间/平均工作时间）</p>\n<h4 id=\"停止线程池的正确方法\"><a href=\"#停止线程池的正确方法\" class=\"headerlink\" title=\"停止线程池的正确方法\"></a>停止线程池的正确方法</h4><p>1.shutdown，只是起到通知的作用,告诉线程池停止运行，此时线程不再接受新的任务，isShutDown=true。<br>2..isTerminated：真正的结束状态。<br>3.awaitTermination：等待一定时间后判断线程池是否已结束。<br>4.shutdownNow：主动中断所有子线程。</p>\n<p>正确的调用顺序应该是: shutdown&gt;&gt;awaitTermination？shutdownNow</p>"},{"title":"计算机网络","date":"2020-07-03T03:18:54.000Z","_content":"\n### 网络基础知识\n\n![七层协议](/articleImage/2020-07-03/1.png)\n\n##### 第一层：物理层\n\n解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。\n物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率\n主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。\n层数据：比特\n存在的物理设备：网卡\n\n<!--more-->\n\n##### 第二层：数据链路层\n\n在传输比特流的时候会出现错传、传输不完整的情况，因此数据链路层应运而生，它定了如何格式化数据以进行传输，提供错误检测和纠正，以确保数据传输的可靠性\n层数据：帧\n存在的物理设备：交换机（对帧解码，并根据帧中包含的信息，把数据发送给正确的接收方）。\n\n##### 第三层，网络层\n\n随着网络节点的不断增加，点对点通信的时候需要经过多个结点，如何到达目标节点、如何选择最佳路径便成为了首要需求。\n作用：是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先级，网络拥塞程度，服务质量，可选路由的花费决定从节点A到结点B的最佳路径。\n层数据：（分组）数据报 存在的物理设备：路由器（由于网络层处理并智能指导数据传送，路由器连接网络各段）\n需要关注的协议： IP\n\n##### 第四层，传输层\n\n随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很多时间，而网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发出的数据进行切分，切割为一个一个的段落，即segment进行发送，其中一个段落丢失了该怎么办，要不要重传，每个段落要按照顺序到达吗。这便是传输层需要考虑的问题。\n传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，同时传输层解决了传输质量的问题，该层是OSI模型中最重要的一层。具有传输协议，同时进行流量控制，或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网不能直接接收大于1500字节的数据包，发送方结点的传输层将数据分割成较小的数据片，同时为每一数据片安排序列号，以便数据到达接收方结点的传输层时能以正确的顺序重组，该过程称为排序。\n层数据：分段\n需要关注的协议：TCP/UDP\n\n##### 第五层，会话层\n\n现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道每次都需要调用tcp协议去打包，然后调IP协议去找路由，自己去发，这样当然不行。因此我们要建立一个自动收发包，自动寻址的功能。于是发明了会话层\n作用：建立和管理应用程序间的通讯\n\n##### 第六层，表示层\n\n现在能保证应用程序能自动收发包和寻址，但我要用linux给windows发包，两个系统的语法不一致。\n作用：解决不同系统之间的通信语法问题，在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用网络的类型不同而不同。\n\n##### 第七层，应用层\n\n此时虽然发送方知道发送的是什么东西，转换成字节数组有多长，但接收方不知道，所以应用层的网络协议诞生了\n作用：规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，方便接受方能够正确解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层，你也可以直接在两台电脑传递，只不过都是1、0的字节数组。\n需要关注的协议：http协议\n\n从应用层开始都会对要传输信息的头部进行处理，加上本层的一些信息，最终物理层通过以太网，电缆等介质将数据解析成比特流，在网络中传输。数据传递到目标地址并自底而上的将头部的内容解析分离出来。\n\nOSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的指定。即OSI参考模型并不是一个标准，而是制定标准是所使用的概念性框架。\nTCP\\IP : OSI的一种实现\n\n![OSI](/articleImage/2020-07-03/osi.gif)","source":"_posts/计算机网络.md","raw":"---\ntitle: 计算机网络\ndate: 2020-07-03 11:18:54\ncategories:\n\t- Java面试\n\t- 计算机网络\n\n---\n\n### 网络基础知识\n\n![七层协议](/articleImage/2020-07-03/1.png)\n\n##### 第一层：物理层\n\n解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。\n物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率\n主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。\n层数据：比特\n存在的物理设备：网卡\n\n<!--more-->\n\n##### 第二层：数据链路层\n\n在传输比特流的时候会出现错传、传输不完整的情况，因此数据链路层应运而生，它定了如何格式化数据以进行传输，提供错误检测和纠正，以确保数据传输的可靠性\n层数据：帧\n存在的物理设备：交换机（对帧解码，并根据帧中包含的信息，把数据发送给正确的接收方）。\n\n##### 第三层，网络层\n\n随着网络节点的不断增加，点对点通信的时候需要经过多个结点，如何到达目标节点、如何选择最佳路径便成为了首要需求。\n作用：是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先级，网络拥塞程度，服务质量，可选路由的花费决定从节点A到结点B的最佳路径。\n层数据：（分组）数据报 存在的物理设备：路由器（由于网络层处理并智能指导数据传送，路由器连接网络各段）\n需要关注的协议： IP\n\n##### 第四层，传输层\n\n随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很多时间，而网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发出的数据进行切分，切割为一个一个的段落，即segment进行发送，其中一个段落丢失了该怎么办，要不要重传，每个段落要按照顺序到达吗。这便是传输层需要考虑的问题。\n传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，同时传输层解决了传输质量的问题，该层是OSI模型中最重要的一层。具有传输协议，同时进行流量控制，或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网不能直接接收大于1500字节的数据包，发送方结点的传输层将数据分割成较小的数据片，同时为每一数据片安排序列号，以便数据到达接收方结点的传输层时能以正确的顺序重组，该过程称为排序。\n层数据：分段\n需要关注的协议：TCP/UDP\n\n##### 第五层，会话层\n\n现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道每次都需要调用tcp协议去打包，然后调IP协议去找路由，自己去发，这样当然不行。因此我们要建立一个自动收发包，自动寻址的功能。于是发明了会话层\n作用：建立和管理应用程序间的通讯\n\n##### 第六层，表示层\n\n现在能保证应用程序能自动收发包和寻址，但我要用linux给windows发包，两个系统的语法不一致。\n作用：解决不同系统之间的通信语法问题，在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用网络的类型不同而不同。\n\n##### 第七层，应用层\n\n此时虽然发送方知道发送的是什么东西，转换成字节数组有多长，但接收方不知道，所以应用层的网络协议诞生了\n作用：规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，方便接受方能够正确解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层，你也可以直接在两台电脑传递，只不过都是1、0的字节数组。\n需要关注的协议：http协议\n\n从应用层开始都会对要传输信息的头部进行处理，加上本层的一些信息，最终物理层通过以太网，电缆等介质将数据解析成比特流，在网络中传输。数据传递到目标地址并自底而上的将头部的内容解析分离出来。\n\nOSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的指定。即OSI参考模型并不是一个标准，而是制定标准是所使用的概念性框架。\nTCP\\IP : OSI的一种实现\n\n![OSI](/articleImage/2020-07-03/osi.gif)","slug":"计算机网络","published":1,"updated":"2020-07-08T09:38:30.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtua0022ycto9rtv9ytt","content":"<h3 id=\"网络基础知识\"><a href=\"#网络基础知识\" class=\"headerlink\" title=\"网络基础知识\"></a>网络基础知识</h3><p><img src=\"/articleImage/2020-07-03/1.png\" alt=\"七层协议\"></p>\n<h5 id=\"第一层：物理层\"><a href=\"#第一层：物理层\" class=\"headerlink\" title=\"第一层：物理层\"></a>第一层：物理层</h5><p>解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。<br>物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率<br>主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。<br>层数据：比特<br>存在的物理设备：网卡</p>\n<a id=\"more\"></a>\n\n<h5 id=\"第二层：数据链路层\"><a href=\"#第二层：数据链路层\" class=\"headerlink\" title=\"第二层：数据链路层\"></a>第二层：数据链路层</h5><p>在传输比特流的时候会出现错传、传输不完整的情况，因此数据链路层应运而生，它定了如何格式化数据以进行传输，提供错误检测和纠正，以确保数据传输的可靠性<br>层数据：帧<br>存在的物理设备：交换机（对帧解码，并根据帧中包含的信息，把数据发送给正确的接收方）。</p>\n<h5 id=\"第三层，网络层\"><a href=\"#第三层，网络层\" class=\"headerlink\" title=\"第三层，网络层\"></a>第三层，网络层</h5><p>随着网络节点的不断增加，点对点通信的时候需要经过多个结点，如何到达目标节点、如何选择最佳路径便成为了首要需求。<br>作用：是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先级，网络拥塞程度，服务质量，可选路由的花费决定从节点A到结点B的最佳路径。<br>层数据：（分组）数据报 存在的物理设备：路由器（由于网络层处理并智能指导数据传送，路由器连接网络各段）<br>需要关注的协议： IP</p>\n<h5 id=\"第四层，传输层\"><a href=\"#第四层，传输层\" class=\"headerlink\" title=\"第四层，传输层\"></a>第四层，传输层</h5><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很多时间，而网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发出的数据进行切分，切割为一个一个的段落，即segment进行发送，其中一个段落丢失了该怎么办，要不要重传，每个段落要按照顺序到达吗。这便是传输层需要考虑的问题。<br>传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，同时传输层解决了传输质量的问题，该层是OSI模型中最重要的一层。具有传输协议，同时进行流量控制，或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网不能直接接收大于1500字节的数据包，发送方结点的传输层将数据分割成较小的数据片，同时为每一数据片安排序列号，以便数据到达接收方结点的传输层时能以正确的顺序重组，该过程称为排序。<br>层数据：分段<br>需要关注的协议：TCP/UDP</p>\n<h5 id=\"第五层，会话层\"><a href=\"#第五层，会话层\" class=\"headerlink\" title=\"第五层，会话层\"></a>第五层，会话层</h5><p>现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道每次都需要调用tcp协议去打包，然后调IP协议去找路由，自己去发，这样当然不行。因此我们要建立一个自动收发包，自动寻址的功能。于是发明了会话层<br>作用：建立和管理应用程序间的通讯</p>\n<h5 id=\"第六层，表示层\"><a href=\"#第六层，表示层\" class=\"headerlink\" title=\"第六层，表示层\"></a>第六层，表示层</h5><p>现在能保证应用程序能自动收发包和寻址，但我要用linux给windows发包，两个系统的语法不一致。<br>作用：解决不同系统之间的通信语法问题，在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用网络的类型不同而不同。</p>\n<h5 id=\"第七层，应用层\"><a href=\"#第七层，应用层\" class=\"headerlink\" title=\"第七层，应用层\"></a>第七层，应用层</h5><p>此时虽然发送方知道发送的是什么东西，转换成字节数组有多长，但接收方不知道，所以应用层的网络协议诞生了<br>作用：规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，方便接受方能够正确解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层，你也可以直接在两台电脑传递，只不过都是1、0的字节数组。<br>需要关注的协议：http协议</p>\n<p>从应用层开始都会对要传输信息的头部进行处理，加上本层的一些信息，最终物理层通过以太网，电缆等介质将数据解析成比特流，在网络中传输。数据传递到目标地址并自底而上的将头部的内容解析分离出来。</p>\n<p>OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的指定。即OSI参考模型并不是一个标准，而是制定标准是所使用的概念性框架。<br>TCP\\IP : OSI的一种实现</p>\n<p><img src=\"/articleImage/2020-07-03/osi.gif\" alt=\"OSI\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"网络基础知识\"><a href=\"#网络基础知识\" class=\"headerlink\" title=\"网络基础知识\"></a>网络基础知识</h3><p><img src=\"/articleImage/2020-07-03/1.png\" alt=\"七层协议\"></p>\n<h5 id=\"第一层：物理层\"><a href=\"#第一层：物理层\" class=\"headerlink\" title=\"第一层：物理层\"></a>第一层：物理层</h5><p>解决两台物理机的通信需求，具体就是机器A向机器B发送比特流，机器B能收到比特流。<br>物理层定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率<br>主要作用是传输比特流，将他们转换为电流强弱来传输，到达目的地后在转化为0101的字节码。<br>层数据：比特<br>存在的物理设备：网卡</p>","more":"<h5 id=\"第二层：数据链路层\"><a href=\"#第二层：数据链路层\" class=\"headerlink\" title=\"第二层：数据链路层\"></a>第二层：数据链路层</h5><p>在传输比特流的时候会出现错传、传输不完整的情况，因此数据链路层应运而生，它定了如何格式化数据以进行传输，提供错误检测和纠正，以确保数据传输的可靠性<br>层数据：帧<br>存在的物理设备：交换机（对帧解码，并根据帧中包含的信息，把数据发送给正确的接收方）。</p>\n<h5 id=\"第三层，网络层\"><a href=\"#第三层，网络层\" class=\"headerlink\" title=\"第三层，网络层\"></a>第三层，网络层</h5><p>随着网络节点的不断增加，点对点通信的时候需要经过多个结点，如何到达目标节点、如何选择最佳路径便成为了首要需求。<br>作用：是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先级，网络拥塞程度，服务质量，可选路由的花费决定从节点A到结点B的最佳路径。<br>层数据：（分组）数据报 存在的物理设备：路由器（由于网络层处理并智能指导数据传送，路由器连接网络各段）<br>需要关注的协议： IP</p>\n<h5 id=\"第四层，传输层\"><a href=\"#第四层，传输层\" class=\"headerlink\" title=\"第四层，传输层\"></a>第四层，传输层</h5><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很多时间，而网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发出的数据进行切分，切割为一个一个的段落，即segment进行发送，其中一个段落丢失了该怎么办，要不要重传，每个段落要按照顺序到达吗。这便是传输层需要考虑的问题。<br>传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，同时传输层解决了传输质量的问题，该层是OSI模型中最重要的一层。具有传输协议，同时进行流量控制，或是基于接收方可接受数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网不能直接接收大于1500字节的数据包，发送方结点的传输层将数据分割成较小的数据片，同时为每一数据片安排序列号，以便数据到达接收方结点的传输层时能以正确的顺序重组，该过程称为排序。<br>层数据：分段<br>需要关注的协议：TCP/UDP</p>\n<h5 id=\"第五层，会话层\"><a href=\"#第五层，会话层\" class=\"headerlink\" title=\"第五层，会话层\"></a>第五层，会话层</h5><p>现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道每次都需要调用tcp协议去打包，然后调IP协议去找路由，自己去发，这样当然不行。因此我们要建立一个自动收发包，自动寻址的功能。于是发明了会话层<br>作用：建立和管理应用程序间的通讯</p>\n<h5 id=\"第六层，表示层\"><a href=\"#第六层，表示层\" class=\"headerlink\" title=\"第六层，表示层\"></a>第六层，表示层</h5><p>现在能保证应用程序能自动收发包和寻址，但我要用linux给windows发包，两个系统的语法不一致。<br>作用：解决不同系统之间的通信语法问题，在表示层，数据将按照网络能理解的方案进行格式化。这种格式化也因所使用网络的类型不同而不同。</p>\n<h5 id=\"第七层，应用层\"><a href=\"#第七层，应用层\" class=\"headerlink\" title=\"第七层，应用层\"></a>第七层，应用层</h5><p>此时虽然发送方知道发送的是什么东西，转换成字节数组有多长，但接收方不知道，所以应用层的网络协议诞生了<br>作用：规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，方便接受方能够正确解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层，你也可以直接在两台电脑传递，只不过都是1、0的字节数组。<br>需要关注的协议：http协议</p>\n<p>从应用层开始都会对要传输信息的头部进行处理，加上本层的一些信息，最终物理层通过以太网，电缆等介质将数据解析成比特流，在网络中传输。数据传递到目标地址并自底而上的将头部的内容解析分离出来。</p>\n<p>OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的指定。即OSI参考模型并不是一个标准，而是制定标准是所使用的概念性框架。<br>TCP\\IP : OSI的一种实现</p>\n<p><img src=\"/articleImage/2020-07-03/osi.gif\" alt=\"OSI\"></p>"},{"title":"hexo自动部署至VPS","date":"2017-03-03T06:14:15.000Z","_content":"之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low~”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了~o(￣▽￣)o~ (小装一波~)。\n>最终实现：自己电脑上新建文章后，hexo clean && hexo g -d 即可。\n>实现原理：\n>1.hexo 提交代码渲染后文件至远程仓库(coding)\n>2.coding中对应项目配置webhook发送执行请求\n>3.vps 接收指定请求执行脚本(拉取最新代码)\n<!--more-->\n\n操作分为本机上和vps上的操作。\n### hexo本地配置及部署\n>hexo是基于nodejs开发的，npm是nodejs的包管理工具\n>git用于部署代码\n>所以首页应确认本机环境：git，node.js环境\n>git,node.js安装可另查资料\n\n{% codeblock %}\n#安装hexo命令行工具\nnpm install hexo-cli -g\n#创建blog目录，并初始化hexo项目\nhexo init blog\ncd blog\nhexo new \"My First Post\"\n#生成相关静态文件\nhexo g\n#启动本地服务，查看效果（http://localhost:4000）\nhexo server\n{% endcodeblock %}\n\nhexo的git配置，hexo根目录下_config.yml文件中\n{% codeblock %}\ndeploy:\n  type: git\n  message: update\n  repo: git@git.coding.net:letra/hexo.git \n{% endcodeblock %}\n{% codeblock %}\n#代码部署\nhexo deploy\n{% endcodeblock %}\n如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了\n重点来了！！！\n### 远程仓库配置WebHooks\n![](/img/articleImg/webhook.png)\n这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到http://karson.cc:4002/webhooks/push/123456。\n\n为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。\n\n到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。\n\n### VPS相关配置\n在hexo目录中新建webhook.js,内容如下：\n{% codeblock %}\nvar http = require('http')\nvar exec = require('child_process').exec\nhttp.createServer(function (req, res) {\n#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。\nif(req.url === '/webhooks/push/123456'){\n#如果url匹配，表示认证通过，则执行 sh ./deploy.sh\nexec('sh ./deploy.sh')\n}\nres.end()\n}).listen(4002)\n{% endcodeblock %}\n这段代码就能启动一个nodejs服务，监听4002端口。\n当请求过来的url完全匹配的时候，执行deploy.sh。\n再新建一个文件deploy.sh处理部署相关脚本，内容如下：\n{% codeblock %}\ngit pull origin master\n{% endcodeblock %}\n然后在服务器中启动nodejs服务监听webhooks\n使用PM2执行脚本[PM2](http://www.cnblogs.com/zhongweiv/p/pm2.html)\n{% codeblock %}\nnpm install pm2 -g\npm2 start webhook.js\n{% endcodeblock %}\n然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了...","source":"_posts/webhook.md","raw":"---\ntitle: hexo自动部署至VPS\ndate: 2017-03-03 14:14:15\ntags:\n\t- Git\n\t- Webhook\ncategories: [运维,其他]\n---\n之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low~”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了~o(￣▽￣)o~ (小装一波~)。\n>最终实现：自己电脑上新建文章后，hexo clean && hexo g -d 即可。\n>实现原理：\n>1.hexo 提交代码渲染后文件至远程仓库(coding)\n>2.coding中对应项目配置webhook发送执行请求\n>3.vps 接收指定请求执行脚本(拉取最新代码)\n<!--more-->\n\n操作分为本机上和vps上的操作。\n### hexo本地配置及部署\n>hexo是基于nodejs开发的，npm是nodejs的包管理工具\n>git用于部署代码\n>所以首页应确认本机环境：git，node.js环境\n>git,node.js安装可另查资料\n\n{% codeblock %}\n#安装hexo命令行工具\nnpm install hexo-cli -g\n#创建blog目录，并初始化hexo项目\nhexo init blog\ncd blog\nhexo new \"My First Post\"\n#生成相关静态文件\nhexo g\n#启动本地服务，查看效果（http://localhost:4000）\nhexo server\n{% endcodeblock %}\n\nhexo的git配置，hexo根目录下_config.yml文件中\n{% codeblock %}\ndeploy:\n  type: git\n  message: update\n  repo: git@git.coding.net:letra/hexo.git \n{% endcodeblock %}\n{% codeblock %}\n#代码部署\nhexo deploy\n{% endcodeblock %}\n如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了\n重点来了！！！\n### 远程仓库配置WebHooks\n![](/img/articleImg/webhook.png)\n这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到http://karson.cc:4002/webhooks/push/123456。\n\n为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。\n\n到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。\n\n### VPS相关配置\n在hexo目录中新建webhook.js,内容如下：\n{% codeblock %}\nvar http = require('http')\nvar exec = require('child_process').exec\nhttp.createServer(function (req, res) {\n#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。\nif(req.url === '/webhooks/push/123456'){\n#如果url匹配，表示认证通过，则执行 sh ./deploy.sh\nexec('sh ./deploy.sh')\n}\nres.end()\n}).listen(4002)\n{% endcodeblock %}\n这段代码就能启动一个nodejs服务，监听4002端口。\n当请求过来的url完全匹配的时候，执行deploy.sh。\n再新建一个文件deploy.sh处理部署相关脚本，内容如下：\n{% codeblock %}\ngit pull origin master\n{% endcodeblock %}\n然后在服务器中启动nodejs服务监听webhooks\n使用PM2执行脚本[PM2](http://www.cnblogs.com/zhongweiv/p/pm2.html)\n{% codeblock %}\nnpm install pm2 -g\npm2 start webhook.js\n{% endcodeblock %}\n然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了...","slug":"webhook","published":1,"updated":"2020-07-02T03:38:14.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtuc0027ycto2wr5alw9","content":"<p>之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low<del>”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了</del>o(￣▽￣)o~ (小装一波~)。</p>\n<blockquote>\n<p>最终实现：自己电脑上新建文章后，hexo clean &amp;&amp; hexo g -d 即可。<br>实现原理：<br>1.hexo 提交代码渲染后文件至远程仓库(coding)<br>2.coding中对应项目配置webhook发送执行请求<br>3.vps 接收指定请求执行脚本(拉取最新代码)</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>操作分为本机上和vps上的操作。</p>\n<h3 id=\"hexo本地配置及部署\"><a href=\"#hexo本地配置及部署\" class=\"headerlink\" title=\"hexo本地配置及部署\"></a>hexo本地配置及部署</h3><blockquote>\n<p>hexo是基于nodejs开发的，npm是nodejs的包管理工具<br>git用于部署代码<br>所以首页应确认本机环境：git，node.js环境<br>git,node.js安装可另查资料</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装hexo命令行工具</span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">#创建blog目录，并初始化hexo项目</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">hexo new &quot;My First Post&quot;</span><br><span class=\"line\">#生成相关静态文件</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">#启动本地服务，查看效果（http:&#x2F;&#x2F;localhost:4000）</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n<p>hexo的git配置，hexo根目录下_config.yml文件中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  message: update</span><br><span class=\"line\">  repo: git@git.coding.net:letra&#x2F;hexo.git </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#代码部署</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了<br>重点来了！！！</p>\n<h3 id=\"远程仓库配置WebHooks\"><a href=\"#远程仓库配置WebHooks\" class=\"headerlink\" title=\"远程仓库配置WebHooks\"></a>远程仓库配置WebHooks</h3><p><img src=\"/img/articleImg/webhook.png\" alt=\"\"><br>这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到<a href=\"http://karson.cc:4002/webhooks/push/123456。\" target=\"_blank\" rel=\"noopener\">http://karson.cc:4002/webhooks/push/123456。</a></p>\n<p>为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。</p>\n<p>到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。</p>\n<h3 id=\"VPS相关配置\"><a href=\"#VPS相关配置\" class=\"headerlink\" title=\"VPS相关配置\"></a>VPS相关配置</h3><p>在hexo目录中新建webhook.js,内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http &#x3D; require(&#39;http&#39;)</span><br><span class=\"line\">var exec &#x3D; require(&#39;child_process&#39;).exec</span><br><span class=\"line\">http.createServer(function (req, res) &#123;</span><br><span class=\"line\">#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。</span><br><span class=\"line\">if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;webhooks&#x2F;push&#x2F;123456&#39;)&#123;</span><br><span class=\"line\">#如果url匹配，表示认证通过，则执行 sh .&#x2F;deploy.sh</span><br><span class=\"line\">exec(&#39;sh .&#x2F;deploy.sh&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">res.end()</span><br><span class=\"line\">&#125;).listen(4002)</span><br></pre></td></tr></table></figure>\n<p>这段代码就能启动一个nodejs服务，监听4002端口。<br>当请求过来的url完全匹配的时候，执行deploy.sh。<br>再新建一个文件deploy.sh处理部署相关脚本，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>然后在服务器中启动nodejs服务监听webhooks<br>使用PM2执行脚本<a href=\"http://www.cnblogs.com/zhongweiv/p/pm2.html\" target=\"_blank\" rel=\"noopener\">PM2</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2 -g</span><br><span class=\"line\">pm2 start webhook.js</span><br></pre></td></tr></table></figure>\n<p>然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了…</p>\n","site":{"data":{}},"excerpt":"<p>之前每次写好一篇博文后，都是傻傻的打包利用Xftp手动传至VPS中。简直就是一个字“low<del>”。自从利用webhook实现自动部署后，腰不酸了，腿不疼了，可以扛两袋米一口气上五楼了</del>o(￣▽￣)o~ (小装一波~)。</p>\n<blockquote>\n<p>最终实现：自己电脑上新建文章后，hexo clean &amp;&amp; hexo g -d 即可。<br>实现原理：<br>1.hexo 提交代码渲染后文件至远程仓库(coding)<br>2.coding中对应项目配置webhook发送执行请求<br>3.vps 接收指定请求执行脚本(拉取最新代码)</p>\n</blockquote>","more":"<p>操作分为本机上和vps上的操作。</p>\n<h3 id=\"hexo本地配置及部署\"><a href=\"#hexo本地配置及部署\" class=\"headerlink\" title=\"hexo本地配置及部署\"></a>hexo本地配置及部署</h3><blockquote>\n<p>hexo是基于nodejs开发的，npm是nodejs的包管理工具<br>git用于部署代码<br>所以首页应确认本机环境：git，node.js环境<br>git,node.js安装可另查资料</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装hexo命令行工具</span><br><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">#创建blog目录，并初始化hexo项目</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">hexo new &quot;My First Post&quot;</span><br><span class=\"line\">#生成相关静态文件</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">#启动本地服务，查看效果（http:&#x2F;&#x2F;localhost:4000）</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n<p>hexo的git配置，hexo根目录下_config.yml文件中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  message: update</span><br><span class=\"line\">  repo: git@git.coding.net:letra&#x2F;hexo.git </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#代码部署</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>如果正确，然后在你的远程Git仓库中就有了hexo项目的相关文件了<br>重点来了！！！</p>\n<h3 id=\"远程仓库配置WebHooks\"><a href=\"#远程仓库配置WebHooks\" class=\"headerlink\" title=\"远程仓库配置WebHooks\"></a>远程仓库配置WebHooks</h3><p><img src=\"/img/articleImg/webhook.png\" alt=\"\"><br>这张图的配置的意思是：当仓库发生push的时候，会发送一个请求到<a href=\"http://karson.cc:4002/webhooks/push/123456。\" target=\"_blank\" rel=\"noopener\">http://karson.cc:4002/webhooks/push/123456。</a></p>\n<p>为了服务端的简易处理，这里没有使用token，而是将url地址当做token，123456就充当了token的角色。</p>\n<p>到这，仓库这边的配置就完成了，接下来的问题就是服务器如何接收这个请求并重新部署hexo了。</p>\n<h3 id=\"VPS相关配置\"><a href=\"#VPS相关配置\" class=\"headerlink\" title=\"VPS相关配置\"></a>VPS相关配置</h3><p>在hexo目录中新建webhook.js,内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http &#x3D; require(&#39;http&#39;)</span><br><span class=\"line\">var exec &#x3D; require(&#39;child_process&#39;).exec</span><br><span class=\"line\">http.createServer(function (req, res) &#123;</span><br><span class=\"line\">#该路径与WebHooks中的路径部分需要完全匹配，实现简易的授权认证。</span><br><span class=\"line\">if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;webhooks&#x2F;push&#x2F;123456&#39;)&#123;</span><br><span class=\"line\">#如果url匹配，表示认证通过，则执行 sh .&#x2F;deploy.sh</span><br><span class=\"line\">exec(&#39;sh .&#x2F;deploy.sh&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">res.end()</span><br><span class=\"line\">&#125;).listen(4002)</span><br></pre></td></tr></table></figure>\n<p>这段代码就能启动一个nodejs服务，监听4002端口。<br>当请求过来的url完全匹配的时候，执行deploy.sh。<br>再新建一个文件deploy.sh处理部署相关脚本，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>然后在服务器中启动nodejs服务监听webhooks<br>使用PM2执行脚本<a href=\"http://www.cnblogs.com/zhongweiv/p/pm2.html\" target=\"_blank\" rel=\"noopener\">PM2</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2 -g</span><br><span class=\"line\">pm2 start webhook.js</span><br></pre></td></tr></table></figure>\n<p>然后可以在本机中hexo d 命令，vps就会自动更新hexo文件了…</p>"},{"title":"自定义注解","date":"2020-07-24T09:27:44.000Z","_content":"\n### **JAVA注解**\n\n>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。\n\n### **内置注解**\n\nJava 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。\n\n 1、作用在代码的注解:\n\n- `@Override` - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\n- `@Deprecated` - 标记过时方法。如果使用该方法，会报编译警告。\n- `@SuppressWarnings` - 指示编译器去忽略注解中声明的警告。<!--more-->\n\n2、作用在其他注解的注解(或者说**元注解**):\n\n- `@Retention` - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\n- `@Documented` - 标记这些注解是否包含在用户文档中。\n- `@Target` - 标记这个注解应该是哪种 Java 成员。\n- `@Inherited` - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\n\n3、从 Java 7 开始，额外添加了 3 个注解:\n\n- `@SafeVarargs` - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\n- `@FunctionalInterface` - Java 8 开始支持，标识一个匿名函数或函数式接口。\n- `@Repeatable` - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。\n\n### **元注解**\n\n1、**@Target**\n\n`@Target` 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值\n\n- ElementType.TYPE 可以应用于类的任何元素。\n- ElementType.FIELD 可以应用于字段或属性。\n- ElementType.METHOD 可以应用于方法级注释。\n- ElementType.PARAMETER 可以应用于方法的参数。\n- ElementType.CONSTRUCTOR 可以应用于构造函数。\n- ElementType.LOCAL_VARIABLE 可以应用于局部变量。\n- ElementType.ANNOTATION_TYPE 可以应用于注释类型。\n- ElementType.PACKAGE 可以应用于包声明。\n- ElementType.TYPE_PARAMETER\n- ElementType.TYPE_USE\n\n2、**@Retention**\n\n`@Retention` annotation指定标记注释的存储方式：\n\n- RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。\n- RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。\n- RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。\n\n3、**@Documented**\n\n`@Documented` 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。\n\n4、**@Inherited**\n\n`@Inherited` 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。\n\n5、**@Repeatable**\n\nRepeatable Java SE 8中引入的，`@Repeatable`注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。\n\n### **自定义注解**\n\nJava中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface SPI {\n    /**\n     * default extension name\n     */\n    String value() default \"\";\n}\n```\n\n我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？\n\n```java\nimport java.lang.annotation.Annotation;\npublic class MyAnnotation implements Annotation {\n    @Override\n    public Class<? extends Annotation> annotationType() {\n        return null;\n    }\n}\n```\n\n发现Annotation接口中只有一个annotationType的方法，而且通过源码的注释我们可以发现答案是不能。![img](/articleImage/2020-07-24/3.png)汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。\n\n### **利用反射解析注解**\n\n```java\npublic class AnnotationTest {\n    public static void main(String[] args) {\n        try {\n            //获取DemoClass的Class对象\n            DemoClass demo = DemoClass.builder().build();\n            Class clazz = demo.getClass();\n            //判断DemoClass对象上是否有DemoAnnotation注解\n            if (clazz.isAnnotationPresent(DemoAnnotation.class)) {\n                System.out.println(\"DemoClass类上配置了DemoAnnotation注解！\");\n                //获取该对象上DemoAnnotation类型的注解\n                DemoAnnotation demoAnno = (DemoAnnotation) clazz.getAnnotation(DemoAnnotation.class);\n                System.out.println(\"DemoClass.name :\" + demoAnno.value()));\n            } else {\n                System.out.println(\"DemoClass类上没有配置DemoAnnotation注解！\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 实例：**自定义日期格式校验注解**\n\n```java\nimport org.apache.commons.lang3.time.DateUtils;\nimport javax.validation.Constraint;\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport javax.validation.Payload;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.text.ParseException;\nimport java.util.Date;\nimport static java.lang.annotation.ElementType.*;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author karson\n */\n@Target({FIELD})\n@Retention(RUNTIME)\n@Documented\n@Constraint(validatedBy = {DateValidator.DateValidatorInner.class})\npublic @interface DateValidator {\n\n    /**\n     * 必须的属性\n     * 显示 校验信息\n     * 利用 {} 获取 属性值，参考了官方的message编写方式\n     *@see org.hibernate.validator 静态资源包里面 message 编写方式\n     */\n    String message() default \"日期格式不匹配{dateFormat}\";\n\n    /**\n     * 必须的属性\n     * 用于分组校验\n     */\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n    /**\n     * 非必须\n     */\n    String dateFormat() default \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * 必须实现 ConstraintValidator接口\n     */\n    class DateValidatorInner implements ConstraintValidator<DateValidator, String> {\n        private String dateFormat;\n\n        @Override\n        public void initialize(DateValidator constraintAnnotation) {\n            this.dateFormat = constraintAnnotation.dateFormat();\n\n        }\n\n        /**\n         * 校验逻辑的实现\n         * @param value 需要校验的 值\n         * @return 布尔值结果\n         */\n        @Override\n        public boolean isValid(String value, ConstraintValidatorContext context) {\n            if (value == null) {\n                return true;\n            }\n            if(\"\".equals(value)){\n                return true;\n            }\n            try {\n                Date date = DateUtils.parseDate(value, dateFormat);\n                return date != null;\n            } catch (ParseException e) {\n                return false;\n            }\n        }\n    }\n}\n\n```\n\n\n\n","source":"_posts/自定义注解.md","raw":"---\ntitle: 自定义注解\ndate: 2020-07-24 17:27:44\ncategories:\n\t- 编程\n\t- Java\n\n---\n\n### **JAVA注解**\n\n>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。\n\n### **内置注解**\n\nJava 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。\n\n 1、作用在代码的注解:\n\n- `@Override` - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\n- `@Deprecated` - 标记过时方法。如果使用该方法，会报编译警告。\n- `@SuppressWarnings` - 指示编译器去忽略注解中声明的警告。<!--more-->\n\n2、作用在其他注解的注解(或者说**元注解**):\n\n- `@Retention` - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\n- `@Documented` - 标记这些注解是否包含在用户文档中。\n- `@Target` - 标记这个注解应该是哪种 Java 成员。\n- `@Inherited` - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\n\n3、从 Java 7 开始，额外添加了 3 个注解:\n\n- `@SafeVarargs` - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\n- `@FunctionalInterface` - Java 8 开始支持，标识一个匿名函数或函数式接口。\n- `@Repeatable` - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。\n\n### **元注解**\n\n1、**@Target**\n\n`@Target` 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值\n\n- ElementType.TYPE 可以应用于类的任何元素。\n- ElementType.FIELD 可以应用于字段或属性。\n- ElementType.METHOD 可以应用于方法级注释。\n- ElementType.PARAMETER 可以应用于方法的参数。\n- ElementType.CONSTRUCTOR 可以应用于构造函数。\n- ElementType.LOCAL_VARIABLE 可以应用于局部变量。\n- ElementType.ANNOTATION_TYPE 可以应用于注释类型。\n- ElementType.PACKAGE 可以应用于包声明。\n- ElementType.TYPE_PARAMETER\n- ElementType.TYPE_USE\n\n2、**@Retention**\n\n`@Retention` annotation指定标记注释的存储方式：\n\n- RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。\n- RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。\n- RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。\n\n3、**@Documented**\n\n`@Documented` 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。\n\n4、**@Inherited**\n\n`@Inherited` 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。\n\n5、**@Repeatable**\n\nRepeatable Java SE 8中引入的，`@Repeatable`注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。\n\n### **自定义注解**\n\nJava中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface SPI {\n    /**\n     * default extension name\n     */\n    String value() default \"\";\n}\n```\n\n我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？\n\n```java\nimport java.lang.annotation.Annotation;\npublic class MyAnnotation implements Annotation {\n    @Override\n    public Class<? extends Annotation> annotationType() {\n        return null;\n    }\n}\n```\n\n发现Annotation接口中只有一个annotationType的方法，而且通过源码的注释我们可以发现答案是不能。![img](/articleImage/2020-07-24/3.png)汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。\n\n### **利用反射解析注解**\n\n```java\npublic class AnnotationTest {\n    public static void main(String[] args) {\n        try {\n            //获取DemoClass的Class对象\n            DemoClass demo = DemoClass.builder().build();\n            Class clazz = demo.getClass();\n            //判断DemoClass对象上是否有DemoAnnotation注解\n            if (clazz.isAnnotationPresent(DemoAnnotation.class)) {\n                System.out.println(\"DemoClass类上配置了DemoAnnotation注解！\");\n                //获取该对象上DemoAnnotation类型的注解\n                DemoAnnotation demoAnno = (DemoAnnotation) clazz.getAnnotation(DemoAnnotation.class);\n                System.out.println(\"DemoClass.name :\" + demoAnno.value()));\n            } else {\n                System.out.println(\"DemoClass类上没有配置DemoAnnotation注解！\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 实例：**自定义日期格式校验注解**\n\n```java\nimport org.apache.commons.lang3.time.DateUtils;\nimport javax.validation.Constraint;\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport javax.validation.Payload;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.text.ParseException;\nimport java.util.Date;\nimport static java.lang.annotation.ElementType.*;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * @author karson\n */\n@Target({FIELD})\n@Retention(RUNTIME)\n@Documented\n@Constraint(validatedBy = {DateValidator.DateValidatorInner.class})\npublic @interface DateValidator {\n\n    /**\n     * 必须的属性\n     * 显示 校验信息\n     * 利用 {} 获取 属性值，参考了官方的message编写方式\n     *@see org.hibernate.validator 静态资源包里面 message 编写方式\n     */\n    String message() default \"日期格式不匹配{dateFormat}\";\n\n    /**\n     * 必须的属性\n     * 用于分组校验\n     */\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n    /**\n     * 非必须\n     */\n    String dateFormat() default \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * 必须实现 ConstraintValidator接口\n     */\n    class DateValidatorInner implements ConstraintValidator<DateValidator, String> {\n        private String dateFormat;\n\n        @Override\n        public void initialize(DateValidator constraintAnnotation) {\n            this.dateFormat = constraintAnnotation.dateFormat();\n\n        }\n\n        /**\n         * 校验逻辑的实现\n         * @param value 需要校验的 值\n         * @return 布尔值结果\n         */\n        @Override\n        public boolean isValid(String value, ConstraintValidatorContext context) {\n            if (value == null) {\n                return true;\n            }\n            if(\"\".equals(value)){\n                return true;\n            }\n            try {\n                Date date = DateUtils.parseDate(value, dateFormat);\n                return date != null;\n            } catch (ParseException e) {\n                return false;\n            }\n        }\n    }\n}\n\n```\n\n\n\n","slug":"自定义注解","published":1,"updated":"2020-07-24T09:44:19.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd5ugtue0029ycto5myy7j5r","content":"<h3 id=\"JAVA注解\"><a href=\"#JAVA注解\" class=\"headerlink\" title=\"JAVA注解\"></a><strong>JAVA注解</strong></h3><blockquote>\n<p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。</p>\n</blockquote>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a><strong>内置注解</strong></h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>\n<p> 1、作用在代码的注解:</p>\n<ul>\n<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>\n<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li>\n<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。<a id=\"more\"></a></li>\n</ul>\n<p>2、作用在其他注解的注解(或者说<strong>元注解</strong>):</p>\n<ul>\n<li><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>\n<li><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</li>\n<li><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</li>\n<li><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>\n</ul>\n<p>3、从 Java 7 开始，额外添加了 3 个注解:</p>\n<ul>\n<li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>\n<li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>\n<li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>\n</ul>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a><strong>元注解</strong></h3><p>1、<strong>@Target</strong></p>\n<p><code>@Target</code> 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值</p>\n<ul>\n<li>ElementType.TYPE 可以应用于类的任何元素。</li>\n<li>ElementType.FIELD 可以应用于字段或属性。</li>\n<li>ElementType.METHOD 可以应用于方法级注释。</li>\n<li>ElementType.PARAMETER 可以应用于方法的参数。</li>\n<li>ElementType.CONSTRUCTOR 可以应用于构造函数。</li>\n<li>ElementType.LOCAL_VARIABLE 可以应用于局部变量。</li>\n<li>ElementType.ANNOTATION_TYPE 可以应用于注释类型。</li>\n<li>ElementType.PACKAGE 可以应用于包声明。</li>\n<li>ElementType.TYPE_PARAMETER</li>\n<li>ElementType.TYPE_USE</li>\n</ul>\n<p>2、<strong>@Retention</strong></p>\n<p><code>@Retention</code> annotation指定标记注释的存储方式：</p>\n<ul>\n<li>RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。</li>\n<li>RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。</li>\n<li>RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。</li>\n</ul>\n<p>3、<strong>@Documented</strong></p>\n<p><code>@Documented</code> 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。</p>\n<p>4、<strong>@Inherited</strong></p>\n<p><code>@Inherited</code> 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。</p>\n<p>5、<strong>@Repeatable</strong></p>\n<p>Repeatable Java SE 8中引入的，<code>@Repeatable</code>注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。</p>\n<h3 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a><strong>自定义注解</strong></h3><p>Java中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SPI &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * default extension name</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Annotation;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAnnotation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Annotation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;? extends Annotation&gt; annotationType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现Annotation接口中只有一个annotationType的方法，而且通过源码的注释我们可以发现答案是不能。<img src=\"/articleImage/2020-07-24/3.png\" alt=\"img\">汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。</p>\n<h3 id=\"利用反射解析注解\"><a href=\"#利用反射解析注解\" class=\"headerlink\" title=\"利用反射解析注解\"></a><strong>利用反射解析注解</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnnotationTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取DemoClass的Class对象</span></span><br><span class=\"line\">            DemoClass demo = DemoClass.builder().build();</span><br><span class=\"line\">            Class clazz = demo.getClass();</span><br><span class=\"line\">            <span class=\"comment\">//判断DemoClass对象上是否有DemoAnnotation注解</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz.isAnnotationPresent(DemoAnnotation<span class=\"class\">.<span class=\"keyword\">class</span>)) </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DemoClass类上配置了DemoAnnotation注解！\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">//获取该对象上DemoAnnotation类型的注解</span></span><br><span class=\"line\">                DemoAnnotation demoAnno = (DemoAnnotation) clazz.getAnnotation(DemoAnnotation<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DemoClass.name :\"</span> + demoAnno.value()));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DemoClass类上没有配置DemoAnnotation注解！\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例：自定义日期格式校验注解\"><a href=\"#实例：自定义日期格式校验注解\" class=\"headerlink\" title=\"实例：自定义日期格式校验注解\"></a>实例：<strong>自定义日期格式校验注解</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Constraint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Payload;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Documented;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.ParseException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.annotation.ElementType.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> karson</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;FIELD&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Constraint</span>(validatedBy = &#123;DateValidator.DateValidatorInner<span class=\"class\">.<span class=\"keyword\">class</span>&#125;)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> @<span class=\"title\">interface</span> <span class=\"title\">DateValidator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 必须的属性</span></span><br><span class=\"line\"><span class=\"comment\">     * 显示 校验信息</span></span><br><span class=\"line\"><span class=\"comment\">     * 利用 &#123;&#125; 获取 属性值，参考了官方的message编写方式</span></span><br><span class=\"line\"><span class=\"comment\">     *<span class=\"doctag\">@see</span> org.hibernate.validator 静态资源包里面 message 编写方式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">message</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"日期格式不匹配</span>&#123;dateFormat&#125;<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    /**</span></span><br><span class=\"line\"><span class=\"string\">     * 必须的属性</span></span><br><span class=\"line\"><span class=\"string\">     * 用于分组校验</span></span><br><span class=\"line\"><span class=\"string\">     */</span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    /**</span></span><br><span class=\"line\"><span class=\"string\">     * 非必须</span></span><br><span class=\"line\"><span class=\"string\">     */</span></span><br><span class=\"line\"><span class=\"string\">    String dateFormat() default \"</span>yyyy-MM-dd HH:mm:ss<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    /**</span></span><br><span class=\"line\"><span class=\"string\">     * 必须实现 ConstraintValidator接口</span></span><br><span class=\"line\"><span class=\"string\">     */</span></span><br><span class=\"line\"><span class=\"string\">    class DateValidatorInner implements ConstraintValidator&lt;DateValidator, String&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">        private String dateFormat;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        @Override</span></span><br><span class=\"line\"><span class=\"string\">        public void initialize(DateValidator constraintAnnotation) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            this.dateFormat = constraintAnnotation.dateFormat();</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        /**</span></span><br><span class=\"line\"><span class=\"string\">         * 校验逻辑的实现</span></span><br><span class=\"line\"><span class=\"string\">         * @param value 需要校验的 值</span></span><br><span class=\"line\"><span class=\"string\">         * @return 布尔值结果</span></span><br><span class=\"line\"><span class=\"string\">         */</span></span><br><span class=\"line\"><span class=\"string\">        @Override</span></span><br><span class=\"line\"><span class=\"string\">        public boolean isValid(String value, ConstraintValidatorContext context) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            if (value == null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">                return true;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            if(\"</span><span class=\"string\">\".equals(value))&#123;</span></span><br><span class=\"line\"><span class=\"string\">                return true;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            try &#123;</span></span><br><span class=\"line\"><span class=\"string\">                Date date = DateUtils.parseDate(value, dateFormat);</span></span><br><span class=\"line\"><span class=\"string\">                return date != null;</span></span><br><span class=\"line\"><span class=\"string\">            &#125; catch (ParseException e) &#123;</span></span><br><span class=\"line\"><span class=\"string\">                return false;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<h3 id=\"JAVA注解\"><a href=\"#JAVA注解\" class=\"headerlink\" title=\"JAVA注解\"></a><strong>JAVA注解</strong></h3><blockquote>\n<p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。</p>\n</blockquote>\n<h3 id=\"内置注解\"><a href=\"#内置注解\" class=\"headerlink\" title=\"内置注解\"></a><strong>内置注解</strong></h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>\n<p> 1、作用在代码的注解:</p>\n<ul>\n<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>\n<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li>\n<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。","more":"</li>\n</ul>\n<p>2、作用在其他注解的注解(或者说<strong>元注解</strong>):</p>\n<ul>\n<li><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>\n<li><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</li>\n<li><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</li>\n<li><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>\n</ul>\n<p>3、从 Java 7 开始，额外添加了 3 个注解:</p>\n<ul>\n<li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>\n<li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>\n<li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>\n</ul>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a><strong>元注解</strong></h3><p>1、<strong>@Target</strong></p>\n<p><code>@Target</code> 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值</p>\n<ul>\n<li>ElementType.TYPE 可以应用于类的任何元素。</li>\n<li>ElementType.FIELD 可以应用于字段或属性。</li>\n<li>ElementType.METHOD 可以应用于方法级注释。</li>\n<li>ElementType.PARAMETER 可以应用于方法的参数。</li>\n<li>ElementType.CONSTRUCTOR 可以应用于构造函数。</li>\n<li>ElementType.LOCAL_VARIABLE 可以应用于局部变量。</li>\n<li>ElementType.ANNOTATION_TYPE 可以应用于注释类型。</li>\n<li>ElementType.PACKAGE 可以应用于包声明。</li>\n<li>ElementType.TYPE_PARAMETER</li>\n<li>ElementType.TYPE_USE</li>\n</ul>\n<p>2、<strong>@Retention</strong></p>\n<p><code>@Retention</code> annotation指定标记注释的存储方式：</p>\n<ul>\n<li>RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。</li>\n<li>RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。</li>\n<li>RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。</li>\n</ul>\n<p>3、<strong>@Documented</strong></p>\n<p><code>@Documented</code> 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。</p>\n<p>4、<strong>@Inherited</strong></p>\n<p><code>@Inherited</code> 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。</p>\n<p>5、<strong>@Repeatable</strong></p>\n<p>Repeatable Java SE 8中引入的，<code>@Repeatable</code>注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。</p>\n<h3 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a><strong>自定义注解</strong></h3><p>Java中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SPI &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * default extension name</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Annotation;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAnnotation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Annotation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;? extends Annotation&gt; annotationType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现Annotation接口中只有一个annotationType的方法，而且通过源码的注释我们可以发现答案是不能。<img src=\"/articleImage/2020-07-24/3.png\" alt=\"img\">汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。</p>\n<h3 id=\"利用反射解析注解\"><a href=\"#利用反射解析注解\" class=\"headerlink\" title=\"利用反射解析注解\"></a><strong>利用反射解析注解</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnnotationTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取DemoClass的Class对象</span></span><br><span class=\"line\">            DemoClass demo = DemoClass.builder().build();</span><br><span class=\"line\">            Class clazz = demo.getClass();</span><br><span class=\"line\">            <span class=\"comment\">//判断DemoClass对象上是否有DemoAnnotation注解</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz.isAnnotationPresent(DemoAnnotation<span class=\"class\">.<span class=\"keyword\">class</span>)) </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DemoClass类上配置了DemoAnnotation注解！\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">//获取该对象上DemoAnnotation类型的注解</span></span><br><span class=\"line\">                DemoAnnotation demoAnno = (DemoAnnotation) clazz.getAnnotation(DemoAnnotation<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DemoClass.name :\"</span> + demoAnno.value()));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"DemoClass类上没有配置DemoAnnotation注解！\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例：自定义日期格式校验注解\"><a href=\"#实例：自定义日期格式校验注解\" class=\"headerlink\" title=\"实例：自定义日期格式校验注解\"></a>实例：<strong>自定义日期格式校验注解</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Constraint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Payload;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Documented;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Retention;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.annotation.Target;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.ParseException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.annotation.ElementType.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> karson</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;FIELD&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Constraint</span>(validatedBy = &#123;DateValidator.DateValidatorInner<span class=\"class\">.<span class=\"keyword\">class</span>&#125;)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> @<span class=\"title\">interface</span> <span class=\"title\">DateValidator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 必须的属性</span></span><br><span class=\"line\"><span class=\"comment\">     * 显示 校验信息</span></span><br><span class=\"line\"><span class=\"comment\">     * 利用 &#123;&#125; 获取 属性值，参考了官方的message编写方式</span></span><br><span class=\"line\"><span class=\"comment\">     *<span class=\"doctag\">@see</span> org.hibernate.validator 静态资源包里面 message 编写方式</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">message</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"日期格式不匹配</span>&#123;dateFormat&#125;<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    /**</span></span><br><span class=\"line\"><span class=\"string\">     * 必须的属性</span></span><br><span class=\"line\"><span class=\"string\">     * 用于分组校验</span></span><br><span class=\"line\"><span class=\"string\">     */</span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    /**</span></span><br><span class=\"line\"><span class=\"string\">     * 非必须</span></span><br><span class=\"line\"><span class=\"string\">     */</span></span><br><span class=\"line\"><span class=\"string\">    String dateFormat() default \"</span>yyyy-MM-dd HH:mm:ss<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    /**</span></span><br><span class=\"line\"><span class=\"string\">     * 必须实现 ConstraintValidator接口</span></span><br><span class=\"line\"><span class=\"string\">     */</span></span><br><span class=\"line\"><span class=\"string\">    class DateValidatorInner implements ConstraintValidator&lt;DateValidator, String&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">        private String dateFormat;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        @Override</span></span><br><span class=\"line\"><span class=\"string\">        public void initialize(DateValidator constraintAnnotation) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            this.dateFormat = constraintAnnotation.dateFormat();</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        /**</span></span><br><span class=\"line\"><span class=\"string\">         * 校验逻辑的实现</span></span><br><span class=\"line\"><span class=\"string\">         * @param value 需要校验的 值</span></span><br><span class=\"line\"><span class=\"string\">         * @return 布尔值结果</span></span><br><span class=\"line\"><span class=\"string\">         */</span></span><br><span class=\"line\"><span class=\"string\">        @Override</span></span><br><span class=\"line\"><span class=\"string\">        public boolean isValid(String value, ConstraintValidatorContext context) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            if (value == null) &#123;</span></span><br><span class=\"line\"><span class=\"string\">                return true;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            if(\"</span><span class=\"string\">\".equals(value))&#123;</span></span><br><span class=\"line\"><span class=\"string\">                return true;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            try &#123;</span></span><br><span class=\"line\"><span class=\"string\">                Date date = DateUtils.parseDate(value, dateFormat);</span></span><br><span class=\"line\"><span class=\"string\">                return date != null;</span></span><br><span class=\"line\"><span class=\"string\">            &#125; catch (ParseException e) &#123;</span></span><br><span class=\"line\"><span class=\"string\">                return false;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckd5ugtss0006ycto1o4jghbi","category_id":"ckd5ugtt5000iycto9x0t8atv","_id":"ckd5ugtte000rycto83sp9560"},{"post_id":"ckd5ugtsb0000ycto5vay3tcz","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtti000zycto549x236c"},{"post_id":"ckd5ugtsb0000ycto5vay3tcz","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugttl0012yctobpvv84id"},{"post_id":"ckd5ugtte000tycto64mlfyfn","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtto0017yctocyjg8qbm"},{"post_id":"ckd5ugtte000tycto64mlfyfn","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtts001ayctodzvec0ii"},{"post_id":"ckd5ugtst0007yctoal7nejt7","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugttv001eycto83z94w1d"},{"post_id":"ckd5ugtst0007yctoal7nejt7","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugttx001iyctoeyfqck16"},{"post_id":"ckd5ugttg000wycto5xjn0o6v","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtu0001mycto12u80kjs"},{"post_id":"ckd5ugttg000wycto5xjn0o6v","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtu3001qycto552y68o5"},{"post_id":"ckd5ugttj0010yctoahem0yiy","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtu6001uycto1d8e2lg2"},{"post_id":"ckd5ugttj0010yctoahem0yiy","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtu8001yycto10yafivb"},{"post_id":"ckd5ugtsw000bycto53a01r8h","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtua0021yctofkql49c2"},{"post_id":"ckd5ugtsw000bycto53a01r8h","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtuc0026ycto93go0yzn"},{"post_id":"ckd5ugttl0013yctoda3u7r2k","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtue0028yctoa2dr6jno"},{"post_id":"ckd5ugttl0013yctoda3u7r2k","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtuh002cyctod94zhiyt"},{"post_id":"ckd5ugtsj0002ycto3bgp26gb","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtuh002eycto4poqafi8"},{"post_id":"ckd5ugtsj0002ycto3bgp26gb","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtuj002hyctodpih31sa"},{"post_id":"ckd5ugttv001fyctogtaddezk","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtuj002jyctocwdkh42a"},{"post_id":"ckd5ugttv001fyctogtaddezk","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtuk002lycto62n2fa3d"},{"post_id":"ckd5ugtsy000cycto3ogl5g8d","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtul002nyctogewy761q"},{"post_id":"ckd5ugtsy000cycto3ogl5g8d","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtum002qyctof96g3wn7"},{"post_id":"ckd5ugttx001jycto4a5zckpv","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtum002rycto88l2ft0e"},{"post_id":"ckd5ugttx001jycto4a5zckpv","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtun002tycto7wj1e0v4"},{"post_id":"ckd5ugtu0001nycto1b8oh9rw","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtun002uyctogkrb7o4h"},{"post_id":"ckd5ugtu0001nycto1b8oh9rw","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtun002vyctohkua7h91"},{"post_id":"ckd5ugtt1000fycto0il1c61k","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtun002xycto0ejsgd0n"},{"post_id":"ckd5ugtt1000fycto0il1c61k","category_id":"ckd5ugtu1001oyctob6b3b0yn","_id":"ckd5ugtuo002yycto3ch6af35"},{"post_id":"ckd5ugtsq0005ycto4asognjq","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtuo0030ycto4tg4eipg"},{"post_id":"ckd5ugtsq0005ycto4asognjq","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtup0031ycto6641d9e5"},{"post_id":"ckd5ugtua0022ycto9rtv9ytt","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtup0033yctob8twhuir"},{"post_id":"ckd5ugtua0022ycto9rtv9ytt","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtup0034ycto1le87t3c"},{"post_id":"ckd5ugtt4000hyctoadkx484v","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtuq0036ycto0s1oglpx"},{"post_id":"ckd5ugtt4000hyctoadkx484v","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtuq0037ycto8ab7fxiq"},{"post_id":"ckd5ugtue0029ycto5myy7j5r","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtur0039ycto9lw1eatc"},{"post_id":"ckd5ugtue0029ycto5myy7j5r","category_id":"ckd5ugtta000mycto4ln83qpo","_id":"ckd5ugtur003ayctogftthodg"},{"post_id":"ckd5ugtt8000lycto2o6n3niu","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtur003cycto2flpe5tw"},{"post_id":"ckd5ugtt8000lycto2o6n3niu","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtur003dycto3omfd9ik"},{"post_id":"ckd5ugttb000nyctog792e9cp","category_id":"ckd5ugtsu0008yctoesfh8w7s","_id":"ckd5ugtus003fyctoav896qi0"},{"post_id":"ckd5ugttb000nyctog792e9cp","category_id":"ckd5ugtto0016ycto6cnxfjci","_id":"ckd5ugtus003gyctoegnten3k"},{"post_id":"ckd5ugttc000pycto5n4cf7ff","category_id":"ckd5ugtul002pyctogjft90rb","_id":"ckd5ugtus003iyctogtx353p5"},{"post_id":"ckd5ugtto0018ycto28yfhmxk","category_id":"ckd5ugtso0003yctodj8q7w09","_id":"ckd5ugtut003jycto8pvb7740"},{"post_id":"ckd5ugtto0018ycto28yfhmxk","category_id":"ckd5ugtum002sycto6pecgi8y","_id":"ckd5ugtut003lyctobhaf6zpc"},{"post_id":"ckd5ugttt001bycto3l2n9dpa","category_id":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtuu003myctobc9n2uos"},{"post_id":"ckd5ugtt6000jyctofo1z3sya","category_id":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtuu003nyctoa04xgp71"},{"post_id":"ckd5ugtt6000jyctofo1z3sya","category_id":"ckd5ugtur003bycto6pu64xoa","_id":"ckd5ugtuu003pycto2rw88ihb"},{"post_id":"ckd5ugtu3001rycto33be78wc","category_id":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtuv003qyctob3qed5ue"},{"post_id":"ckd5ugtu3001rycto33be78wc","category_id":"ckd5ugtus003eyctohtn47c4y","_id":"ckd5ugtuv003ryctoe0sdaqch"},{"post_id":"ckd5ugtu6001vyctogtzy9c7b","category_id":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtuv003sycto6pzta92f"},{"post_id":"ckd5ugtu6001vyctogtzy9c7b","category_id":"ckd5ugtus003eyctohtn47c4y","_id":"ckd5ugtuv003tycto4dz8adco"},{"post_id":"ckd5ugtu9001zyctodttdcmf2","category_id":"ckd5ugtup0035yctohrkt5mvo","_id":"ckd5ugtuv003uycto098a79pq"},{"post_id":"ckd5ugtu9001zyctodttdcmf2","category_id":"ckd5ugtut003kycto7x3udc7t","_id":"ckd5ugtuv003vycto2j90gj4v"},{"post_id":"ckd5ugtuc0027ycto2wr5alw9","category_id":"ckd5ugtug002byctob0c833cr","_id":"ckd5ugtuv003wyctoh3u29yoy"},{"post_id":"ckd5ugtuc0027ycto2wr5alw9","category_id":"ckd5ugtuu003oycto4lu35794","_id":"ckd5ugtuv003xycto50adg04c"}],"PostTag":[{"post_id":"ckd5ugtsb0000ycto5vay3tcz","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugtsw000aycto9o7nddop"},{"post_id":"ckd5ugtsw000bycto53a01r8h","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugtt1000eyctog6pv27u2"},{"post_id":"ckd5ugtss0006ycto1o4jghbi","tag_id":"ckd5ugtsv0009ycto1in2bs1z","_id":"ckd5ugttd000qycto4gxnggf1"},{"post_id":"ckd5ugtss0006ycto1o4jghbi","tag_id":"ckd5ugtt3000gycto9fhc3leo","_id":"ckd5ugttg000uyctofw5xg1gy"},{"post_id":"ckd5ugtss0006ycto1o4jghbi","tag_id":"ckd5ugtt7000kycto5qgf6irt","_id":"ckd5ugtth000xyctoewr43pgs"},{"post_id":"ckd5ugtst0007yctoal7nejt7","tag_id":"ckd5ugttc000oyctoatblc1lh","_id":"ckd5ugttk0011yctobifo7rlr"},{"post_id":"ckd5ugtte000tycto64mlfyfn","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugttn0015ycto4cs518v7"},{"post_id":"ckd5ugttj0010yctoahem0yiy","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugttq0019yctogbg42yk5"},{"post_id":"ckd5ugtt1000fycto0il1c61k","tag_id":"ckd5ugttg000vycto8k0x74yt","_id":"ckd5ugttu001dyctof9d99xvi"},{"post_id":"ckd5ugttl0013yctoda3u7r2k","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugttw001hycto7o7i5wi1"},{"post_id":"ckd5ugtto0018ycto28yfhmxk","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugttz001kyctodl6vgc9g"},{"post_id":"ckd5ugtt6000jyctofo1z3sya","tag_id":"ckd5ugttm0014ycto762dattu","_id":"ckd5ugtu2001pyctohagu444v"},{"post_id":"ckd5ugttc000pycto5n4cf7ff","tag_id":"ckd5ugttu001cyctod5ny4bvc","_id":"ckd5ugtu4001sycto5wc13vbv"},{"post_id":"ckd5ugttx001jycto4a5zckpv","tag_id":"ckd5ugtsp0004yctocc6l7lqt","_id":"ckd5ugtu7001wycto8k5m4tyw"},{"post_id":"ckd5ugttg000wycto5xjn0o6v","tag_id":"ckd5ugttz001lycto7hbe2uup","_id":"ckd5ugtua0020yctogku35o7q"},{"post_id":"ckd5ugttt001bycto3l2n9dpa","tag_id":"ckd5ugtu5001tyctoctildn3b","_id":"ckd5ugtuc0025yctoc6t9cj1a"},{"post_id":"ckd5ugtu3001rycto33be78wc","tag_id":"ckd5ugtub0023yctoapvj8lvr","_id":"ckd5ugtuh002dyctodn8bfrp0"},{"post_id":"ckd5ugtu6001vyctogtzy9c7b","tag_id":"ckd5ugtuf002aycto45v66wcg","_id":"ckd5ugtuj002iyctohn6baecb"},{"post_id":"ckd5ugtuc0027ycto2wr5alw9","tag_id":"ckd5ugtt7000kycto5qgf6irt","_id":"ckd5ugtul002mycto355tc4tt"},{"post_id":"ckd5ugtuc0027ycto2wr5alw9","tag_id":"ckd5ugtui002fycto2be938jq","_id":"ckd5ugtul002oycto2qat1pbd"}],"Tag":[{"name":"Java基础","_id":"ckd5ugtsp0004yctocc6l7lqt"},{"name":"Hexo","_id":"ckd5ugtsv0009ycto1in2bs1z"},{"name":"GitHub","_id":"ckd5ugtt3000gycto9fhc3leo"},{"name":"Git","_id":"ckd5ugtt7000kycto5qgf6irt"},{"name":"Lambda","_id":"ckd5ugttc000oyctoatblc1lh"},{"name":"dubbo","_id":"ckd5ugttg000vycto8k0x74yt"},{"name":"ddos","_id":"ckd5ugttm0014ycto762dattu"},{"name":"druid","_id":"ckd5ugttu001cyctod5ny4bvc"},{"name":"JavaMail","_id":"ckd5ugttz001lycto7hbe2uup"},{"name":"Redis","_id":"ckd5ugtu5001tyctoctildn3b"},{"name":"Nginx","_id":"ckd5ugtub0023yctoapvj8lvr"},{"name":"vpn","_id":"ckd5ugtuf002aycto45v66wcg"},{"name":"Webhook","_id":"ckd5ugtui002fycto2be938jq"}]}}